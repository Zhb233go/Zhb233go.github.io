<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go语言进阶--简单的理解操作符</title>
      <link href="/hypo-Z.github.io/2023/10/19/go-yu-yan-jin-jie-jian-dan-de-li-jie-cao-zuo-fu/"/>
      <url>/hypo-Z.github.io/2023/10/19/go-yu-yan-jin-jie-jian-dan-de-li-jie-cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是位运算"><a href="#1-什么是位运算" class="headerlink" title="1.什么是位运算"></a>1.什么是位运算</h2><p>程序中的所有数在计算机内存中都是以二进制的形式储存的.位运算就是直接对整数在内存中的二进制位进行操作.比如,and运算本来是一个逻辑运算符,但整数与整数之间也可以进行and运算.举个例子,6的二进制是110,11的二进制是1011,那么6 and 11的结果就是2,它是二进制对应位进行逻辑运算的结果（0表示False,1表示True,空位都当0处理）.</p><p>感觉位运算操作符虽然在平时用得并不多,但是在涉及到底层性能优化或者使用某些trick的时候还是比较有意思.</p><p><code>&amp;(AND) |(OR)</code> 就不提了最常用的东西 会编程就会.</p><p>&amp;操作的话是当 两个数需要同时为1的时候才会保留. 例如 <code>0000 0100 &amp; 0000 1111 =&gt; 0000 0100 =&gt; 4</code></p><p>操作的话是当 两个数同时为1或者1个为1一个不为1的时候会保留. 例如 <code>0000 0100 | 0000 1111 =&gt; 0000 1111 =&gt; 15</code></p><p>本篇作为 Go 编程“边角料”的最后一篇,主要针对 Go 语言提供的操作符进行一次总结.刚好回应上篇一位读者关于表达式是否要加’.’的问题做个回复.</p><h3 id="Go语言的操作符"><a href="#Go语言的操作符" class="headerlink" title="Go语言的操作符"></a>Go语言的操作符</h3><p>在 Go 语言中,一共提供了<code>47</code>个操作符,包括标点符号.摘自<a href="https://golang.org/ref/spec#Operators_and_punctuation">官方文档</a>,分别是：</p><pre class="line-numbers language-none"><code class="language-none">+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )-    |     -=    |=     ||    &lt;     &lt;=    [    ]*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :     &amp;^          &amp;^=<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除以上操作符以外,在 Go 语言中还有一个特殊的符号 <code>_</code>, 以及一个非 Go 语言操作符的特殊字节<code>?</code>.</p><p>刨去一些常用的操作符,对其中较隐晦操作符做个简单的备注,方便不时之需.</p><p>就隐晦本身而言可以划分为两类：</p><ul><li>符号本身隐晦</li><li>应用场景隐晦</li></ul><h2 id="2-符号隐晦"><a href="#2-符号隐晦" class="headerlink" title="2.符号隐晦"></a>2.符号隐晦</h2><p>上文中的 47 个操作符,一个个看下来,真正隐晦的符号基本上都是位运算操作符或相关操作符.</p><p>之所以隐晦,因为位运算在大部分开发人员的日常开发中属于非常规操作,因为运用得少,而增加了其陌生感.不妨简单罗列一下：</p><pre class="line-numbers language-none"><code class="language-none">&amp;    bitwise AND            integers     |    bitwise OR             integers    ^    bitwise XOR            integers    &amp;^   bit clear (AND NOT)    integers  &lt;&lt;   left shift             integer &lt;&lt; unsigned integer&gt;&gt;   right shift            integer &gt;&gt; unsigned integer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>写个简单的例子, 强化记忆:</p><pre class="line-numbers language-none"><code class="language-none">package mainimport "fmt"func main(){  fmt.Printf("AND: a(%b) &amp; b(%b) = (%b)\n", 4, 5, (4 &amp; 5))  fmt.Printf("OR:  a(%b) | b(%b) = (%b)\n", 4, 5, (4 | 5))  fmt.Printf("XOR: a(%b) ^ b(%b) = (%b)\n", 4, 5, (4 ^ 5))  fmt.Printf("AND NOT: a(%b) &amp;^ b(%b) = (%b)\n", 4, 5, (4 &amp;^ 5))  fmt.Printf("Left Shift:  a(%b) &lt;&lt; 1 = (%b)\n", 5, (5 &lt;&lt; 1))  fmt.Printf("Right Shift: a(%b) &gt;&gt; 1 = (%b)\n", 5, (5 &gt;&gt; 1))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果是:</p><pre class="line-numbers language-none"><code class="language-none">AND: a(100) &amp; b(101) = (100)OR:  a(100) | b(101) = (101)XOR: a(100) ^ b(101) = (1)AND NOT: a(100) &amp;^ b(101) = (0)Left Shift:  a(101) &lt;&lt; 1 = (1010)Right Shift: a(101) &gt;&gt; 1 = (10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>位操作符并不难,之所以隐晦,主要是实际运用的少导致的.其中,XOR 运算有个特点：如果对一个值连续做两次 XOR,会返回这个值本身.XOR 的这个特点,使得它可以用于信息的加密.阮一峰这篇文章<a href="http://www.ruanyifeng.com/blog/2017/05/xor.html">XOR 加密简介</a>很好读.</p><p>与位运算符相关的符号,有：</p><pre class="line-numbers language-none"><code class="language-none">&lt;&lt;=    &gt;&gt;=    &amp;=    ^=   |=<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其功能与<code>+=</code>是一样的,即 <code>a += 1</code> 等同于 <code>a = a + 1</code>.</p><h2 id="3-场景隐晦"><a href="#3-场景隐晦" class="headerlink" title="3.场景隐晦"></a>3.场景隐晦</h2><p>另一类操作符,看似非常简单,但因其在不同应用场景下产生了不同功能效果,导致在使用上的陌生.</p><h3 id="2-1-符号-‘-’"><a href="#2-1-符号-‘-’" class="headerlink" title="2.1 符号 ‘_’"></a>2.1 符号 ‘_’</h3><p>符号 ‘_’, 又称为<strong>空标识符</strong>(Blank identifier).它有两种使用场景,不同场景提供的功能是不同的.</p><ul><li>作为匿名变量赋值使用 此时符号 ‘_’, 功能与 <code>/dev/null</code> 类似,只负责接收值并直接丢弃,无法取回.</li></ul><pre class="line-numbers language-none"><code class="language-none">ar := [10]int{1,2,3,4,5,6,7,8,9,0}for _, v := range ar {    println(v)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在包引用时使用 常规情况下,包引用格式是这样的:</li></ul><pre class="line-numbers language-none"><code class="language-none">package YourPackageimport   "lib/math"         //math.Sinimport m "lib/math"         //m.Sinimport . "lib/math"         //Sin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体语法意义不解释了.现在看看 ‘_’ 在包引入中的功能.</p><pre class="line-numbers language-none"><code class="language-none">import _ "the/third/pkg"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时引入的第三方包<code>"the/third/pkg"</code>,如果引入的结果是一个空标识符’_‘.按其空标识符的原始意义,就是对于使用方而言,没有任何意义,因为无法使用被引入包中任何变量或是函数.</p><p>但是,这种引用有一个副作用,就是：会对第三方包进行编译并且执行初始化<code>func init()</code>操作.这一功能,对于某些引用方就非常有用.</p><p>所以当我们研究一些开源代码时,看到类似的引用<code>import _ "the/third/pkg"</code>时,直接跳到引入包的<code>init</code>函数,就可以建立起内在逻辑.不妨看一下<code>github.com/golang/protobuf/protoc-gen-go/link_grpc.go</code>的代码, 这就是<code>grpc</code>插件注册到<code>protoc-gen-go</code>的地方.</p><pre class="line-numbers language-none"><code class="language-none">package mainimport _ "github.com/golang/protobuf/protoc-gen-go/grpc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-符号-‘-’"><a href="#2-2-符号-‘-’" class="headerlink" title="2.2 符号 ‘.’"></a>2.2 符号 ‘.’</h3><p>符号 ‘.’ 常规情况下是作为<strong>选择器</strong>的在使用.如：</p><pre class="line-numbers language-none"><code class="language-none">//直接选择属性名或函数名x.FieldNamex.FunctionName<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>还可以做为<strong>包引用</strong>使用,如上节.</p><pre class="line-numbers language-none"><code class="language-none">import . "lib/math"         //Sin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它的作用有点类似当前目录符’.’的意思了,简化掉了包引用的相对路径.</p><p>还有一个用法,即<strong>类型断言</strong>（type assertion）.</p><pre class="line-numbers language-none"><code class="language-none">//类型断言: 类型必须用'()'括起来v, ok := x.(T) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>作为<strong>类型断言</strong>时,类型必须用’()’括起来,防止和<strong>选择器</strong>功能混淆.<strong>类型断言</strong>与<strong>类型转换</strong>需要区分一下.</p><pre class="line-numbers language-none"><code class="language-none">//类型转换: 变量必须用'()'括起来v := T(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>区别：</p><ul><li><p><strong>类型转换</strong>中,待转换的变量<code>x</code>只要是一个可以转换成目标类型的变量即可.失败时代码无法编译通过.</p></li><li><p>类型断言</p><p>中,待断言的变量</p><pre class="line-numbers language-none"><code class="language-none">x<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>必须与目标类型一致.如果失败,返回</p><pre class="line-numbers language-none"><code class="language-none">bool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数标识.</p><h3 id="2-3-符号-‘…’"><a href="#2-3-符号-‘…’" class="headerlink" title="2.3 符号 ‘…’"></a>2.3 符号 ‘…’</h3></li></ul><p>符号 ‘…’ 主要用于不定参数与切片打散功能.非常简单,备注一下.</p><p><strong>不定参数</strong></p><pre class="line-numbers language-none"><code class="language-none">import "fmt"func Foo(args ...interface{}) {  for _, arg := range args {    fmt.Println(arg)  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>切片打散</strong></p><pre class="line-numbers language-none"><code class="language-none">args := []interface{}{1, false, "hello"}Foo(args...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>数组长度</strong></p><pre class="line-numbers language-none"><code class="language-none">[...]int{1,2,4}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-4-符号-‘-’-非-Go-语言操作符"><a href="#2-4-符号-‘-’-非-Go-语言操作符" class="headerlink" title="2.4 符号 ‘?’, 非 Go 语言操作符"></a>2.4 符号 ‘?’, 非 Go 语言操作符</h3><p>很多语言都支持符号 ‘?’, 但是在 Go 语言中并它不属于系统操作符, 虽然在 Go 代码中经常会碰到符号 ‘?’.在语言级别符号 ‘?’ 没有任何语法意义,只是一个常规的字节.</p><p>常见使用场景是做为 SQL 语句的替换符使用.如:</p><pre class="line-numbers language-none"><code class="language-none">import "database/sql"  id := 47  result, err := db.ExecContext(ctx, "UPDATE balances SET balance = balance + 10 WHERE user_id = ?", id)  if err != nil {      log.Fatal(err)  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的符号 ‘?’ 仅仅与依赖包<code>database/sql</code>有关,与 Go 语言本身无关.在<code>database/sql</code>包中,字符 ‘?’ 可以将任意类型参数变量替换转义成 SQL 字符串合适的类型值.</p><h2 id="4-更好的心智模型"><a href="#4-更好的心智模型" class="headerlink" title="4.更好的心智模型"></a>4.更好的心智模型</h2><p>人类善于用抽象符号表达想法,01序列就是其中的一种抽象符号,不过是设计给机器用的.既然谈到位运算符,免不了要与01序列打交道,于是我们开始祭出人类一大法宝：映射.01序列每一位,要么是0,要么是1,可辨识性太低,人类看久了都会打瞌睡.那么我们在这里尝试做一些转换,把01序列变成序号集合,这个序号集合从0开始,顺序从右到左.例如 00100011 转换为序号集合就是 {5, 1, 0} .</p><p>关于集合的操作您是不是想起一些东西来,没错,集合可以合并,可以求交集,可以求差集等等操作.想到集合操作,我很容易想到两个平面圆在脑海中交织,互相争夺领地,而每次集合操作的结果可以被看做是被划分出来的某些区域,这里应该很有画面感.</p><p>继续回到原先的问题上,转变模型,重新解释如下：</p><pre class="line-numbers language-none"><code class="language-none">A &amp; B  -&gt; 求交集.将两个集合共有的元素提取出来.A | B  -&gt; 求并集.将两个集合合并.A ^ B  -&gt; 求并集的补集.排除两个集合共有元素,合并两个集合剩下的元素.^A     -&gt; 求补集.A全集排除A集合之外的元素.这里存在求全集问题,A集合的全集就是所有序号的集合.A &amp;^ B -&gt; 求差集.A集合排除B集合元素.A &lt;&lt; N -&gt; A集合中的每一个序号元素加N.A &gt;&gt; N -&gt; A集合中的每一个序号元素减N.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是立刻感觉到世界变得友好了,不再充满恶意了,生活本该如此！</p><p>简单总结就是一句话,01序列可以当做序号集合对待.这算是一个小小的奇淫技巧吧！</p><p>转自<a href="https://zh.mojotv.cn/2019/07/21/golang-operator.html">https://zh.mojotv.cn/2019/07/21/golang-operator.html</a>,更多详情可前往查看,感谢大佬分享！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 操作符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用GIT钩子自动生成提交注释</title>
      <link href="/hypo-Z.github.io/2023/04/15/41-shi-yong-git-gou-zi-zi-dong-sheng-cheng-ti-jiao-zhu-shi/"/>
      <url>/hypo-Z.github.io/2023/04/15/41-shi-yong-git-gou-zi-zi-dong-sheng-cheng-ti-jiao-zhu-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="使用GIT钩子自动生成提交注释"><a href="#使用GIT钩子自动生成提交注释" class="headerlink" title="使用GIT钩子自动生成提交注释"></a>使用GIT钩子自动生成提交注释</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在GIT仓库的.git/hooks目录下创建prepare-commit-msg文件</li><li>向文件中添加如下代码:<pre class="line-numbers language-none"><code class="language-none">bash#!/bin/shCOMMIT_MSG_FILE=$1COMMIT_SOURCE=$2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="获取最近一次git-add的注释或解析diff信息"><a href="#获取最近一次git-add的注释或解析diff信息" class="headerlink" title="获取最近一次git add的注释或解析diff信息"></a>获取最近一次git add的注释或解析diff信息</h1></li></ol><pre class="line-numbers language-none"><code class="language-none">msg=...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="输出到提交注释文件"><a href="#输出到提交注释文件" class="headerlink" title="输出到提交注释文件"></a>输出到提交注释文件</h1><pre class="line-numbers language-none"><code class="language-none">echo "$msg" &gt; $COMMIT_MSG_FILE<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li><p>设置文件为可执行:</p><pre class="line-numbers language-none"><code class="language-none">bashchmod +x .git/hooks/prepare-commit-msg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>禁止GIT的权限提示:</p><pre class="line-numbers language-none"><code class="language-none">bashgit config --global advice.ignoredHook false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>提交代码,会自动生成注释</p></li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ol><li>确认默认shell,提供对应命令(如zsh)</li><li>可以获取最近git add的注释,也可以解析git diff生成详细注释</li><li>如果解析diff,需要在代码中标记接口等,如//[api]</li><li>文件必须有执行权限,否则GIT会忽略钩子</li><li>可以设置为多语言注释,提高易读性</li><li>必须禁止GIT的ignoredHook提示,否则会出现warning</li><li>提交前不需要自己输入注释,会自动生成</li><li>定制化钩子可以大大提高开发效率,值得运用</li><li>可以根据实践不断完善和增强定制钩子</li><li>请提出使用问题和反馈,不断修复BUG和提高</li></ol><h1 id="解析git-diff生成提交注释"><a href="#解析git-diff生成提交注释" class="headerlink" title="解析git diff生成提交注释"></a>解析git diff生成提交注释</h1><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>在prepare-commit-msg文件中,获取git diff结果:</p><pre class="line-numbers language-none"><code class="language-none">bashdiff=$(git diff --cached)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>解析diff,提取添加/删除/修改的接口、方法等信息:</p><pre class="line-numbers language-none"><code class="language-none">bashadded=$(echo "$diff" | grep '^+    ' | grep '\[api\]')  removed=$(echo "$diff" | grep '^-    ' | grep '\[api\]')   modified=$(echo "$diff" | grep '^\+.*\[api\].*$' | grep '\-[api\]')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>根据解析结果生成详细注释:</p><pre class="line-numbers language-none"><code class="language-none">bashif [ "$added" != "" ]; thenmsg="Add API: $added"  elif [ "$removed" != "" ]; thenmsg="Remove API: $removed"  elif [ "$modified" != "" ]; thenmsg="Modify API: $modified"elsemsg="Update files"   fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>输出生成的注释:</p><pre class="line-numbers language-none"><code class="language-none">bashecho "$msg" &gt; $COMMIT_MSG_FILE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>提交代码,会自动生成详细注释</p></li></ol><h2 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h2><ol><li>需要在代码中标记接口、方法等,如//[api]</li><li>不同语言有不同的标记方式,如Go使用//[api]</li><li>提交时保留标记,否则无法解析生成详细注释</li><li>详细注释会标明添加/删除/修改的接口、方法名称等</li><li>其他步骤同上,如设置执行权限、禁用提示等</li><li>定制化变得更加强大,但也需要更多标记维护</li><li>灵活运用,根据需要选择获取最近git add注释或解析diff</li></ol>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
            <tag> 钩子 </tag>
            
            <tag> commit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——rwmutex的实现机制</title>
      <link href="/hypo-Z.github.io/2022/10/28/go-yu-yan-jin-jie-rwmutex-de-shi-xian-ji-zhi/"/>
      <url>/hypo-Z.github.io/2022/10/28/go-yu-yan-jin-jie-rwmutex-de-shi-xian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="RWMutex的实现机制"><a href="#RWMutex的实现机制" class="headerlink" title="RWMutex的实现机制"></a>RWMutex的实现机制</h1><p>前面我们聊了互斥锁Mutex，所谓读写锁RWMutex，完整的表述应该是读写互斥锁，可以说是Mutex的一个改进版，在某些场景下可以发挥更加灵活的控制能力，比如：读取数据频率远远大于写数据频率的场景。</p><p>例如，程序中写操作少而读操作多，简单的说，如果执行过程是1次写然后N次读的话，使用Mutex，这个过程将是串行的，因为即便N次读操作互相之间并不影响，但也都需要持有Mutex后才可以操作。如果使用读写锁，多个读操作可以同时持有锁，并发能力将大大提升。</p><p>实现读写锁需要解决如下几个问题：</p><ol><li><p>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞</p></li><li><p>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞</p></li><li><p>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞</p></li><li><p>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁</p><table><thead><tr><th align="center"></th><th align="center"><strong>读</strong></th><th align="center"><strong>写</strong></th></tr></thead><tbody><tr><td align="center">读</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">写</td><td align="center">N</td><td align="center">N</td></tr></tbody></table></li></ol><p>下面我们将按照这个思路，即读写锁如何解决这些问题的，来分析读写锁的实现。</p><p>读写锁基于Mutex实现，实现源码非常简单和简洁，又有一定的技巧在里面。</p><h2 id="读写锁数据结构"><a href="#读写锁数据结构" class="headerlink" title="读写锁数据结构"></a>读写锁数据结构</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p>源码包<code>src/sync/rwmutex.go:RWMutex</code>定义了读写锁数据结构：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> RWMutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>    w           Mutex  <span class="token comment">//用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此</span>    writerSem   <span class="token builtin">uint32</span> <span class="token comment">//写阻塞等待的信号量，最后一个读者释放锁时会释放信号量</span>    readerSem   <span class="token builtin">uint32</span> <span class="token comment">//读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量</span>    readerCount <span class="token builtin">int32</span>  <span class="token comment">//记录读者个数</span>    readerWait  <span class="token builtin">int32</span>  <span class="token comment">//记录写阻塞时读者个数</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由以上数据结构可见，读写锁内部仍有一个互斥锁，用于将两个写操作隔离开来，其他的几个都用于隔离读操作和写操作。</p><p>下面我们简单看下RWMutex提供的4个接口，后面再根据使用场景具体分析这几个成员是如何配合工作的。</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><p>RWMutex提供4个简单的接口来提供服务：</p><ul><li>RLock()：读锁定</li><li>RUnlock()：解除读锁定</li><li>Lock(): 写锁定，与Mutex完全一致</li><li>Unlock()：解除写锁定，与Mutex完全一致</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Lock-实现逻辑"><a href="#Lock-实现逻辑" class="headerlink" title="Lock()实现逻辑"></a>Lock()实现逻辑</h3><p>写锁定操作需要做两件事：</p><ul><li>获取互斥锁</li><li>阻塞等待所有读操作结束（如果有的话）</li></ul><p>所以<code>func (rw *RWMutex) Lock()</code>接口实现流程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_b31533f6f5d070460b2194aa486ee040_r.png" alt="null"></p><h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// First, resolve competition with other writers.</span>rw<span class="token punctuation">.</span>w<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// Announce to readers there is a pending writer.</span>r <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerCount<span class="token punctuation">,</span> <span class="token operator">-</span>rwmutexMaxReaders<span class="token punctuation">)</span> <span class="token operator">+</span> rwmutexMaxReaders<span class="token comment">// Wait for active readers.</span><span class="token keyword">if</span> r <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerWait<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token function">runtime_SemacquireMutex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>writerSem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先调用互斥锁的 lock，获取到互斥锁之后，</p><ul><li><code>atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders)</code> 调用这个函数阻塞后续的读操作</li><li>如果计算之后当前仍然有其他 goroutine 持有读锁，那么就调用 <code>runtime_SemacquireMutex</code> 休眠当前的 goroutine 等待所有的读操作完成</li></ul><h3 id="Unlock-实现逻辑"><a href="#Unlock-实现逻辑" class="headerlink" title="Unlock()实现逻辑"></a>Unlock()实现逻辑</h3><p>解除写锁定要做两件事：</p><ul><li>唤醒因读锁定而被阻塞的协程（如果有的话）</li><li>解除互斥锁</li></ul><p>所以<code>func (rw *RWMutex) Unlock()</code>接口实现流程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_15371303a4b9903ccf8df1a1d3d6c761_r.png" alt="null"></p><h4 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Announce to readers there is no active writer.</span>r <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerCount<span class="token punctuation">,</span> rwmutexMaxReaders<span class="token punctuation">)</span><span class="token keyword">if</span> r <span class="token operator">&gt;=</span> rwmutexMaxReaders <span class="token punctuation">{</span>race<span class="token punctuation">.</span><span class="token function">Enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"sync: Unlock of unlocked RWMutex"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// Unblock blocked readers, if any.</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">int</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token function">runtime_Semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerSem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解锁的操作，会先调用 <code>atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</code> 将恢复之前写入的负数，然后根据当前有多少个读操作在等待，循环唤醒</p><h3 id="RLock-实现逻辑"><a href="#RLock-实现逻辑" class="headerlink" title="RLock()实现逻辑"></a>RLock()实现逻辑</h3><p>读锁定需要做两件事：</p><ul><li>增加读操作计数，即readerCount++</li><li>阻塞等待写操作结束(如果有的话)</li></ul><p>所以<code>func (rw *RWMutex) RLock()</code>接口实现流程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_970f3e966f918951584d728879e613c4_r.png" alt="null"></p><h4 id="源码实现-2"><a href="#源码实现-2" class="headerlink" title="源码实现"></a>源码实现</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerCount<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// A writer is pending, wait for it.</span><span class="token function">runtime_SemacquireMutex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerSem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先是读锁， <code>atomic.AddInt32(&amp;rw.readerCount, 1)</code> 调用这个原子方法，对当前在读的数量加一，如果返回负数，那么说明当前有其他写锁，这时候就调用 <code>runtime_SemacquireMutex</code> 休眠 goroutine 等待被唤醒</p><h3 id="RUnlock-实现逻辑"><a href="#RUnlock-实现逻辑" class="headerlink" title="RUnlock()实现逻辑"></a>RUnlock()实现逻辑</h3><p>解除读锁定需要做两件事：</p><ul><li>减少读操作计数，即readerCount–</li><li>唤醒等待写操作的协程（如果有的话）</li></ul><p>所以<code>func (rw *RWMutex) RUnlock()</code>接口实现流程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_0a707690c6ed961a03c503a85f679225_r.png" alt="null"></p><p>注意：即便有协程阻塞等待写操作，并不是所有的解除读锁定操作都会唤醒该协程，而是最后一个解除读锁定的协程才会释放信号量将该协程唤醒，因为只有当所有读操作的协程释放锁后才可以唤醒协程。</p><h3 id="源码实现-3"><a href="#源码实现-3" class="headerlink" title="源码实现"></a>源码实现</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> r <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerCount<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// Outlined slow-path to allow the fast-path to be inlined</span>rw<span class="token punctuation">.</span><span class="token function">rUnlockSlow</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解锁的时候对正在读的操作减一，如果返回值小于 0 那么说明当前有在写的操作，这个时候调用 <code>rUnlockSlow</code> 进入慢速通道</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rw <span class="token operator">*</span>RWMutex<span class="token punctuation">)</span> <span class="token function">rUnlockSlow</span><span class="token punctuation">(</span>r <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> r<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> r<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token operator">-</span>rwmutexMaxReaders <span class="token punctuation">{</span>race<span class="token punctuation">.</span><span class="token function">Enable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"sync: RUnlock of unlocked RWMutex"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// A writer is pending.</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>readerWait<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// The last reader unblocks the writer.</span><span class="token function">runtime_Semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rw<span class="token punctuation">.</span>writerSem<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>被阻塞的准备读的 goroutine 的数量减一，readerWait 为 0，就表示当前没有正在准备读的 goroutine 这时候调用 <code>runtime_Semrelease</code> 唤醒写操作</p><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>上面我们简单看了下4个接口实现原理，接下来我们看一下是如何解决前面提到的几个问题的。</p><h3 id="写操作是如何阻止写操作的"><a href="#写操作是如何阻止写操作的" class="headerlink" title="写操作是如何阻止写操作的"></a>写操作是如何阻止写操作的</h3><p>读写锁包含一个互斥锁(Mutex)，写锁定必须要先获取该互斥锁，如果互斥锁已被协程A获取（或者协程A在阻塞等待读结束），意味着协程A获取了互斥锁，那么协程B只能阻塞等待该互斥锁。</p><p>所以，写操作依赖互斥锁阻止其他的写操作。</p><h3 id="写操作是如何阻止读操作的"><a href="#写操作是如何阻止读操作的" class="headerlink" title="写操作是如何阻止读操作的"></a>写操作是如何阻止读操作的</h3><p>这个是读写锁实现中最精华的技巧。</p><p>我们知道RWMutex.readerCount是个整型值，用于表示读者数量，不考虑写操作的情况下，每次读锁定将该值+1，每次解除读锁定将该值-1，所以readerCount取值为[0, N]，N为读者个数，实际上最大可支持2^30个并发读者。</p><p>当写锁定进行时，会先将readerCount减去2^30，从而readerCount变成了负值，此时再有读锁定到来时检测到readerCount为负值，便知道有写操作在进行，只好阻塞等待。而真实的读操作个数并不会丢失，只需要将readerCount加上2^30即可获得。</p><p>所以，写操作将readerCount变成负值来阻止读操作的。</p><h3 id="读操作是如何阻止写操作的"><a href="#读操作是如何阻止写操作的" class="headerlink" title="读操作是如何阻止写操作的"></a>读操作是如何阻止写操作的</h3><p>读锁定会先将RWMutext.readerCount加1，此时写操作到来时发现读者数量不为0，会阻塞等待所有读操作结束。</p><p>所以，读操作通过readerCount来将来阻止写操作的。</p><h3 id="为什么写锁定不会被饿死"><a href="#为什么写锁定不会被饿死" class="headerlink" title="为什么写锁定不会被饿死"></a>为什么写锁定不会被饿死</h3><p>我们知道，写操作要等待读操作结束后才可以获得锁，写操作等待期间可能还有新的读操作持续到来，如果写操作等待所有读操作结束，很可能被饿死。然而，通过RWMutex.readerWait可完美解决这个问题。</p><p>写操作到来时，会把RWMutex.readerCount值拷贝到RWMutex.readerWait中，用于标记排在写操作前面的读者个数。</p><p>前面的读操作结束后，除了会递减RWMutex.readerCount，还会递减RWMutex.readerWait值，当RWMutex.readerWait值变为0时唤醒写操作。</p><p>所以，写操作就相当于把一段连续的读操作划分成两部分，前面的读操作结束后唤醒写操作，写操作结束后唤醒后面的读操作。如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_4cc8b286df29eeb2d3f3809977df015c_r.png" alt="null"></p><p>参考文章：</p><p><a href="https://topgoer.cn/docs/gozhuanjia/gozhuanjiamutex">Go专家编程</a></p><p><a href="https://lailin.xyz/post/go-training-week3-sync.html">mohuishou的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——mutex的实现机制</title>
      <link href="/hypo-Z.github.io/2022/10/27/go-yu-yan-jin-jie-mutex-de-shi-xian-ji-zhi/"/>
      <url>/hypo-Z.github.io/2022/10/27/go-yu-yan-jin-jie-mutex-de-shi-xian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="mutex的实现机制"><a href="#mutex的实现机制" class="headerlink" title="mutex的实现机制"></a>mutex的实现机制</h1><blockquote><p>互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock()和Unlock()分别用于加锁和解锁。</p><p>Mutex使用起来非常方便，但其内部实现却复杂得多，这包括Mutex的几种状态。另外，我们也想探究一下Mutex重复解锁引起panic的原因。</p><p>按照惯例，本节内容从源码入手，提取出实现原理，又不会过分纠结于实现细节。</p></blockquote><h2 id="Mutex数据结构"><a href="#Mutex数据结构" class="headerlink" title="Mutex数据结构"></a>Mutex数据结构</h2><p>源码包<code>src/sync/mutex.go:Mutex</code>定义了互斥锁的数据结构：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Mutex <span class="token keyword">struct</span> <span class="token punctuation">{</span>    state <span class="token builtin">int32</span>    sema  <span class="token builtin">uint32</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Mutex.state表示互斥锁的状态，比如是否被锁定等。</li><li>Mutex.sema表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。</li></ul><p>我们看到Mutex.state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态。</p><p>下图展示Mutex的内存布局：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_45a91868c2c9d5dc2617e9fda0e46049_r.png" alt="null"></p><ul><li>Locked: 表示该Mutex是否已被锁定，0：没有锁定 1：已被锁定。</li><li>Woken: 表示是否有协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。</li><li>Starving：表示该Mutex是否处于饥饿状态，0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过1ms。</li><li>Waiter: 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。</li></ul><p>协程之间抢锁实际上是抢给Locked赋值的权利，能给Locked域置1，就说明抢锁成功。抢不到的话就阻塞等待Mutex.sema信号量，一旦持有锁的协程解锁，等待的协程会依次被唤醒。</p><p>Woken和Starving主要用于控制协程间的抢锁过程，后面再进行了解。</p><h2 id="加解锁过程"><a href="#加解锁过程" class="headerlink" title="加解锁过程"></a>加解锁过程</h2><h3 id="简单加锁"><a href="#简单加锁" class="headerlink" title="简单加锁"></a>简单加锁</h3><p>假定当前只有一个协程在加锁，没有其他协程干扰，那么过程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_4b43555a5440890c948680aab58e982f_r.png" alt="null"></p><p>加锁过程会去判断Locked标志位是否为0，如果是0则把Locked位置1，代表加锁成功。从上图可见，加锁成功后，只是Locked位置1，其他状态位没发生变化。</p><h3 id="加锁被阻塞"><a href="#加锁被阻塞" class="headerlink" title="加锁被阻塞"></a>加锁被阻塞</h3><p>假定加锁时，锁已被其他协程占用了，此时加锁过程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_7009a47d6e8acb7e7b9c421ad1fece22_r.png" alt="null"></p><p>从上图可看到，当协程B对一个已被占用的锁再次加锁时，Waiter计数器增加了1，此时协程B将被阻塞，直到Locked值变为0后才会被唤醒。</p><h3 id="简单解锁"><a href="#简单解锁" class="headerlink" title="简单解锁"></a>简单解锁</h3><p>假定解锁时，没有其他协程阻塞，此时解锁过程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_6f4885510e5659f0615f17e6a5b89d2f_r.png" alt="null"></p><p>由于没有其他协程阻塞等待加锁，所以此时解锁时只需要把Locked位置为0即可，不需要释放信号量。</p><h3 id="解锁并唤醒协程"><a href="#解锁并唤醒协程" class="headerlink" title="解锁并唤醒协程"></a>解锁并唤醒协程</h3><p>假定解锁时，有1个或多个协程阻塞，此时解锁过程如下图所示：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_f45d385c3f7bacc272878bbfd6d48182_r.png" alt="null"></p><p>协程A解锁过程分为两个步骤，一是把Locked位置0，二是查看到Waiter&gt;0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程B把Locked位置1，于是协程B获得锁。</p><h2 id="自旋过程"><a href="#自旋过程" class="headerlink" title="自旋过程"></a>自旋过程</h2><p>加锁时，如果当前Locked位为1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续的探测Locked位是否变为0，这个过程即为自旋过程。</p><p>自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。</p><p>自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。</p><h3 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h3><p>自旋对应于CPU的”PAUSE”指令，CPU对该指令什么都不做，相当于CPU空转，对程序而言相当于sleep了一小段时间，时间非常短，当前实现是30个时钟周期。</p><p>自旋过程中会持续探测Locked是否变为0，连续两次探测间隔就是执行这些PAUSE指令，它不同于sleep，不需要将协程转为睡眠状态。</p><h3 id="自旋条件"><a href="#自旋条件" class="headerlink" title="自旋条件"></a>自旋条件</h3><p>加锁时程序会自动判断是否可以自旋，无限制的自旋将会给CPU带来巨大压力，所以判断是否可以自旋就很重要了。</p><p>自旋必须满足以下所有条件：</p><ul><li>自旋次数要足够小，通常为4，即自旋最多4次</li><li>CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁</li><li>协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋</li><li>协程调度机制中的可运行队列必须为空，否则会延迟协程调度</li></ul><p>可见，自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。</p><h3 id="自旋的优势"><a href="#自旋的优势" class="headerlink" title="自旋的优势"></a>自旋的优势</h3><p>自旋的优势是更充分的利用CPU，尽量避免协程切换。因为当前申请加锁的协程拥有CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。</p><h3 id="自旋的问题"><a href="#自旋的问题" class="headerlink" title="自旋的问题"></a>自旋的问题</h3><p>如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程将很难获得锁，从而进入饥饿状态。</p><p>为了避免协程长时间无法获取锁，自1.8版本以来增加了一个状态，即Mutex的Starving状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。</p><h2 id="Mutex模式"><a href="#Mutex模式" class="headerlink" title="Mutex模式"></a>Mutex模式</h2><p>前面分析加锁和解锁过程中只关注了Waiter和Locked位的变化，现在我们看一下Starving位的作用。</p><p>每个Mutex都有两个模式，称为Normal和Starving。下面分别说明这两个模式。</p><h3 id="normal模式"><a href="#normal模式" class="headerlink" title="normal模式"></a>normal模式</h3><p>默认情况下，Mutex的模式为normal。</p><p>该模式下，协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。</p><h3 id="starvation模式"><a href="#starvation模式" class="headerlink" title="starvation模式"></a>starvation模式</h3><p>自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到CPU后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过1ms的话，会将Mutex标记为”饥饿”模式，然后再阻塞。</p><p>处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1。</p><h2 id="Woken状态"><a href="#Woken状态" class="headerlink" title="Woken状态"></a>Woken状态</h2><p>Woken状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把Woken标记为1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。</p><h2 id="源码实现（源码包src-sync-mutex-go）"><a href="#源码实现（源码包src-sync-mutex-go）" class="headerlink" title="源码实现（源码包src/sync/mutex.go）"></a>源码实现（源码包<code>src/sync/mutex.go</code>）</h2><h3 id="加锁实现（重点）"><a href="#加锁实现（重点）" class="headerlink" title="加锁实现（重点）"></a>加锁实现（<em><strong>重点</strong></em>）</h3><ol><li><p>首先如果当前锁处于初始化状态就直接用 CAS 方法尝试获取锁，这是**_ Fast Path_**</p></li><li><p>如果失败就进入**_ Slow Path_**</p><ol><li><p>会首先判断当前能不能进入自旋状态，如果可以就进入自旋，最多自旋 4 次</p></li><li><p>自旋完成之后，就会去计算当前的锁的状态</p></li><li><p>然后尝试通过 CAS 获取锁</p></li><li><p>如果没有获取到就调用 <code>runtime_SemacquireMutex</code> 方法休眠当前 goroutine 并且尝试获取信号量</p></li><li><p>goroutine 被唤醒之后会先判断当前是否处在饥饿状态，（如果当前 goroutine 超过 1ms 都没有获取到锁就会进饥饿模式） 1. 如果处在饥饿状态就会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出 1. 如果不在，就会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环</p><p>CAS 方法在这里指的是 <code>atomic.CompareAndSwapInt32(addr, old, new) bool</code> 方法，这个方法会先比较传入的地址的值是否是 old，如果是的话就尝试赋新值，如果不是的话就直接返回 false，返回 true 时表示赋值成功 饥饿模式是 Go 1.9 版本之后引入的优化，用于解决公平性的问题[10]</p></li></ol></li></ol><p>回味一下上面看到的流程图，我们来看看互斥锁是如何加锁的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Fast path: grab unlocked mutex.</span><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mutexLocked<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// Slow path (outlined so that the fast path can be inlined)</span>m<span class="token punctuation">.</span><span class="token function">lockSlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当我们调用 <code>Lock</code> 方法的时候，会先尝试走 Fast Path，也就是如果当前互斥锁如果处于未加锁的状态，尝试加锁，只要加锁成功就直接返回</li><li>否则的话就进入 slow path</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">lockSlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> waitStartTime <span class="token builtin">int64</span> <span class="token comment">// 等待时间</span>starving <span class="token operator">:=</span> <span class="token boolean">false</span> <span class="token comment">// 是否处于饥饿状态</span>awoke <span class="token operator">:=</span> <span class="token boolean">false</span> <span class="token comment">// 是否处于唤醒状态</span>iter <span class="token operator">:=</span> <span class="token number">0</span> <span class="token comment">// 自旋迭代次数</span>old <span class="token operator">:=</span> m<span class="token punctuation">.</span>state<span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token comment">// Don't spin in starvation mode, ownership is handed off to waiters</span><span class="token comment">// so we won't be able to acquire the mutex anyway.</span><span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">==</span> mutexLocked <span class="token operator">&amp;&amp;</span> <span class="token function">runtime_canSpin</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Active spinning makes sense.</span><span class="token comment">// Try to set mutexWoken flag to inform Unlock</span><span class="token comment">// to not wake other blocked goroutines.</span><span class="token keyword">if</span> <span class="token operator">!</span>awoke <span class="token operator">&amp;&amp;</span> old<span class="token operator">&amp;</span>mutexWoken <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> old<span class="token operator">|</span>mutexWoken<span class="token punctuation">)</span> <span class="token punctuation">{</span>awoke <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token function">runtime_doSpin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>iter<span class="token operator">++</span>old <span class="token operator">=</span> m<span class="token punctuation">.</span>state<span class="token keyword">continue</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 <code>lockSlow</code> 方法中我们可以看到，有一个大的 for 循环，不断的尝试去获取互斥锁，在循环的内部，第一步就是判断能否自旋状态。<br>进入自旋状态的判断比较苛刻，具体需要满足什么条件呢？ <code>runtime_canSpin</code> 源码见下方</p><ul><li>当前互斥锁的状态是非饥饿状态，并且已经被锁定了</li><li>自旋次数不超过 4 次</li><li>cpu 个数大于一，必须要是多核 cpu</li><li>当前正在执行当中，并且队列空闲的 p 的个数大于等于一</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// Active spinning for sync.Mutex.</span><span class="token comment">//go:linkname sync_runtime_canSpin sync.runtime_canSpin</span><span class="token comment">//go:nosplit</span><span class="token keyword">func</span> <span class="token function">sync_runtime_canSpin</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span><span class="token keyword">if</span> i <span class="token operator">&gt;=</span> active_spin <span class="token operator">||</span> ncpu <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">||</span> gomaxprocs <span class="token operator">&lt;=</span> <span class="token function">int32</span><span class="token punctuation">(</span>sched<span class="token punctuation">.</span>npidle<span class="token operator">+</span>sched<span class="token punctuation">.</span>nmspinning<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token keyword">if</span> p <span class="token operator">:=</span> <span class="token function">getg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>m<span class="token punctuation">.</span>p<span class="token punctuation">.</span><span class="token function">ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">!</span><span class="token function">runqempty</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果可以进入自旋状态之后就会调用 <code>runtime_doSpin</code> 方法进入自旋， <code>doSpin</code> 方法会调用 <code>procyield(30)</code> 执行三十次 <code>PAUSE</code> 指令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">TEXT runtime·procyield<span class="token punctuation">(</span>SB<span class="token punctuation">)</span>,NOSPLIT,<span class="token variable">$0</span>-0MOVLcycles+0<span class="token punctuation">(</span>FP<span class="token punctuation">)</span>, AXagain:PAUSESUBL<span class="token variable">$1</span>, AXJNZagainRET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么使用 PAUSE 指令呢？ PAUSE 指令会告诉 CPU 我当前处于处于自旋状态，这时候 CPU 会针对性的做一些优化，并且在执行这个指令的时候 CPU 会降低自己的功耗，减少能源消耗</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> <span class="token operator">!</span>awoke <span class="token operator">&amp;&amp;</span> old<span class="token operator">&amp;</span>mutexWoken <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> old<span class="token operator">|</span>mutexWoken<span class="token punctuation">)</span> <span class="token punctuation">{</span>awoke <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在自旋的过程中会尝试设置 <code>mutexWoken</code> 来通知解锁，从而避免唤醒其他已经休眠的 <code>goroutine</code> 在自旋模式下，当前的 <code>goroutine</code> 就能更快的获取到锁</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">new</span> <span class="token operator">:=</span> old<span class="token comment">// Don't try to acquire starving mutex, new arriving goroutines must queue.</span><span class="token keyword">if</span> old<span class="token operator">&amp;</span>mutexStarving <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token builtin">new</span> <span class="token operator">|=</span> mutexLocked<span class="token punctuation">}</span><span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token builtin">new</span> <span class="token operator">+=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> mutexWaiterShift<span class="token punctuation">}</span><span class="token comment">// The current goroutine switches mutex to starvation mode.</span><span class="token comment">// But if the mutex is currently unlocked, don't do the switch.</span><span class="token comment">// Unlock expects that starving mutex has waiters, which will not</span><span class="token comment">// be true in this case.</span><span class="token keyword">if</span> starving <span class="token operator">&amp;&amp;</span> old<span class="token operator">&amp;</span>mutexLocked <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token builtin">new</span> <span class="token operator">|=</span> mutexStarving<span class="token punctuation">}</span><span class="token keyword">if</span> awoke <span class="token punctuation">{</span><span class="token comment">// The goroutine has been woken from sleep,</span><span class="token comment">// so we need to reset the flag in either case.</span><span class="token keyword">if</span> <span class="token builtin">new</span><span class="token operator">&amp;</span>mutexWoken <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"sync: inconsistent mutex state"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token builtin">new</span> <span class="token operator">&amp;^=</span> mutexWoken<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自旋结束之后就会去计算当前互斥锁的状态，如果当前处在饥饿模式下则不会去请求锁，而是会将当前 goroutine 放到队列的末端</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">break</span> <span class="token comment">// locked the mutex with CAS</span>    <span class="token punctuation">}</span>    <span class="token comment">// If we were already waiting before, queue at the front of the queue.</span>    queueLifo <span class="token operator">:=</span> waitStartTime <span class="token operator">!=</span> <span class="token number">0</span>    <span class="token keyword">if</span> waitStartTime <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        waitStartTime <span class="token operator">=</span> <span class="token function">runtime_nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token function">runtime_SemacquireMutex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">,</span> queueLifo<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    starving <span class="token operator">=</span> starving <span class="token operator">||</span> <span class="token function">runtime_nanotime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>waitStartTime <span class="token operator">&gt;</span> starvationThresholdNs    old <span class="token operator">=</span> m<span class="token punctuation">.</span>state    <span class="token keyword">if</span> old<span class="token operator">&amp;</span>mutexStarving <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token comment">// If this goroutine was woken and mutex is in starvation mode,</span>        <span class="token comment">// ownership was handed off to us but mutex is in somewhat</span>        <span class="token comment">// inconsistent state: mutexLocked is not set and we are still</span>        <span class="token comment">// accounted as waiter. Fix that.</span>        <span class="token keyword">if</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexWoken<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"sync: inconsistent mutex state"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        delta <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>mutexLocked <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>mutexWaiterShift<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token operator">!</span>starving <span class="token operator">||</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>            <span class="token comment">// Exit starvation mode.</span>            <span class="token comment">// Critical to do it here and consider wait time.</span>            <span class="token comment">// Starvation mode is so inefficient, that two goroutines</span>            <span class="token comment">// can go lock-step infinitely once they switch mutex</span>            <span class="token comment">// to starvation mode.</span>            delta <span class="token operator">-=</span> mutexStarving        <span class="token punctuation">}</span>        atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> delta<span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span>    awoke <span class="token operator">=</span> <span class="token boolean">true</span>    iter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>状态计算完成之后就会尝试使用 CAS 操作获取锁，如果获取成功就会直接退出循环 如果获取失败，则会调用 <code>runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)</code> 方法保证锁不会同时被两个 goroutine 获取。<code>runtime_SemacquireMutex</code> 方法的主要作用是:</p><ul><li>不断调用尝试获取锁</li><li>休眠当前 goroutine</li><li>等待信号量，唤醒 goroutine</li></ul><p>goroutine 被唤醒之后就会去判断当前是否处于饥饿模式，如果当前等待超过 <code>1ms</code> 就会进入饥饿模式</p><ul><li>饥饿模式下：会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出</li><li>正常模式下：会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环</li></ul><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>和加锁比解锁就很简单了，直接看注释就好</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 解锁一个没有锁定的互斥量会报运行时错误</span><span class="token comment">// 解锁没有绑定关系，可以一个 goroutine 锁定，另外一个 goroutine 解锁</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Fast path: 直接尝试设置 state 的值，进行解锁</span><span class="token builtin">new</span> <span class="token operator">:=</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> <span class="token operator">-</span>mutexLocked<span class="token punctuation">)</span>    <span class="token comment">// 如果减去了 mutexLocked 的值之后不为零就会进入慢速通道，这说明有可能失败了，或者是还有其他的 goroutine 等着</span><span class="token keyword">if</span> <span class="token builtin">new</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// Outlined slow path to allow inlining the fast path.</span><span class="token comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span>m<span class="token punctuation">.</span><span class="token function">unlockSlow</span><span class="token punctuation">(</span><span class="token builtin">new</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Mutex<span class="token punctuation">)</span> <span class="token function">unlockSlow</span><span class="token punctuation">(</span><span class="token builtin">new</span> <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 解锁一个没有锁定的互斥量会报运行时错误</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">new</span><span class="token operator">+</span>mutexLocked<span class="token punctuation">)</span><span class="token operator">&amp;</span>mutexLocked <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">"sync: unlock of unlocked mutex"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token comment">// 判断是否处于饥饿模式</span><span class="token keyword">if</span> <span class="token builtin">new</span><span class="token operator">&amp;</span>mutexStarving <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token comment">// 正常模式</span>old <span class="token operator">:=</span> <span class="token builtin">new</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token comment">// 如果当前没有等待者.或者 goroutine 已经被唤醒或者是处于锁定状态了，就直接返回</span><span class="token keyword">if</span> old<span class="token operator">&gt;&gt;</span>mutexWaiterShift <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> old<span class="token operator">&amp;</span><span class="token punctuation">(</span>mutexLocked<span class="token operator">|</span>mutexWoken<span class="token operator">|</span>mutexStarving<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 唤醒等待者并且移交锁的控制权</span><span class="token builtin">new</span> <span class="token operator">=</span> <span class="token punctuation">(</span>old <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&lt;&lt;</span>mutexWaiterShift<span class="token punctuation">)</span> <span class="token operator">|</span> mutexWoken<span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">CompareAndSwapInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>state<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">runtime_Semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>old <span class="token operator">=</span> m<span class="token punctuation">.</span>state<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 饥饿模式，走 handoff 流程，直接将锁交给下一个等待的 goroutine，注意这个时候不会从饥饿模式中退出</span><span class="token function">runtime_Semrelease</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">.</span>sema<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="为什么重复解锁要panic"><a href="#为什么重复解锁要panic" class="headerlink" title="为什么重复解锁要panic"></a>为什么重复解锁要panic</h2><p>可能你会想，为什么Go不能实现得更健壮些，多次执行Unlock()也不要panic？</p><p>仔细想想Unlock的逻辑就可以理解，这实际上很难做到。Unlock过程分为将Locked置为0，然后判断Waiter值，如果值&gt;0，则释放信号量。</p><p>如果多次Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度，也会引起不必要的协程切换。</p><h2 id="编程Tips"><a href="#编程Tips" class="headerlink" title="编程Tips"></a>编程Tips</h2><h3 id="使用defer避免死锁"><a href="#使用defer避免死锁" class="headerlink" title="使用defer避免死锁"></a>使用defer避免死锁</h3><p>加锁后立即使用defer对其解锁，可以有效的避免死锁。</p><h3 id="加锁和解锁应该成对出现"><a href="#加锁和解锁应该成对出现" class="headerlink" title="加锁和解锁应该成对出现"></a>加锁和解锁应该成对出现</h3><p>加锁和解锁最好出现在同一个层次的代码块中，比如同一个函数。</p><p>重复解锁会引起panic，应避免这种操作的可能性。</p><p>参考文章：</p><p><a href="https://topgoer.cn/docs/gozhuanjia/gozhuanjiamutex">Go专家编程</a></p><p><a href="https://lailin.xyz/post/go-training-week3-sync.html">mohuishou的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——map的实现机制浅析</title>
      <link href="/hypo-Z.github.io/2022/10/26/go-yu-yan-jin-jie-map-de-shi-xian-ji-zhi-qian-xi/"/>
      <url>/hypo-Z.github.io/2022/10/26/go-yu-yan-jin-jie-map-de-shi-xian-ji-zhi-qian-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="map的实现机制浅析"><a href="#map的实现机制浅析" class="headerlink" title="map的实现机制浅析"></a>map的实现机制浅析</h1><h2 id="map数据结构"><a href="#map数据结构" class="headerlink" title="map数据结构"></a>map数据结构</h2><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。</p><p>map数据结构由<code>runtime/map.go:hmap</code>定义:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> hmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>    count     <span class="token builtin">int</span> <span class="token comment">// 当前保存的元素个数</span>    <span class="token operator">...</span>    B         <span class="token builtin">uint8</span>    <span class="token operator">...</span>    buckets    unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// bucket数组指针，数组的大小为2^B</span>    <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下图展示一个拥有4个bucket的map：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_897a05f6373f7f966d00d1bfea6274d2_r.png" alt="null"></p><p>本例中, <code>hmap.B=2</code>， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。</p><p><code>bucket</code>很多时候被翻译为桶，所谓的<code>哈希桶</code>实际上就是bucket。</p><h2 id="bucket数据结构"><a href="#bucket数据结构" class="headerlink" title="bucket数据结构"></a>bucket数据结构</h2><p>bucket数据结构由<code>runtime/map.go:bmap</code>定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> bmap <span class="token keyword">struct</span> <span class="token punctuation">{</span>    tophash <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token builtin">uint8</span> <span class="token comment">//存储哈希值的高8位</span>    data    <span class="token builtin">byte</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment">//key value数据:key/key/key/.../value/value/value...</span>    overflow <span class="token operator">*</span>bmap   <span class="token comment">//溢出bucket的地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个bucket可以存储8个键值对。</p><ul><li>tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。</li><li>data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。</li><li>overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。</li></ul><p>注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。</p><p>下图展示bucket存放8个key-value对：</p><p><img src="https://topgoer.cn/uploads/gozhuanjia/images/m_7f0ba5a124641b1413279892581513c4_r.png" alt="null"></p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找过程如下：</p><ol><li>根据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>取哈希值高位在tophash数组中查询</li><li>如果tophash[i]中存储值与哈希值相等，则去找到该bucket中的key值进行比较</li><li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li><li>如果当前处于搬迁过程，则优先从oldbuckets查找</li></ol><p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p><h2 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h2><p>新元素插入过程如下：</p><ol><li>根据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值</li><li>如果没找到将key，将key插入</li></ol><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/* 创建map */</span>        countryCapitalMap <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"France"</span><span class="token punctuation">:</span> <span class="token string">"Paris"</span><span class="token punctuation">,</span> <span class="token string">"Italy"</span><span class="token punctuation">:</span> <span class="token string">"Rome"</span><span class="token punctuation">,</span> <span class="token string">"Japan"</span><span class="token punctuation">:</span> <span class="token string">"Tokyo"</span><span class="token punctuation">,</span> <span class="token string">"India"</span><span class="token punctuation">:</span> <span class="token string">"New delhi"</span><span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"原始地图"</span><span class="token punctuation">)</span>        <span class="token comment">/* 打印地图 */</span>        <span class="token keyword">for</span> country <span class="token operator">:=</span> <span class="token keyword">range</span> countryCapitalMap <span class="token punctuation">{</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>country<span class="token punctuation">,</span> <span class="token string">"首都是"</span><span class="token punctuation">,</span> countryCapitalMap <span class="token punctuation">[</span> country <span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment">/*删除元素*/</span> <span class="token function">delete</span><span class="token punctuation">(</span>countryCapitalMap<span class="token punctuation">,</span> <span class="token string">"France"</span><span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"法国条目被删除"</span><span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"删除元素后地图"</span><span class="token punctuation">)</span>        <span class="token comment">/*打印地图*/</span>        <span class="token keyword">for</span> country <span class="token operator">:=</span> <span class="token keyword">range</span> countryCapitalMap <span class="token punctuation">{</span>                fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>country<span class="token punctuation">,</span> <span class="token string">"首都是"</span><span class="token punctuation">,</span> countryCapitalMap <span class="token punctuation">[</span> country <span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="hashmap简单实现"><a href="#hashmap简单实现" class="headerlink" title="hashmap简单实现"></a>hashmap简单实现</h2><p>基于 go 实现简单 HashMap，暂未做 key 值的校验。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">type</span> HashMap <span class="token keyword">struct</span> <span class="token punctuation">{</span>    key <span class="token builtin">string</span>    value <span class="token builtin">string</span>    hashCode <span class="token builtin">int</span>    next <span class="token operator">*</span>HashMap<span class="token punctuation">}</span><span class="token keyword">var</span> table <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">*</span>HashMap<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> table<span class="token punctuation">{</span>        table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>HashMap<span class="token punctuation">{</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">*</span>HashMap<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> table<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">genHashCode</span><span class="token punctuation">(</span>k <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> hashCode <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">var</span> lastIndex <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> k <span class="token punctuation">{</span>        <span class="token keyword">if</span> i <span class="token operator">==</span> lastIndex <span class="token punctuation">{</span>            hashCode <span class="token operator">+=</span> <span class="token function">int</span><span class="token punctuation">(</span>k<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">break</span>        <span class="token punctuation">}</span>        hashCode <span class="token operator">+=</span> <span class="token punctuation">(</span>hashCode <span class="token operator">+</span> <span class="token function">int</span><span class="token punctuation">(</span>k<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">31</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> hashCode<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">indexTable</span><span class="token punctuation">(</span>hashCode <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> hashCode<span class="token operator">%</span><span class="token number">16</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">indexNode</span><span class="token punctuation">(</span>hashCode <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hashCode<span class="token operator">&gt;&gt;</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">put</span><span class="token punctuation">(</span>k <span class="token builtin">string</span><span class="token punctuation">,</span> v <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> hashCode <span class="token operator">=</span> <span class="token function">genHashCode</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>    <span class="token keyword">var</span> thisNode <span class="token operator">=</span> HashMap<span class="token punctuation">{</span>k<span class="token punctuation">,</span>v<span class="token punctuation">,</span>hashCode<span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">}</span>    <span class="token keyword">var</span> tableIndex <span class="token operator">=</span> <span class="token function">indexTable</span><span class="token punctuation">(</span>hashCode<span class="token punctuation">)</span>    <span class="token keyword">var</span> nodeIndex <span class="token operator">=</span> <span class="token function">indexNode</span><span class="token punctuation">(</span>hashCode<span class="token punctuation">)</span>    <span class="token keyword">var</span> headPtr <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">*</span>HashMap<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> headNode <span class="token operator">=</span> headPtr<span class="token punctuation">[</span>tableIndex<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>headNode<span class="token punctuation">)</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token string">""</span> <span class="token punctuation">{</span>        <span class="token operator">*</span>headNode <span class="token operator">=</span> thisNode        <span class="token keyword">return</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> lastNode <span class="token operator">*</span>HashMap <span class="token operator">=</span> headNode    <span class="token keyword">var</span> nextNode <span class="token operator">*</span>HashMap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>headNode<span class="token punctuation">)</span><span class="token punctuation">.</span>next    <span class="token keyword">for</span> nextNode <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token function">indexNode</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">.</span>hashCode<span class="token punctuation">)</span> <span class="token operator">&lt;</span> nodeIndex<span class="token punctuation">)</span><span class="token punctuation">{</span>        lastNode <span class="token operator">=</span> nextNode        nextNode <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>nextNode<span class="token punctuation">)</span><span class="token punctuation">.</span>next    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>lastNode<span class="token punctuation">)</span><span class="token punctuation">.</span>hashCode <span class="token operator">==</span> thisNode<span class="token punctuation">.</span>hashCode <span class="token punctuation">{</span>        <span class="token keyword">var</span> oldValue <span class="token builtin">string</span> <span class="token operator">=</span> lastNode<span class="token punctuation">.</span>value        lastNode<span class="token punctuation">.</span>value <span class="token operator">=</span> thisNode<span class="token punctuation">.</span>value        <span class="token keyword">return</span> oldValue    <span class="token punctuation">}</span>    <span class="token keyword">if</span> lastNode<span class="token punctuation">.</span>hashCode <span class="token operator">&lt;</span> thisNode<span class="token punctuation">.</span>hashCode <span class="token punctuation">{</span>        lastNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>thisNode    <span class="token punctuation">}</span>    <span class="token keyword">if</span> nextNode <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        thisNode<span class="token punctuation">.</span>next <span class="token operator">=</span> nextNode    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">get</span><span class="token punctuation">(</span>k <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> hashCode <span class="token operator">=</span> <span class="token function">genHashCode</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>    <span class="token keyword">var</span> tableIndex <span class="token operator">=</span> <span class="token function">indexTable</span><span class="token punctuation">(</span>hashCode<span class="token punctuation">)</span>    <span class="token keyword">var</span> headPtr <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">*</span>HashMap<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">var</span> node <span class="token operator">*</span>HashMap <span class="token operator">=</span> headPtr<span class="token punctuation">[</span>tableIndex<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>key <span class="token operator">==</span> k<span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>value    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> k <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>key <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>value        <span class="token punctuation">}</span>        node <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>next    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span class="token comment">//examples </span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"a_put"</span><span class="token punctuation">)</span>    <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"b_put"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">,</span><span class="token string">"p_put"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考文章：<br><a href="https://www.runoob.com/go/go-map.html">菜鸟教程</a><br><a href="https://topgoer.cn/docs/gozhuanjia/gozhuanjiamap">Go专家编程</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——channel的实现机制</title>
      <link href="/hypo-Z.github.io/2022/10/25/go-yu-yan-jin-jie-channel-de-shi-xian-ji-zhi/"/>
      <url>/hypo-Z.github.io/2022/10/25/go-yu-yan-jin-jie-channel-de-shi-xian-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="channel的实现机制"><a href="#channel的实现机制" class="headerlink" title="channel的实现机制"></a>channel的实现机制</h1><blockquote><p>channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。</p></blockquote><p>本章从源码角度分析channel的实现机制</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code>src/runtime/chan.go:hchan</code>定义了channel的数据结构：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> hchan <span class="token keyword">struct</span> <span class="token punctuation">{</span>    qcount   <span class="token builtin">uint</span>           <span class="token comment">// 当前队列中剩余元素个数</span>    dataqsiz <span class="token builtin">uint</span>           <span class="token comment">// 环形队列长度，即可以存放的元素个数</span>    buf      unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 环形队列指针</span>    elemsize <span class="token builtin">uint16</span>         <span class="token comment">// 每个元素的大小</span>    closed   <span class="token builtin">uint32</span>            <span class="token comment">// 标识关闭状态</span>    elemtype <span class="token operator">*</span>_type         <span class="token comment">// 元素类型</span>    sendx    <span class="token builtin">uint</span>           <span class="token comment">// 队列下标，指示元素写入时存放到队列中的位置</span>    recvx    <span class="token builtin">uint</span>           <span class="token comment">// 队列下标，指示元素从队列的该位置读出</span>    recvq    waitq          <span class="token comment">// 等待读消息的goroutine队列</span>    sendq    waitq          <span class="token comment">// 等待写消息的goroutine队列</span>    lock mutex              <span class="token comment">// 互斥锁，chan不允许并发读写</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h2><p>chan内部实现了一个环形队列作为其缓冲区，队列的长度是创建chan时指定的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch<span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment">//队列可看成定长数组队列arrry:=[6]int</span><span class="token comment">//dataqsiz指示了队列长度为7，即可缓存7个元素；</span><span class="token comment">//buf指向队列的内存，buf:=&amp;array ,队列中还剩余元素；</span><span class="token comment">//qcount表示队列中还有元素个数len(array)；</span><span class="token comment">//sendx指示后续写入的数据存储的位置，取值[0, 6]；</span><span class="token comment">//recvx指示从该位置读取数据, 取值[0, 6]；</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞。<br>向channel写数据，如果channel缓冲区已满或者没有缓冲区，当前goroutine会被阻塞。</p><p>被阻塞的goroutine将会挂在channel的等待队列中：</p><ul><li><p>因读阻塞的goroutine会被向channel写入数据的goroutine唤醒；</p></li><li><p>因写阻塞的goroutine会被从channel读数据的goroutine唤醒；</p></li></ul><p>注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token comment">//循环添加0-9数字至channel中，并睡眠1秒</span><span class="token keyword">func</span> <span class="token function">addNumberToChan</span><span class="token punctuation">(</span>chanName <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>chanName <span class="token operator">&lt;-</span> itime<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//创建一个无缓存的channel</span><span class="token keyword">var</span> chan1 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token comment">//延时关闭channel，养成好习惯</span>    <span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>chan1<span class="token punctuation">)</span>    <span class="token comment">//一个协程负责添加数值</span><span class="token keyword">go</span> <span class="token function">addNumberToChan</span><span class="token punctuation">(</span>chan1<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token keyword">select</span> <span class="token punctuation">{</span>            <span class="token comment">//若读channel不阻塞，打印结果</span><span class="token keyword">case</span> e <span class="token operator">:=</span> <span class="token operator">&lt;-</span>chan1<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Get element from chan1: %d\n"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>            <span class="token comment">//channel阻塞，提醒并睡眠1秒</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"No element in chan1.\n"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">0</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">1</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">2</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">3</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">4</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">5</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">6</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">7</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">8</span>No element in chan1<span class="token punctuation">.</span>Get element from chan1<span class="token punctuation">:</span> <span class="token number">9</span>No element in chan1<span class="token punctuation">.</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行稳定之后会顺序输出排列数字</p><h2 id="锁lock-mutex"><a href="#锁lock-mutex" class="headerlink" title="锁lock mutex"></a>锁lock mutex</h2><p>一个channel同时仅允许被一个goroutine读写</p><h2 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h2><p>panic出现的常见场景还有：</p><ol><li>关闭值为nil的channel</li><li>关闭已经被关闭的channel</li><li>向已经关闭的channel写数据</li></ol><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>通过range可以持续从channel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">chanRange</span><span class="token punctuation">(</span>chanName <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> e <span class="token operator">:=</span> <span class="token keyword">range</span> chanName <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Get element from chan: %d\n"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">addNumberToChan1</span><span class="token punctuation">(</span>chanName <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>chanName <span class="token operator">&lt;-</span> i<span class="token punctuation">}</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>chan2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">close</span><span class="token punctuation">(</span>chan2<span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">addNumberToChan1</span><span class="token punctuation">(</span>chan2<span class="token punctuation">)</span><span class="token function">chanRange</span><span class="token punctuation">(</span>chan2<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">0</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">1</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">2</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">3</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">4</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">5</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">6</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">7</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">8</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token comment">//每隔5秒</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">0</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">1</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">2</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">3</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">4</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">5</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">6</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">7</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">8</span>Get element from <span class="token keyword">chan</span><span class="token punctuation">:</span> <span class="token number">9</span><span class="token operator">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考文章：<a href="https://topgoer.cn/docs/gozhuanjia/gochan4">Go专家编程</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——反射</title>
      <link href="/hypo-Z.github.io/2022/10/18/go-yu-yan-ji-chu-fan-she/"/>
      <url>/hypo-Z.github.io/2022/10/18/go-yu-yan-ji-chu-fan-she/</url>
      
        <content type="html"><![CDATA[<h1 id="反射定律"><a href="#反射定律" class="headerlink" title="反射定律"></a>反射定律</h1><p>罗布派克<br>2011 年 9 月 6 日</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>计算中的反射是程序检查其自身结构的能力，特别是通过类型。这是元编程的一种形式。这也是一个很大的混乱来源。</p><p>在本文中，我们试图通过解释反射在 Go 中的工作原理来澄清事情。每种语言的反射模型都不同（许多语言根本不支持），但这篇文章是关于 Go 的，所以对于本文的其余部分，“反射”这个词应该被理解为“Go 中的反射”。</p><p>2022 年 1 月添加的注释：这篇博文写于 2011 年，早于 Go 中的参数多态（又名泛型）。尽管由于语言的发展，文章中的任何重要内容都没有变得不正确，但它已经在一些地方进行了调整，以避免让熟悉现代 Go 的人感到困惑。</p><h2 id="类型和接口"><a href="#类型和接口" class="headerlink" title="类型和接口"></a>类型和接口</h2><p>因为反射建立在类型系统之上，所以让我们从复习一下 Go 中的类型开始。</p><p>Go 是静态类型的。每个变量都有一个静态类型，也就是说，只有一种类型在编译时已知并固定： <code>int</code>、<code>float32</code>、<code>*MyType</code>、<code>[]byte</code>等等。如果我们声明</p><pre class="line-numbers language-none"><code class="language-none">type MyInt intvar i intvar j MyInt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后<code>i</code>有 type<code>int</code>并且<code>j</code>有 type <code>MyInt</code>。变量<code>i</code>和<code>j</code>具有不同的静态类型，尽管它们具有相同的基础类型，但它们不能在没有转换的情况下相互分配。</p><p>一类重要的类型是接口类型，它表示固定的方法集。（在讨论反射时，我们可以忽略将接口定义用作多态代码中的约束。）接口变量可以存储任何具体（非接口）值，只要该值实现接口的方法即可。一对著名的例子是<code>io.Reader</code>and <code>io.Writer</code>，类型<code>Reader</code>and<code>Writer</code>来自<a href="https://go.dev/pkg/io/">io 包</a>：</p><pre class="line-numbers language-none"><code class="language-none">// Reader is the interface that wraps the basic Read method.type Reader interface {    Read(p []byte) (n int, err error)}// Writer is the interface that wraps the basic Write method.type Writer interface {    Write(p []byte) (n int, err error)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>任何使用此签名实现<code>Read</code>(or <code>Write</code>) 方法的类型都被称为实现<code>io.Reader</code>(or <code>io.Writer</code>)。出于本讨论的目的，这意味着类型变量 <code>io.Reader</code>可以保存其类型具有<code>Read</code>方法的任何值：</p><pre class="line-numbers language-none"><code class="language-none">var r io.Readerr = os.Stdinr = bufio.NewReader(r)r = new(bytes.Buffer)// and so on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重要的是要清楚，无论具体值<code>r</code>可能是什么， <code>r</code>‘s 的类型始终是<code>io.Reader</code>：Go 是静态类型的，而静态类型<code>r</code>是<code>io.Reader</code>。</p><p>接口类型的一个极其重要的例子是空接口：</p><pre class="line-numbers language-none"><code class="language-none">interface{}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或其等效别名，</p><pre class="line-numbers language-none"><code class="language-none">any<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它代表空的方法集，任何值都可以满足它，因为每个值都有零个或多个方法。</p><p>有人说 Go 的接口是动态类型的，但这是一种误导。它们是静态类型的：接口类型的变量始终具有相同的静态类型，即使在运行时存储在接口变量中的值可能会改变类型，该值也将始终满足接口。</p><p>我们需要对所有这些都保持精确，因为反射和接口密切相关。</p><h2 id="接口的表示"><a href="#接口的表示" class="headerlink" title="接口的表示"></a>接口的表示</h2><p>Russ Cox 写了一篇 关于 Go 中接口值表示的<a href="https://research.swtch.com/2009/12/go-data-structures-interfaces.html">详细博客文章。</a>这里没有必要重复完整的故事，但一个简化的摘要是有序的。</p><p>接口类型的变量存储一对：分配给变量的具体值，以及该值的类型描述符。更准确地说，值是实现接口的底层具体数据项，类型描述了该项的完整类型。例如，之后</p><pre class="line-numbers language-none"><code class="language-none">var r io.Readertty, err := os.OpenFile("/dev/tty", os.O_RDWR, 0)if err != nil {    return nil, err}r = tty<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>r</code>示意性地包含 (value, type) 对 ( <code>tty</code>, <code>*os.File</code>)。请注意，该类型<code>*os.File</code>实现的方法不是<code>Read</code>; 即使接口值只提供对<code>Read</code>方法的访问，内部的值也包含有关该值的所有类型信息。这就是为什么我们可以这样做：</p><pre class="line-numbers language-none"><code class="language-none">var w io.Writerw = r.(io.Writer)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个赋值中的表达式是一个类型断言；它断言的是里面的项目<code>r</code>也实现了<code>io.Writer</code>，所以我们可以将它分配给<code>w</code>. 赋值后，<code>w</code>将包含对 ( <code>tty</code>, <code>*os.File</code>)。那是同一对在举行<code>r</code>。接口的静态类型决定了可以使用接口变量调用哪些方法，即使内部的具体值可能具有更大的方法集。</p><p>继续，我们可以这样做：</p><pre class="line-numbers language-none"><code class="language-none">var empty interface{}empty = w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>并且我们的空接口值<code>empty</code>将再次包含同一对 ( <code>tty</code>, <code>*os.File</code>)。这很方便：一个空接口可以保存任何值，并包含我们可能需要的关于该值的所有信息。</p><p>（我们在这里不需要类型断言，因为静态已知它 <code>w</code>满足空接口。在我们将值从 a 移动<code>Reader</code>到 a的示例中<code>Writer</code>，我们需要显式并使用类型断言，因为<code>Writer</code>‘ 的方法不是的子集<code>Reader</code>。）</p><p>一个重要的细节是接口变量内的对总是有形式（值，具体类型），不能有形式（值，接口类型）。接口不保存接口值。</p><p>现在我们准备好反思了。</p><h2 id="第一反射定律"><a href="#第一反射定律" class="headerlink" title="第一反射定律"></a>第一反射定律</h2><h2 id="1-反射从接口值到反射对象。"><a href="#1-反射从接口值到反射对象。" class="headerlink" title="1. 反射从接口值到反射对象。"></a>1. 反射从接口值到反射对象。</h2><p>在基本层面上，反射只是一种检查存储在接口变量中的类型和值对的机制。首先，我们需要了解<a href="https://go.dev/pkg/reflect/">反射包</a>中的两种类型： <a href="https://go.dev/pkg/reflect/#Type">类型</a>和<a href="https://go.dev/pkg/reflect/#Value">值</a>。这两种类型可以访问接口变量的内容，以及两个简单的函数，称为<code>reflect.TypeOf</code>and <code>reflect.ValueOf</code>，检索<code>reflect.Type</code>和<code>reflect.Value</code>分片接口值。（另外，从 a<code>reflect.Value</code>到对应的 很容易<code>reflect.Type</code>，但现在让<code>Value</code>和<code>Type</code>概念分开。）</p><p>让我们从<code>TypeOf</code>：</p><pre class="line-numbers language-none"><code class="language-none">package mainimport (    "fmt"    "reflect")func main() {    var x float64 = 3.4    fmt.Println("type:", reflect.TypeOf(x))}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该程序打印</p><pre class="line-numbers language-none"><code class="language-none">type: float64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您可能想知道接口在哪里，因为程序看起来像是将<code>float64</code>变量<code>x</code>而不是接口值传递给<code>reflect.TypeOf</code>. 但它就在那里；作为<a href="https://go.dev/pkg/reflect/#TypeOf">godoc 报告</a>， 的签名<code>reflect.TypeOf</code>包括一个空接口：</p><pre class="line-numbers language-none"><code class="language-none">// TypeOf returns the reflection Type of the value in the interface{}.func TypeOf(i interface{}) Type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当我们调用时<code>reflect.TypeOf(x)</code>，<code>x</code>首先存储在一个空接口中，然后作为参数传递； <code>reflect.TypeOf</code>解压缩该空接口以恢复类型信息。</p><p>当然，该<code>reflect.ValueOf</code>函数会恢复值（从这里开始，我们将省略样板文件并只关注可执行代码）：</p><pre class="line-numbers language-none"><code class="language-none">var x float64 = 3.4fmt.Println("value:", reflect.ValueOf(x).String())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>印刷</p><pre class="line-numbers language-none"><code class="language-none">value: &lt;float64 Value&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（我们显式调用该<code>String</code>方法，因为默认情况下，<code>fmt</code>包会深入到 a<code>reflect.Value</code>中以显示内部的具体值。该<code>String</code>方法没有。）</p><p>两者<code>reflect.Type</code>都有<code>reflect.Value</code>很多方法可以让我们检查和操作它们。一个重要的例子是它<code>Value</code>有一个<code>Type</code>返回 <code>Type</code>a的方法<code>reflect.Value</code>。另一个是两者<code>Type</code>都有<code>Value</code>一个<code>Kind</code>方法，该方法返回一个常量，指示存储的项目类型： <code>Uint</code>、<code>Float64</code>、<code>Slice</code>等。还<code>Value</code>使用名称 like 的方法<code>Int</code>，<code>Float</code>让我们获取存储在其中的值（as<code>int64</code>和<code>float64</code>）：</p><pre class="line-numbers language-none"><code class="language-none">var x float64 = 3.4v := reflect.ValueOf(x)fmt.Println("type:", v.Type())fmt.Println("kind is float64:", v.Kind() == reflect.Float64)fmt.Println("value:", v.Float())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>印刷</p><pre class="line-numbers language-none"><code class="language-none">type: float64kind is float64: truevalue: 3.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>也有类似的方法<code>SetInt</code>，<code>SetFloat</code>但要使用它们，我们需要了解可设置性，即反射第三定律的主题，将在下面讨论。</p><p>反射库有几个值得一提的属性。首先，为了保持 API 简单，“getter”和“setter”方法对<code>Value</code> 可以保存值的最大类型进行操作： <code>int64</code>例如，对于所有有符号整数。即 的<code>Int</code>方法<code>Value</code>返回一个<code>int64</code>，<code>SetInt</code> 值取一个<code>int64</code>; 可能需要转换为实际涉及的类型：</p><pre class="line-numbers language-none"><code class="language-none">var x uint8 = 'x'v := reflect.ValueOf(x)fmt.Println("type:", v.Type())                            // uint8.fmt.Println("kind is uint8: ", v.Kind() == reflect.Uint8) // true.x = uint8(v.Uint())                                       // v.Uint returns a uint64.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个属性是<code>Kind</code>反射对象描述的是底层类型，而不是静态类型。如果反射对象包含用户定义的整数类型的值，如</p><pre class="line-numbers language-none"><code class="language-none">type MyInt intvar x MyInt = 7v := reflect.ValueOf(x)Kind`of`v`仍然是，`reflect.Int`即使静态类型`x`是`MyInt`，不是`int`。换句话说，即使可以，`Kind`也无法区分 an`int`和 a 。`MyInt``Type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反射第二定律"><a href="#反射第二定律" class="headerlink" title="反射第二定律"></a>反射第二定律</h2><h2 id="2-反射从反射对象到接口值。"><a href="#2-反射从反射对象到接口值。" class="headerlink" title="2. 反射从反射对象到接口值。"></a>2. 反射从反射对象到接口值。</h2><p>像物理反射一样，Go 中的反射产生了它自己的逆。</p><p>给定 a<code>reflect.Value</code>我们可以使用该方法恢复接口值<code>Interface</code>；实际上，该方法将类型和值信息打包回接口表示并返回结果：</p><pre class="line-numbers language-none"><code class="language-none">// Interface returns v's value as an interface{}.func (v Value) Interface() interface{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>结果我们可以说</p><pre class="line-numbers language-none"><code class="language-none">y := v.Interface().(float64) // y will have type float64.fmt.Println(y)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打印<code>float64</code>反射对象表示的值<code>v</code>。</p><p>不过，我们可以做得更好。的参数<code>fmt.Println</code>等等 <code>fmt.Printf</code>都是作为空接口值传递的，然后<code>fmt</code>就像我们在前面的示例中所做的那样，它们在内部由包解包。因此，正确打印 a 的内容所需要做的<code>reflect.Value</code>就是将方法的结果传递<code>Interface</code>给格式化的打印例程：</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(v.Interface())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（因为这篇文章是第一次写的，所以对<code>fmt</code> 包做了一个改变，让它自动解包这样的<code>reflect.Value</code>，所以我们可以说</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(v)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到相同的结果，但为了清楚起见，我们将在<code>.Interface()</code>此处保留调用。）</p><p>由于我们的值是 a <code>float64</code>，我们甚至可以根据需要使用浮点格式：</p><pre class="line-numbers language-none"><code class="language-none">fmt.Printf("value is %7.1e\n", v.Interface())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这种情况下得到</p><pre class="line-numbers language-none"><code class="language-none">3.4e+00<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样，无需对 to 的结果进行类型<code>v.Interface()</code>断言<code>float64</code>；空接口值里面有具体值的类型信息，<code>Printf</code>会恢复。</p><p>简而言之，该<code>Interface</code>方法是函数的逆<code>ValueOf</code>函数，只是它的结果始终是静态类型<code>interface{}</code>。</p><p>重申：反射从接口值到反射对象再返回。</p><h2 id="反射第三定律"><a href="#反射第三定律" class="headerlink" title="反射第三定律"></a>反射第三定律</h2><h2 id="3-要修改反射对象，其值必须是可设置的。"><a href="#3-要修改反射对象，其值必须是可设置的。" class="headerlink" title="3.要修改反射对象，其值必须是可设置的。"></a>3.要修改反射对象，其值必须是可设置的。</h2><p>第三定律是最微妙和最令人困惑的，但是如果我们从第一原理开始就很容易理解。</p><p>这是一些不起作用的代码，但值得研究。</p><pre class="line-numbers language-none"><code class="language-none">var x float64 = 3.4v := reflect.ValueOf(x)v.SetFloat(7.1) // Error: will panic.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你运行这段代码，它会因为神秘的消息而恐慌</p><pre class="line-numbers language-none"><code class="language-none">panic: reflect.Value.SetFloat using unaddressable value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>问题不在于该值<code>7.1</code>不可寻址；这<code>v</code>是不可设置的。可设置性是反射的属性<code>Value</code>，并非所有反射<code>Values</code>都有。</p><p>报告a的可设置性的<code>CanSet</code>方法；在我们的例子中，<code>Value``Value</code></p><pre class="line-numbers language-none"><code class="language-none">var x float64 = 3.4v := reflect.ValueOf(x)fmt.Println("settability of v:", v.CanSet())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>印刷</p><pre class="line-numbers language-none"><code class="language-none">settability of v: false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>Set</code>在 non-settable 上调用方法是错误的<code>Value</code>。但什么是可设置性？</p><p>可设置性有点像可寻址性，但更严格。这是反射对象可以修改用于创建反射对象的实际存储的属性。可设置性取决于反射对象是否持有原始项目。当我们说</p><pre class="line-numbers language-none"><code class="language-none">var x float64 = 3.4v := reflect.ValueOf(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们传递<code>x</code>to的副本<code>reflect.ValueOf</code>，因此作为 to 参数创建的接口值<code>reflect.ValueOf</code>是 的副本<code>x</code>，而不是<code>x</code>自身。因此，如果语句</p><pre class="line-numbers language-none"><code class="language-none">v.SetFloat(7.1)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>被允许成功，它不会更新<code>x</code>，即使它<code>v</code>看起来像是从<code>x</code>. <code>x</code>相反，它会更新存储在反射值中的副本，并且<code>x</code>它本身不会受到影响。那会令人困惑和无用，因此它是非法的，而可设置性是用于避免此问题的属性。</p><p>如果这看起来很奇怪，其实不然。这实际上是一个穿着不寻常服装的熟悉情况。考虑传递<code>x</code>给一个函数：</p><pre class="line-numbers language-none"><code class="language-none">f(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们不希望<code>f</code>能够修改，因为我们传递了’ 值<code>x</code>的副本，而不是它本身。如果我们想直接修改，我们必须将地址传递给我们的函数（即指向 的指针）：<code>x``x``f``x``x``x</code></p><pre class="line-numbers language-none"><code class="language-none">f(&amp;x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是直截了当和熟悉的，反射也以同样的方式工作。如果我们想<code>x</code>通过反射进行修改，我们必须给反射库一个指向我们要修改的值的指针。</p><p>让我们这样做。首先我们像往常一样初始化<code>x</code>，然后创建一个指向它的反射值，称为<code>p</code>.</p><pre class="line-numbers language-none"><code class="language-none">var x float64 = 3.4p := reflect.ValueOf(&amp;x) // Note: take the address of x.fmt.Println("type of p:", p.Type())fmt.Println("settability of p:", p.CanSet())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>到目前为止的输出是</p><pre class="line-numbers language-none"><code class="language-none">type of p: *float64settability of p: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>反射对象<code>p</code>是不可设置的，但它不是<code>p</code>我们想要设置的，它是 (in effect) <code>*p</code>。为了得到指向什么<code>p</code>，我们调用 的<code>Elem</code>方法<code>Value</code>，该方法通过指针间接传递，并将结果保存在<code>Value</code>名为的反射中<code>v</code>：</p><pre class="line-numbers language-none"><code class="language-none">v := p.Elem()fmt.Println("settability of v:", v.CanSet())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在<code>v</code>是一个可设置的反射对象，如输出所示，</p><pre class="line-numbers language-none"><code class="language-none">settability of v: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于它代表<code>x</code>，我们终于可以用来<code>v.SetFloat</code>修改 的值<code>x</code>：</p><pre class="line-numbers language-none"><code class="language-none">v.SetFloat(7.1)fmt.Println(v.Interface())fmt.Println(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>正如预期的那样，输出是</p><pre class="line-numbers language-none"><code class="language-none">7.17.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>反射可能很难理解，但它确实在做语言所做的事情，尽管是通过反射<code>Types</code>来<code>Values</code>掩盖正在发生的事情。请记住，反射值需要某些东西的地址才能修改它们所代表的内容。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在我们之前的示例<code>v</code>中，它本身并不是一个指针，它只是从一个指针派生而来。出现这种情况的常见方法是使用反射来修改结构的字段。只要我们有结构的地址，我们就可以修改它的字段。</p><p>这是一个分析结构值的简单示例，<code>t</code>. 我们使用结构的地址创建反射对象，因为我们稍后会修改它。然后我们设置<code>typeOfT</code>它的类型并使用简单的方法调用迭代字段（有关详细信息，请参阅<a href="https://go.dev/pkg/reflect/">包反映</a>）。请注意，我们从结构类型中提取字段的名称，但字段本身是常规<code>reflect.Value</code>对象。</p><pre class="line-numbers language-none"><code class="language-none">type T struct {    A int    B string}t := T{23, "skidoo"}s := reflect.ValueOf(&amp;t).Elem()typeOfT := s.Type()for i := 0; i &lt; s.NumField(); i++ {    f := s.Field(i)    fmt.Printf("%d: %s %s = %v\n", i,        typeOfT.Field(i).Name, f.Type(), f.Interface())}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个程序的输出是</p><pre class="line-numbers language-none"><code class="language-none">0: A int = 231: B string = skidoo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里顺便介绍了一点关于可设置性： 的字段名称<code>T</code>是大写的（导出的），因为只有结构的导出字段是可设置的。</p><p>因为<code>s</code>包含一个可设置的反射对象，所以我们可以修改结构体的字段。</p><pre class="line-numbers language-none"><code class="language-none">s.Field(0).SetInt(77)s.Field(1).SetString("Sunset Strip")fmt.Println("t is now", t)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>结果如下：</p><pre class="line-numbers language-none"><code class="language-none">t is now {77 Sunset Strip}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果我们修改程序以便<code>s</code>从<code>t</code>, not中创建，则对和<code>&amp;t</code>的调用将失败，因为 的字段不可设置。<code>SetInt``SetString``t</code></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这里又是反射定律：</p><ul><li>反射从接口值到反射对象。</li><li>反射从反射对象到接口值。</li><li>要修改反射对象，该值必须是可设置的。</li></ul><p>一旦你理解了这些定律，Go 中的反射就会变得更容易使用，尽管它仍然很微妙。这是一个强大的工具，除非绝对必要，否则应谨慎使用并避免使用。</p><p>还有很多我们没有涉及到的反射——在通道上发送和接收、分配内存、使用切片和映射、调用方法和函数——但是这篇文章已经足够长了。我们将在以后的文章中介绍其中的一些主题。</p><p>转载自：<a href="https://go.dev/blog/laws-of-reflection">https://go.dev/blog/laws-of-reflection</a>,转载请注</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件溯源与CQRS</title>
      <link href="/hypo-Z.github.io/2022/08/19/40-shi-jian-su-yuan-yu-cqrs/"/>
      <url>/hypo-Z.github.io/2022/08/19/40-shi-jian-su-yuan-yu-cqrs/</url>
      
        <content type="html"><![CDATA[<h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><h3 id="什么是域？"><a href="#什么是域？" class="headerlink" title="什么是域？"></a>什么是域？</h3><p>为其构建系统的领域。机场管理、保险销售、咖啡店、轨道飞行，应有尽有。</p><p>一个应用程序跨越多个不同的域并不罕见。例如，在线零售系统可能在运输（选择适当的交付方式，取决于物品和目的地）、定价（包括促销和用户特定的定价，例如位置）和推荐（计算相关按购买历史记录的产品）。</p><h3 id="什么是模型？"><a href="#什么是模型？" class="headerlink" title="什么是模型？"></a>什么是模型？</h3><p>“对手头问题的有用近似。” ——格里·苏斯曼</p><p>一个<code>Employee</code>班级不是真正的雇员。它<em>模拟</em>了一个真正的员工。我们知道该模型并不能捕捉到真正员工的所有信息，这不是重点。它只是为了捕捉我们对当前上下文感兴趣的内容。</p><p>不同的领域可能对建模同一事物的不同方式感兴趣。例如，工资部门和人力资源部门可能以不同的方式对员工进行建模。</p><h3 id="什么是领域模型？"><a href="#什么是领域模型？" class="headerlink" title="什么是领域模型？"></a>什么是领域模型？</h3><p>域的模型。</p><h3 id="什么是领域驱动设计-DDD-？"><a href="#什么是领域驱动设计-DDD-？" class="headerlink" title="什么是领域驱动设计 (DDD)？"></a>什么是领域驱动设计 (DDD)？</h3><p>这是一种深入重视领域模型并将其与实现联系起来的开发方法。DDD 由 Eric Evans 创造并最初开发。</p><h3 id="大家都在谈论的蓝皮书是什么？"><a href="#大家都在谈论的蓝皮书是什么？" class="headerlink" title="大家都在谈论的蓝皮书是什么？"></a>大家都在谈论的蓝皮书是什么？</h3><p><a href="http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">这个</a>？它是 DDD 创始人 Eric Evans 关于领域驱动设计的定义文本。强烈推荐它。</p><h3 id="什么是无处不在的语言？"><a href="#什么是无处不在的语言？" class="headerlink" title="什么是无处不在的语言？"></a>什么是无处不在的语言？</h3><p>涉及域、域模型、实现和后端的所有人员使用的一组术语。这个想法是避免<em>翻译</em>，因为正如 Eric Evans 指出的那样，</p><blockquote><p><em>翻译使交流变得迟钝，使知识处理变得乏力。</em></p></blockquote><p>也就是说，每次我们必须在人与人之间翻译概念时——“哦，在我使用‘帐户’的情况下，你使用的是‘用户’”——我们失去了清晰思考我们正在构建的东西的直接能力并让新知识在领域和实施之间来回流动。</p><p>投资一种无处不在的语言是有回报的，因为它使沟通更清晰，让团队看到更多的机会。</p><h3 id="什么是有界上下文？"><a href="#什么是有界上下文？" class="headerlink" title="什么是有界上下文？"></a>什么是有界上下文？</h3><p>一个更大的系统的一个部门，它有自己的通用语言和领域模型。在线零售商的定价、运输和推荐方面将被视为单独的有界上下文，因为它们具有显着不同的关注点。</p><p>与其他 DDD 概念一样，有界上下文在实施时最有价值。</p><h3 id="如何识别有界上下文？"><a href="#如何识别有界上下文？" class="headerlink" title="如何识别有界上下文？"></a>如何识别有界上下文？</h3><p>一些常见的事情是：</p><ul><li>组织中的自然边界（在有界上下文中，您通常会发现人们密切协作和沟通；在有界上下文之间，通信较少，并且通常是异步的）</li><li>同一个词被赋予不同的含义（产品到定价是一个有价格的东西；产品到运输是一个有重量和尺寸的东西，等等）</li></ul><p>通常，良好的有界上下文看起来像产品（定价策略产品、运输计算产品、产品推荐引擎产品等）。这与产品优于项目的团队结构非常吻合。</p><h3 id="有界上下文应该与我的系统的其余部分隔离到什么程度？"><a href="#有界上下文应该与我的系统的其余部分隔离到什么程度？" class="headerlink" title="有界上下文应该与我的系统的其余部分隔离到什么程度？"></a>有界上下文应该与我的系统的其余部分隔离到什么程度？</h3><p>相当强烈。一般来说，最好避免直接依赖。例如，在 .Net 中，单独的程序集是相当明智的。在诸如 SOA 或微服务之类的分布式范式中，在有界上下文之间找到进程边界是正常的。</p><h3 id="如何在有界上下文之间进行通信？"><a href="#如何在有界上下文之间进行通信？" class="headerlink" title="如何在有界上下文之间进行通信？"></a>如何在有界上下文之间进行通信？</h3><p>仅就其公共 API 而言。这可能涉及订阅来自另一个有界上下文的事件。或者一个有界上下文可以像另一个的常规客户端一样发送命令和查询。</p><h3 id="什么是实体？什么是价值对象？"><a href="#什么是实体？什么是价值对象？" class="headerlink" title="什么是实体？什么是价值对象？"></a>什么是实体？什么是价值对象？</h3><p><em>实体</em>或<em>引用类型</em>的特点是具有与其属性值无关的标识。实体中的所有属性都可以更改，并且它仍然是“相同”的实体。相反，两个实体可能在所有属性上都是等价的，但仍然是不同的。</p><p><em>值对象</em>没有单独的标识；它们仅由它们的属性值定义。虽然我们通常在提到值类型时谈论对象，但本机类型实际上是值类型的一个很好的例子。使值类型不可变是很常见的。例如，<code>String</code>在许多语言中是不可变的，每次您想“更改”一个字符串时，都会派生一个新字符串。</p><p>从事件溯源的角度来看，实体和值对象在域中都扮演着重要的角色，但只有实体需要被持久化，因为只有这些会发生变化。</p><h2 id="命令和事件"><a href="#命令和事件" class="headerlink" title="命令和事件"></a>命令和事件</h2><h3 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h3><p>事件代表在域中发生的事情。它们总是以过去分词动词命名，例如<code>OrderConfirmed</code>. 事件命名与其相关的聚合或实体并不罕见，但不是必需的；让领域语言成为您的指南。</p><p>由于事件代表过去的某事，因此可以将其视为事实陈述，并用于在系统的其他部分做出决策。</p><h3 id="什么是命令？"><a href="#什么是命令？" class="headerlink" title="什么是命令？"></a>什么是命令？</h3><p>人们通过发送命令请求更改域。它们以祈使语气加动词命名，可能包括聚合类型，例如 <code>ConfirmOrder</code>。与事件不同，命令不是事实陈述；这只是一个请求，因此可能会被拒绝。（表达拒绝的典型方式是抛出异常）。</p><h3 id="命令或事件是什么样的？"><a href="#命令或事件是什么样的？" class="headerlink" title="命令或事件是什么样的？"></a>命令或事件是什么样的？</h3><p>命令和事件只是包含用于读取的数据的数据结构，没有任何行为。我们称这种结构为“数据传输对象”（DTO）。名称表明目的。在许多语言中，它们被表示为类，但它们并不是真正的 OO 意义上的真正的类。下面是一个命令示例：</p><pre class="line-numbers language-none"><code class="language-none">public class ConfirmOrder {    public Guid OrderId;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是一个事件的例子：</p><pre class="line-numbers language-none"><code class="language-none">public class OrderConfirmed {    public Guid     OrderId;    public DateTime ConfirmationDate;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命令和事件有什么区别？"><a href="#命令和事件有什么区别？" class="headerlink" title="命令和事件有什么区别？"></a>命令和事件有什么区别？</h3><p>他们的意图。</p><h3 id="什么是不变性？为什么命令和事件是不可变的？"><a href="#什么是不变性？为什么命令和事件是不可变的？" class="headerlink" title="什么是不变性？为什么命令和事件是不可变的？"></a>什么是不变性？为什么命令和事件是不可变的？</h3><p>就这个问题而言，不变性没有任何设置器或其他改变内部状态的方法。Java 和 C# 中的字符串类型是一个熟悉的例子。你永远不会真正<em>改变</em>现有的字符串值，你只是根据旧的字符串值创建新的字符串值。</p><p>命令是不可变的，因为它们的预期用途是直接<em>发送</em>到域模型端进行处理。他们不需要在从客户端到服务器的预计生命周期内进行更改。</p><p>事件是不可变的，因为它们代表过去发生的域操作。除非你是 Marty McFly，否则你无法改变过去，有时甚至无法改变过去。</p><h3 id="什么是命令升级？"><a href="#什么是命令升级？" class="headerlink" title="什么是命令升级？"></a>什么是命令升级？</h3><p>当新要求导致现有命令不够用时，升级命令变得必要。例如，可能需要添加一个新字段，或者可能确实应该将现有字段拆分为几个不同的字段。</p><h3 id="如何升级我的命令？"><a href="#如何升级我的命令？" class="headerlink" title="如何升级我的命令？"></a>如何升级我的命令？</h3><p>您如何进行升级取决于您对客户的控制程度。如果您可以同时部署客户端更新和服务器更新，只需更改两者并部署更新即可。任务完成。如果没有，通常最好让更新的命令成为一种新类型，并让命令处理程序接受一段时间。</p><h3 id="您能否举例说明一些版本化命令的名称？"><a href="#您能否举例说明一些版本化命令的名称？" class="headerlink" title="您能否举例说明一些版本化命令的名称？"></a>您能否举例说明一些版本化命令的名称？</h3><p>当然。</p><pre class="line-numbers language-none"><code class="language-none">UploadFileUploadFile_v2UploadFile_v3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这只是一种约定，但一种理智的约定。</p><h2 id="命令-查询职责分离"><a href="#命令-查询职责分离" class="headerlink" title="命令/查询职责分离"></a>命令/查询职责分离</h2><h3 id="什么是-CQRS？"><a href="#什么是-CQRS？" class="headerlink" title="什么是 CQRS？"></a>什么是 CQRS？</h3><p>CQRS 的意思是“命令查询职责分离”。我们在 <em>命令</em>（写入请求）和<em>查询</em>（读取请求）之间<em>分离**职责。</em>写请求和读请求由不同的对象处理。</p><p>而已。我们可以进一步拆分数据存储，拥有独立的读写存储。一旦发生这种情况，可能会有许多读取存储，针对处理不同类型的查询或跨越许多有界上下文进行了优化。尽管经常讨论与 CQRS 相关的单独的读/写存储，但这不是 CQRS 本身。CQRS 只是命令和查询的第一个拆分。</p><h3 id="CQRS-听起来像是那些新奇的饮食之一。这个词是谁编的？"><a href="#CQRS-听起来像是那些新奇的饮食之一。这个词是谁编的？" class="headerlink" title="CQRS 听起来像是那些新奇的饮食之一。这个词是谁编的？"></a>CQRS 听起来像是那些新奇的饮食之一。这个词是谁编的？</h3><p>格雷格·杨。</p><p>多年来，他一直在抱怨搜索引擎天真地问“你是说汽车吗？” 当搜索 CQRS 时。</p><h3 id="我听说还有一种叫做-CQS-的东西。它是什么，它与-CQRS-有什么关系？"><a href="#我听说还有一种叫做-CQS-的东西。它是什么，它与-CQRS-有什么关系？" class="headerlink" title="我听说还有一种叫做 CQS 的东西。它是什么，它与 CQRS 有什么关系？"></a>我听说还有一种叫做 CQS 的东西。它是什么，它与 CQRS 有什么关系？</h3><p>CQS 的意思是“命令-查询分离”。它是由 Bertrand Meyer 介绍的，作为他在 Eiffel 编程语言工作的一部分。</p><p>这意味着方法要么是执行操作的<em>命令，要么是返回数据的**查询</em> ，但不能两者兼而有之。作为纯粹的动作执行方法，命令总是有一个<code>void</code>返回类型。另一方面，查询不应该对系统本身产生任何可观察到的副作用。</p><p>最初，CQRS 也被称为“CQS”。但确定两者的差异足以让 CQRS 拥有自己的名字。主要区别在于：</p><ul><li>CQS 将命令和查询放在一个类型中的不同<em>方法中。</em></li><li>CQRS 将命令和查询放在不同的<em>对象</em>上。</li></ul><h3 id="CQRS-可以简化吗？"><a href="#CQRS-可以简化吗？" class="headerlink" title="CQRS 可以简化吗？"></a>CQRS 可以简化吗？</h3><p>当然。通用存储库在许多系统中都很常见。它们在 CRUD 场景中运行良好——通常是那些你可能没有应用 DDD 的场景。它们往往适用于创建、更新、删除和读取单个实体。但是一旦有一个跨越多个实体的查询，它应该去哪里？</p><p>与其苦恼于它，并试图将查询硬塞到通用存储库安排中，不如将它们放在一个单独的对象上要容易得多。毫无疑问，他们可以返回简单、轻量级的数据 DTO。</p><p>CQRS 并不一定意味着进行事件溯源、引入命令、事件、读取面、sagas 等等。</p><h3 id="CQRS-不会使我的应用程序更复杂吗？"><a href="#CQRS-不会使我的应用程序更复杂吗？" class="headerlink" title="CQRS 不会使我的应用程序更复杂吗？"></a>CQRS 不会使我的应用程序更复杂吗？</h3><p>一个典型的 CQRS + 事件溯源系统似乎有更多的组件，因为命令、事件、异常和查询成为公共接口的一部分。聚合、命令处理程序、读取侧投影、sagas 和客户端进一步促进了组件的扩散。</p><p>然而，每个组件都与其他组件巧妙地分离。最初，“复杂”的意思是“编织在一起”。CQRS+ES 系统中的组件是独立的，有利于对系统进行推理并响应不断变化的需求：</p><ul><li>消息类型的公共接口构成了应用程序的一层，鼓励您根据用户意图进行思考，而不是更新数据。</li><li>系统分为客户端、写入端和读取端，便于在各个团队之间划分工作。</li><li>也许最重要的是，测试变得非常自然，即使是业务逻辑中最重要和最复杂的部分。</li></ul><h3 id="写入端是否应该始终独立于读取端？"><a href="#写入端是否应该始终独立于读取端？" class="headerlink" title="写入端是否应该始终独立于读取端？"></a>写入端是否应该始终独立于读取端？</h3><p>不会。但它通常会有所帮助——例如，通过在写入端使用事件溯源，这可以提供很多好处。</p><h2 id="事件溯源"><a href="#事件溯源" class="headerlink" title="事件溯源"></a>事件溯源</h2><h3 id="什么是事件溯源？"><a href="#什么是事件溯源？" class="headerlink" title="什么是事件溯源？"></a>什么是事件溯源？</h3><p>将所有更改（事件）存储到系统，而不仅仅是其当前状态。</p><h3 id="为什么我以前没有听说过？"><a href="#为什么我以前没有听说过？" class="headerlink" title="为什么我以前没有听说过？"></a>为什么我以前没有听说过？</h3><p>你有。几乎所有事务 RDBMS 系统都使用事务日志来存储应用于数据库的所有更改。在紧要关头，可以从此事务日志重新创建数据库的当前状态。这是一种活动。事件溯源只是意味着遵循这个想法并使用这样的日志作为主要数据源。</p><h3 id="事件溯源有哪些优势？"><a href="#事件溯源有哪些优势？" class="headerlink" title="事件溯源有哪些优势？"></a>事件溯源有哪些优势？</h3><ul><li>能够将系统置于任何先前状态。对调试很有用。（即上周系统是什么样的？）</li><li>拥有系统的真实历史。提供更多好处，例如审计和可追溯性。在某些领域，这是法律要求的。</li><li>我们通过存储所有事件并能够根据需要创建任意读取端预测来减轻无法预测未来需求的负面影响。这允许对新要求做出更灵活的响应。</li><li>在事件存储上进行的操作类型非常有限，使得持久性非常可预测，从而简化了测试。</li><li>事件存储在概念上比完整的 RDBMS 解决方案更简单，并且很容易从内存中的事件列表扩展到功能齐全的事件存储。</li></ul><h3 id="事件溯源是否需要执行-CQRS？"><a href="#事件溯源是否需要执行-CQRS？" class="headerlink" title="事件溯源是否需要执行 CQRS？"></a>事件溯源是否需要执行 CQRS？</h3><p>不，您可以以您喜欢的任何形式保存您的聚合。然而，事件溯源与 CQRS 配合得很好，并带来了许多额外的好处。</p><h3 id="如果事件队列中的事件被证明是错误的怎么办？"><a href="#如果事件队列中的事件被证明是错误的怎么办？" class="headerlink" title="如果事件队列中的事件被证明是错误的怎么办？"></a>如果事件队列中的事件被证明是错误的怎么办？</h3><p>在事件队列中，新事件被添加到队列的末尾。事件永远不会被删除或更改。（顺便说一句，就像在会计师的分类账中一样。）补偿措施是您可以添加的，以纠正实际错误。它们只是抵消早期事件的事件。</p><h3 id="使用事件溯源不会让我的系统变慢吗？"><a href="#使用事件溯源不会让我的系统变慢吗？" class="headerlink" title="使用事件溯源不会让我的系统变慢吗？"></a>使用事件溯源不会让我的系统变慢吗？</h3><p>不。</p><p>应用事件来建立当前状态需要更多时间。但是处理器真的很快。应用事件需要微秒的数量级。对于大多数域，性能不是问题。</p><p>此外，与事件溯源密切相关的聚合边界应该会导致系统能够很好地水平扩展。</p><h3 id="什么是快照？"><a href="#什么是快照？" class="headerlink" title="什么是快照？"></a>什么是快照？</h3><p>一种优化，聚合状态的快照也每隔一段时间（从概念上）保存在事件队列中，以便事件应用程序可以从快照开始，而不是从头开始。这可以加快速度。快照总是可以根据需要丢弃或重新创建，因为它们表示来自事件流的计算信息。</p><p>通常，与持久事件的常规任务分开的后台进程负责创建快照。</p><p>快照有许多与在数据库中重新引入当前状态相关的缺点。与其假设您将需要它，不如先不做快照，然后在分析表明它会有所帮助后才添加它。</p><h3 id="如何版本-升级我的活动？"><a href="#如何版本-升级我的活动？" class="headerlink" title="如何版本/升级我的活动？"></a>如何版本/升级我的活动？</h3><p>您将它们原样保留在事件存储中，因为它在概念上是一个仅附加列表。但是，写入方和读取方都可以“升级”其处理程序中的传入事件。一个事件总是可以升级到一个更新的版本……如果不是，它可能毕竟不是一个更新的版本，而是一个完全不同的事件类型。</p><h3 id="随着时间的推移，我如何处理不断增长的-大型事件存储？"><a href="#随着时间的推移，我如何处理不断增长的-大型事件存储？" class="headerlink" title="随着时间的推移，我如何处理不断增长的/大型事件存储？"></a>随着时间的推移，我如何处理不断增长的/大型事件存储？</h3><p>事件通常很小，您可以轻松地在低端关系数据库上存储、索引和搜索数百万个事件。</p><p>也就是说，提前计划总是好的，并选择在大小方面为您提供良好服务的序列化格式。例如，JSON 往往小于相应的 XML。</p><p>如果您觉得需要通过算法压缩您的事件，这也是一种选择。Google 的协议缓冲区是要使用的压缩序列化的现代示例。</p><p>对于实际上硬盘空间用完的情况：现在磁盘很便宜。考虑将历史事件保存在一些永久存储中。活动具有重要的商业价值；不要把它们扔掉。</p><p>如果事件存储超过了单台机器，那么很容易首先按聚合类型进行分片，并且即使在聚合本身的级别上也可以使用少量基于内容的路由。</p><h3 id="我也可以坚持命令吗？"><a href="#我也可以坚持命令吗？" class="headerlink" title="我也可以坚持命令吗？"></a>我也可以坚持命令吗？</h3><p>记录命令通常很有用，因为它们包含有关在域模型上发出的请求的重要信息。</p><p>但是命令不是事件，它们不属于事件存储。只需考虑将命令的日志记录作为围绕命令处理程序的附加方面。</p><h2 id="CAP-和最终一致性"><a href="#CAP-和最终一致性" class="headerlink" title="CAP 和最终一致性"></a>CAP 和最终一致性</h2><h3 id="什么是-CAP-定理？"><a href="#什么是-CAP-定理？" class="headerlink" title="什么是 CAP 定理？"></a>什么是 CAP 定理？</h3><p>CAP 定理指出，在分布式系统中，您可以在给定时间点具有以下三个属性中的两个：</p><ul><li>一致性</li><li>可用性</li><li>分区容错</li></ul><p>要理解原因，想象一下当分区两侧的两个节点尝试更新整个系统时会发生什么。</p><h3 id="CAP-适用于什么级别？"><a href="#CAP-适用于什么级别？" class="headerlink" title="CAP 适用于什么级别？"></a>CAP 适用于什么级别？</h3><p>CAP 是细粒度的。您可以在系统的不同部分做出不同的选择。例如，对于接受订单，通常需要可用性，因为您不想丢失订单！</p><h3 id="什么是最终一致性？"><a href="#什么是最终一致性？" class="headerlink" title="什么是最终一致性？"></a>什么是最终一致性？</h3><p>不再强调系统中的即时一致性（即所有事物始终具有相同的数据视图），以换取更高的可用性和更大的组件自主权。</p><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><h3 id="如何处理重复的命令-事件问题？"><a href="#如何处理重复的命令-事件问题？" class="headerlink" title="如何处理重复的命令/事件问题？"></a>如何处理重复的命令/事件问题？</h3><p>在传输层。</p><h3 id="发布事件时应该使用推送还是拉取？"><a href="#发布事件时应该使用推送还是拉取？" class="headerlink" title="发布事件时应该使用推送还是拉取？"></a>发布事件时应该使用推送还是拉取？</h3><p>推送的优点是事件可以在发生时推送。拉取的优点是读取端可以更加活跃和独立。在我们看来，在读取端使用本地事件缓存拉取似乎是最好的和最具可扩展性的解决方案。但是，Push 可以很好地与反应式编程和 Web 套接字一起工作。同样，您不必在系统中的任何地方都做出相同的选择。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="如何测试我的-CQRS-应用程序？"><a href="#如何测试我的-CQRS-应用程序？" class="headerlink" title="如何测试我的 CQRS 应用程序？"></a>如何测试我的 CQRS 应用程序？</h3><p>仅使用命令、事件和异常。</p><h3 id="什么是行为测试？"><a href="#什么是行为测试？" class="headerlink" title="什么是行为测试？"></a>什么是行为测试？</h3><p>纯粹基于对象的行为进行测试，而不讨论其状态。具体来说，这意味着我们只调用方法。这非常适合命令和事件方面的测试，因为应用事件和处理命令是聚合的公共 API 的一部分。</p><h3 id="“告诉，不要问”是什么意思？"><a href="#“告诉，不要问”是什么意思？" class="headerlink" title="“告诉，不要问”是什么意思？"></a>“告诉，不要问”是什么意思？</h3><p>决策应在数据所在的封装边界内做出。对象或集合是“专家”，外部事物不应该询问它的状态然后为它做出决定。</p><p>“告诉，不要问”被认为是面向对象设计的一个很好的原则。</p><p>CQRS 应用程序鼓励的测试是“告诉，不要问”的一个很好的例子。测试聚合行为的唯一方法是设置它们（使用事件），告诉它们做某事（使用命令），然后观察结果（更多事件或异常）。</p><h3 id="我如何知道命令因正确原因而失败？"><a href="#我如何知道命令因正确原因而失败？" class="headerlink" title="我如何知道命令因正确原因而失败？"></a>我如何知道命令因正确原因而失败？</h3><p>使用类型化异常来指示失败的模式，并在测试中排除该类型的异常。</p><h3 id="所以我知道我得到了正确的事件，但我怎么知道它意味着什么？"><a href="#所以我知道我得到了正确的事件，但我怎么知道它意味着什么？" class="headerlink" title="所以我知道我得到了正确的事件，但我怎么知道它意味着什么？"></a>所以我知道我得到了正确的事件，但我怎么知道它意味着什么？</h3><p>测试给定命令是否导致预期事件只是工作的一半。为了确保事件的应用程序确实有意义，请在历史记录中使用该事件编写测试。例如，要测试一个指示预约的事件是否真正生效，将其放入历史记录并尝试进行冲突预约。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><h3 id="什么是聚合？"><a href="#什么是聚合？" class="headerlink" title="什么是聚合？"></a>什么是聚合？</h3><p>一个比一个类更大的封装单元。每个事务都限定为一个聚合。聚合的组件的生命周期受整个聚合的生命周期的限制。</p><p>具体来说，聚合将处理命令、应用事件，并在其中封装一个状态模型，允许它实现所需的命令验证，从而维护聚合的不变量（业务规则）。</p><h3 id="聚合和聚合根有什么区别？"><a href="#聚合和聚合根有什么区别？" class="headerlink" title="聚合和聚合根有什么区别？"></a>聚合和聚合根有什么区别？</h3><p>聚合形成对象关系的树或图。聚合根是“顶部”的根，它代表整体，并且可以委托给其余部分。这很重要，因为它是世界其他地方与之交流的地方。</p><h3 id="我知道聚合是事务边界，但我确实需要在同一个事务中以事务方式更新两个聚合。我应该怎么办？"><a href="#我知道聚合是事务边界，但我确实需要在同一个事务中以事务方式更新两个聚合。我应该怎么办？" class="headerlink" title="我知道聚合是事务边界，但我确实需要在同一个事务中以事务方式更新两个聚合。我应该怎么办？"></a>我知道聚合是事务边界，但我确实需要在同一个事务中以事务方式更新两个聚合。我应该怎么办？</h3><p>您应该重新考虑以下问题：</p><ul><li>您的总边界。</li><li>每个聚合的职责。</li><li>在阅读方面或传奇中，您可以逃脱惩罚。</li><li>您的域的实际非功能性需求。</li></ul><p>如果您编写了一个解决方案，其中两个或多个聚合是事务耦合的，那么您还没有理解聚合。</p><h3 id="为什么使用-GUID-作为-ID-是一种好习惯？"><a href="#为什么使用-GUID-作为-ID-是一种好习惯？" class="headerlink" title="为什么使用 GUID 作为 ID 是一种好习惯？"></a>为什么使用 GUID 作为 ID 是一种好习惯？</h3><p>因为它们（合理地）是全局唯一的，并且可以由服务器或客户端生成。</p><h3 id="如何获取新创建的聚合的-ID？"><a href="#如何获取新创建的聚合的-ID？" class="headerlink" title="如何获取新创建的聚合的 ID？"></a>如何获取新创建的聚合的 ID？</h3><p>客户端可以生成自己的 ID，这是一个重要的见解。</p><p>如果客户端生成一个 GUID 并将其放置在 create-the-aggregate 命令中，这不是问题。否则，您必须从适当的读取端进行轮询，其中 ID 将出现在最终一致的时间范围内。显然，这比一开始就生成它要脆弱得多。</p><h3 id="我应该允许聚合之间的引用吗？"><a href="#我应该允许聚合之间的引用吗？" class="headerlink" title="我应该允许聚合之间的引用吗？"></a>我应该允许聚合之间的引用吗？</h3><p>在实际的“内存引用”的意义上，绝对不是。</p><p>在写入方面，从一个聚合到另一个聚合的实际内存引用是被禁止和错误的，因为根据定义不允许聚合到达它们自身之外。（允许这意味着聚合不再是事务边界，这意味着我们不能再理智地推断其支持其不变量的能力；它还将排除聚合的分片。）</p><p>使用字符串标识符引用另一个聚合很好。它在写入端是无用的（因为标识符必须被视为一个不透明的值，因为聚合无法到达它们自身之外）。然而，阅读方可以自由地使用这些信息来进行有趣的关联。</p><h3 id="如何跨一组聚合验证命令？"><a href="#如何跨一组聚合验证命令？" class="headerlink" title="如何跨一组聚合验证命令？"></a>如何跨一组聚合验证命令？</h3><p>这是对不再能够跨聚合进行查询的常见反应。有几个答案：</p><ul><li>进行客户端验证。</li><li>使用读取端。</li><li>使用传奇。</li><li>如果这些都是完全不切实际的，那么是时候考虑一下你的聚合边界是否正确了。</li></ul><h3 id="如何保证跨聚合的引用完整性？"><a href="#如何保证跨聚合的引用完整性？" class="headerlink" title="如何保证跨聚合的引用完整性？"></a>如何保证跨聚合的引用完整性？</h3><p>你仍然在考虑外交关系，而不是总体。见最后一个问题。另外，请记住，仅仅因为关系设计中有两个表并不意味着它应该是两个聚合。聚合设计是不同的。</p><h3 id="如何确保新创建的用户具有唯一的用户名？"><a href="#如何确保新创建的用户具有唯一的用户名？" class="headerlink" title="如何确保新创建的用户具有唯一的用户名？"></a>如何确保新创建的用户具有唯一的用户名？</h3><p>这是一个经常出现的问题，因为我们没有明确地在写入端执行交叉聚合操作。但是，我们确实有多种选择：</p><ul><li>创建已分配用户名的读取端。当用户键入名称时，使客户端以交互方式查询读取端。</li><li>创建一个反应式传奇来标记和停用仍然使用重复用户名创建的帐户。（无论是极端巧合还是恶意或由于客户端故障。）</li><li>如果最终一致性对您来说不够快，请考虑在已分配名称的写入端添加一个表，就像是一个小的本地读取端。使聚合事务包括插入该表。</li></ul><h3 id="下订单时如何验证客户-ID-是否真实存在？"><a href="#下订单时如何验证客户-ID-是否真实存在？" class="headerlink" title="下订单时如何验证客户 ID 是否真实存在？"></a>下订单时如何验证客户 ID 是否真实存在？</h3><p>假设 customer 和 order 在这里是聚合，很明显 order 聚合不能真正验证这一点，因为这意味着超出聚合。</p><p>事后检查它，在传奇中或只是在记录“损坏”订单的读取端，是一种选择。毕竟，关于订单最重要的事情实际上是记录它，并且大概任何关于订单接收者的有趣数据都被复制到订单聚合中（指客户找到地址是糟糕的设计；订单总是交付到特定地址，无论该客户将来是否更改其地址）。</p><p>能够使用以这种损坏的顺序记录的数据意味着您有机会拯救它并纠正这种情况 - 这比因为违反外键约束而放弃订单更具商业意义！</p><h3 id="如何使用单个命令更新一组聚合？"><a href="#如何使用单个命令更新一组聚合？" class="headerlink" title="如何使用单个命令更新一组聚合？"></a>如何使用单个命令更新一组聚合？</h3><p>单个命令<em>不能</em>作用于一组聚合。它就是不能。</p><p>首先，问问自己是否真的需要只使用一个命令来更新多个聚合。在这种情况下，这是什么要求？</p><p>但是，这是您可以做的。允许一种新的“批量命令”，概念上包含您要发出的命令，以及您要发出它的一组聚合（显式或隐式指定）。写入端的功能不足以进行批量操作，但它能够创建相应的“批量事件”。saga 捕获事件，并对每个指定的聚合发出命令。如果某些命令失败，saga 可以酌情回滚或发送电子邮件。</p><p>这种方法有一些优点：我们将批量操作的意图存储在事件存储中。传奇自动回滚或等效。</p><p>尽管如此，不得不求助于这个解决方案是一个强烈的迹象，表明您的聚合边界没有正确绘制。您可能需要考虑更改聚合边界，而不是为此构建传奇。</p><h3 id="什么是分片？"><a href="#什么是分片？" class="headerlink" title="什么是分片？"></a>什么是分片？</h3><p>一种在多个写入端节点上分布大量聚合的方法。我们可以轻松地对聚合进行分片<em>，因为</em>它们是完全自力更生的。</p><p>我们可以轻松地对聚合进行分片<em>，因为</em>它们没有任何外部引用。</p><h3 id="聚合可以将事件发送到另一个聚合吗？"><a href="#聚合可以将事件发送到另一个聚合吗？" class="headerlink" title="聚合可以将事件发送到另一个聚合吗？"></a>聚合可以将事件发送到另一个聚合吗？</h3><p>不。</p><p>聚合和命令处理程序的分解通常已经使这个想法无法在代码中表达。但还有一个更深层次的哲学原因：回去重新阅读 <a href="http://cqrs.nu/Faq#what-is-an-aggregate">“什么是聚合？”的答案中的第一句话。</a>. 如果您设法绕过命令处理程序并以某种方式将事件推送到另一个聚合中，那么您将剥夺该聚合参与更改验证的机会。这最终就是为什么我们只允许在聚合上的命令处理程序验证的命令的结果中创建事件。</p><h3 id="我可以从我的聚合中调用读取端吗？"><a href="#我可以从我的聚合中调用读取端吗？" class="headerlink" title="我可以从我的聚合中调用读取端吗？"></a>我可以从我的聚合中调用读取端吗？</h3><p>不。</p><h3 id="如何在-CQRS-系统中发送电子邮件？"><a href="#如何在-CQRS-系统中发送电子邮件？" class="headerlink" title="如何在 CQRS 系统中发送电子邮件？"></a>如何在 CQRS 系统中发送电子邮件？</h3><p>在聚合之外的事件处理程序中。不要在命令处理程序中执行此操作，就好像由于与另一个命令的竞争而导致事件没有持久化，那么电子邮件将在错误的前提下发送。</p><h2 id="命令处理程序"><a href="#命令处理程序" class="headerlink" title="命令处理程序"></a>命令处理程序</h2><h3 id="命令处理程序做什么？"><a href="#命令处理程序做什么？" class="headerlink" title="命令处理程序做什么？"></a>命令处理程序做什么？</h3><p>命令处理程序接收命令并代理来自适当聚合的结果。“结果”要么是命令的成功应用，要么是异常。</p><p>这是命令处理程序遵循的常见步骤序列：</p><ol><li>验证命令本身的优点。</li><li>在聚合的当前状态上验证命令。</li><li>如果验证成功，则 0..n 个事件（1 是常见的）。</li><li>尝试持久化新事件。如果在这一步发生并发冲突，要么放弃，要么重试。</li></ol><h3 id="命令处理程序是否应该影响一个或多个聚合？"><a href="#命令处理程序是否应该影响一个或多个聚合？" class="headerlink" title="命令处理程序是否应该影响一个或多个聚合？"></a>命令处理程序是否应该影响一个或多个聚合？</h3><p>只有一个。</p><h3 id="我是否将逻辑放入命令处理程序中？"><a href="#我是否将逻辑放入命令处理程序中？" class="headerlink" title="我是否将逻辑放入命令处理程序中？"></a>我是否将逻辑放入命令处理程序中？</h3><p>是的。究竟什么逻辑取决于您的因式分解。</p><p>验证命令本身的优点的逻辑总是在命令处理程序中。如果命令处理程序只是聚合上的一个方法，那么下一步就是简单地使用聚合的状态来做进一步的验证。在功能更强大的分解中，聚合独立于命令处理程序存在，下一步是加载聚合并对其进行验证。</p><p>如果验证成功，那么命令处理程序应该会产生事件。根据因子的不同，它还可能需要进一步的步骤来尝试和持久化它们。</p><p>在 Edument CQRS 入门工具包中，命令处理程序是返回事件的方法。事件的加载、聚合的构建和事件的持久化完全由命令处理程序考虑。这使它们非常干净和专注，因此与持久性机制完全解耦。</p><p>不管你有它，逻辑归结为验证和一些导致命令成为异常或事件的步骤序列。如果您想超越这一点，请参阅本节中的其余问题。</p><h3 id="我可以从我的命令处理程序调用读取端吗？"><a href="#我可以从我的命令处理程序调用读取端吗？" class="headerlink" title="我可以从我的命令处理程序调用读取端吗？"></a>我可以从我的命令处理程序调用读取端吗？</h3><p>不。</p><h3 id="我可以在我的命令处理程序中进行日志记录、安全性或审计吗？"><a href="#我可以在我的命令处理程序中进行日志记录、安全性或审计吗？" class="headerlink" title="我可以在我的命令处理程序中进行日志记录、安全性或审计吗？"></a>我可以在我的命令处理程序中进行日志记录、安全性或审计吗？</h3><p>是的。装饰器模式在这里派上用场，可以巧妙地分离这些关注点。</p><h3 id="命令处理程序中如何处理并发命令之间的冲突？"><a href="#命令处理程序中如何处理并发命令之间的冲突？" class="headerlink" title="命令处理程序中如何处理并发命令之间的冲突？"></a>命令处理程序中如何处理并发命令之间的冲突？</h3><p>聚合的新事件被持久化的地方是系统中唯一需要担心并发冲突的地方。事件存储知道应用于该聚合的最新事件的序列号，命令处理程序知道它读取的最后一个事件的序列号。如果这些数字不一致，则意味着其他线程或进程首先到达那里。然后，命令处理程序可以再次加载事件并进行新的尝试。</p><h3 id="我应该在命令处理程序中做对外界有副作用的事情（例如发送电子邮件）吗？"><a href="#我应该在命令处理程序中做对外界有副作用的事情（例如发送电子邮件）吗？" class="headerlink" title="我应该在命令处理程序中做对外界有副作用的事情（例如发送电子邮件）吗？"></a>我应该在命令处理程序中做对外界有副作用的事情（例如发送电子邮件）吗？</h3><p>不，因为并发冲突将意味着命令处理程序逻辑将再次运行。在事件处理程序中执行此类操作。</p><h2 id="读边"><a href="#读边" class="headerlink" title="读边"></a>读边</h2><h3 id="什么是读端？"><a href="#什么是读端？" class="headerlink" title="什么是读端？"></a>什么是读端？</h3><p>读取端侦听从写入端发布的事件，将这些事件投影为对本地模型的更改，并允许对该模型进行查询。</p><h3 id="读边解决了哪些实际问题？"><a href="#读边解决了哪些实际问题？" class="headerlink" title="读边解决了哪些实际问题？"></a>读边解决了哪些实际问题？</h3><p>它们使关联模型数据（<code>JOIN</code>用 SQL 术语称为）的成本从每次读取变为每次写入。读取端的查询只是直接的 <code>SELECT</code>，因为数据已经处于客户想要的形状。</p><p>这是一个净赢，因为通常情况下，系统中的读写比率通常为 10 或更多。这个想法与 SQL 数据库中的“视图”非常相似。</p><h3 id="如果我的域的写入次数多于读取次数怎么办？"><a href="#如果我的域的写入次数多于读取次数怎么办？" class="headerlink" title="如果我的域的写入次数多于读取次数怎么办？"></a>如果我的域的写入次数多于读取次数怎么办？</h3><p>你<em>确定</em>吗？在做出肯定的答复之前，请确保您进行了测量。</p><p>一些域（例如电信）在短期内的写入强度很高，并且对写入端的要求很高。但随后读取端通常会赶上并读取接管。</p><p>某些领域（例如实时股票市场）完全由传入的数据控制，并且必须优化写入端以实时应用命令。</p><h3 id="什么是投影？"><a href="#什么是投影？" class="headerlink" title="什么是投影？"></a>什么是投影？</h3><p>一组协同工作以构建和维护读取模型的事件处理程序。</p><h3 id="如果我构建了一个读取端并且预测结果以某种方式错误怎么办？"><a href="#如果我构建了一个读取端并且预测结果以某种方式错误怎么办？" class="headerlink" title="如果我构建了一个读取端并且预测结果以某种方式错误怎么办？"></a>如果我构建了一个读取端并且预测结果以某种方式错误怎么办？</h3><p>如果您无法在运行中轻松纠正它，则使用固定投影构建读取端的新版本，部署它，让它重新处理事件存储中的所有事件，以便它使用最新数据，然后切换查询使用它。</p><h2 id="Sagas"><a href="#Sagas" class="headerlink" title="Sagas"></a>Sagas</h2><h3 id="什么是Sagas？"><a href="#什么是Sagas？" class="headerlink" title="什么是Sagas？"></a>什么是Sagas？</h3><p>以交叉聚合、最终一致的方式对域事件作出反应的独立组件。时间也可以是触发器。Sagas 有时纯粹是响应式的，有时代表工作流。</p><p>从实现的角度来看，saga 是由传入事件（可能来自许多聚合）驱动的状态机。某些状态会产生副作用，例如发送命令、与外部 Web 服务交谈或发送电子邮件。</p><h3 id="Sagas不是泄露了领域逻辑吗？"><a href="#Sagas不是泄露了领域逻辑吗？" class="headerlink" title="Sagas不是泄露了领域逻辑吗？"></a>Sagas不是泄露了领域逻辑吗？</h3><p>不。</p><p>Sagas 正在做的事情是任何个体聚合都无法明智地做到的。因此，这不是逻辑泄漏，因为无论如何逻辑都不属于聚合。此外，我们不会以任何方式破坏封装，因为 sagas 使用命令和事件进行操作，它们是公共 API 的一部分。</p><h3 id="我怎样才能让我的Saga对没有发生的事件做出反应？"><a href="#我怎样才能让我的Saga对没有发生的事件做出反应？" class="headerlink" title="我怎样才能让我的Saga对没有发生的事件做出反应？"></a>我怎样才能让我的Saga对<em>没有</em>发生的事件做出反应？</h3><p>除了对领域事件做出反应外，传奇故事还可以被反复出现的内部警报“唤醒”。实现这样的警报很容易。例如，参见<code>cron</code>Unix。</p><h3 id="saga-如何与写入端交互？"><a href="#saga-如何与写入端交互？" class="headerlink" title="saga 如何与写入端交互？"></a>saga 如何与写入端交互？</h3><p>通过向它发送命令。</p><h2 id="偶尔连接的系统"><a href="#偶尔连接的系统" class="headerlink" title="偶尔连接的系统"></a>偶尔连接的系统</h2><h3 id="线下客户呢？"><a href="#线下客户呢？" class="headerlink" title="线下客户呢？"></a>线下客户呢？</h3><p>客户端可以离线工作，允许您在本地发出命令，在重新连接时与写入端同步。</p><p>客户端倾向于引入写入端（用于进行本地验证）和读取端（更新速度超过最终一致性允许的速度）的功能。从某种意义上说，由于客户端是系统的用户窗口，它总是有增长的趋势，直到它看起来像整个系统的一个小副本，包括写端和读端。</p><h3 id="什么是命令合并？"><a href="#什么是命令合并？" class="headerlink" title="什么是命令合并？"></a>什么是命令合并？</h3><p>有时在高度协作的域中，命令“太晚”到达，并且聚合的当前状态已经改变，因此命令不能干净地应用。命令合并是从命令中提取潜在意图，然后从该意图创建和应用新命令的行为。</p><h3 id="在偶尔连接的客户端中，如何在实践中完成命令合并？"><a href="#在偶尔连接的客户端中，如何在实践中完成命令合并？" class="headerlink" title="在偶尔连接的客户端中，如何在实践中完成命令合并？"></a>在偶尔连接的客户端中，如何在实践中完成命令合并？</h3><p>git 合并模型似乎很适合窃取。</p><p>转自<a href="http://cqrs.nu/Faq">http://cqrs.nu/Faq</a>,更多详情可前往查看<br>项目示例：<a href="https://github.com/looplab/eventhorizon">https://github.com/looplab/eventhorizon</a></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观主义塑造未来</title>
      <link href="/hypo-Z.github.io/2022/08/15/39-le-guan-zhu-yi-su-zao-wei-lai/"/>
      <url>/hypo-Z.github.io/2022/08/15/39-le-guan-zhu-yi-su-zao-wei-lai/</url>
      
        <content type="html"><![CDATA[<h1 id="乐观主义塑造未来"><a href="#乐观主义塑造未来" class="headerlink" title="乐观主义塑造未来"></a>乐观主义塑造未来</h1><blockquote><p>“我认为到2042年，我们会迎来一场真正的繁荣。”</p></blockquote><blockquote><p>“当后人回顾2022年，物价飞涨，股市低迷。此时此刻就是下一段历史的开端。”</p></blockquote><blockquote><p>——凯文·凯利</p></blockquote><p><a href="https://finance.sina.com.cn/tech/internet/2022-08-12/doc-imizmscv5896535.shtml">凯文·凯利：在2022年，我们为什么要保持乐观？</a>　</p><h2 id="为何保持乐观"><a href="#为何保持乐观" class="headerlink" title="为何保持乐观"></a>为何保持乐观</h2><h3 id="保持乐观不仅是我们的责任，而且是未来取得成功的关键因素之一。"><a href="#保持乐观不仅是我们的责任，而且是未来取得成功的关键因素之一。" class="headerlink" title="保持乐观不仅是我们的责任，而且是未来取得成功的关键因素之一。"></a>保持乐观不仅是我们的责任，而且是未来取得成功的关键因素之一。</h3><blockquote><p>人们关于未来的设想，大多都是反乌托邦式的。</p></blockquote><p>但我认为这是一种错误的世界观。世界，特别是未来的世界，远比我们想象的要美好，尽管它的确会存在很多问题。</p><p>未来我们要做的大部分事情会是复杂的，困难的；而越是复杂、困难的事情，越是需要预设它会成功。</p><p>电影《星际迷航》中有一个设想，手拿通讯器可以和任何人说话。这启发了许多人开发智能手机，脑中的蓝图让他们乐观地相信这种想象可以成真。从这个意义上讲，正是对未来的乐观愿景激发了人们的灵感。</p><p>乐观主义精神是创造伟大、美好事物所必需的，是成功的关键。这也是为什么我说：乐观主义者塑造未来。</p><p>我谈论的乐观无关性格，无关感受，不是对问题视而不见，也不是消灭一切问题。</p><p>我谈论的也不是反托邦，不是世界毁灭，不是机器人占领世界……反托邦也不太可能成真。人类有很强的适应能力，有坚定的雄心壮志。</p><p>我谈论的是进托邦。进托邦是指，即使能让世界比去年进步1%，如果每年1%的进步不断累加，那就是在创造文明。</p><p>在过去的两百年里，我们取得了稳步进展，人均国民生产总值，出生时预期寿命都呈上升趋势。基于历史数据，基于统计学角度，人类的更大可能性是按照曲线朝可预见的方向继续下去。</p><p>但各种突发新闻让人们很难保持乐观。通过新闻报道，我们看到了战争，疫情，全球性的动荡正在上演。如果好比坏只多出了1%，这差异会被大量的坏消息掩盖。</p><p>进步隐藏在我们的常规视野之外，隐藏在新闻中。我们需要回顾历史，才能认识到这种进步，与真正的趋势保持一致。</p><p>所以再次重申，真正的乐观主义者不是妄想家，而是现实主义者。当我们想象未来时，乐观主义者的做法最合理，他们会想象一个期望中的未来并相信这可以实现，如此才能实现目标。</p><h3 id="文明需要信任和乐观。"><a href="#文明需要信任和乐观。" class="headerlink" title="文明需要信任和乐观。"></a>文明需要信任和乐观。</h3><blockquote><p>文明的延续需要信任和乐观</p></blockquote><p>文明的本质就是信任他人，相信他人是善良的，我们与他人互动。乐观主义者骨子里相信人性本善，而非人性本恶。</p><p>这种互动，从某种程度上讲，不仅涉及到我们周围的人。我们正在建设全球化文明，这需要我们以全新的方式去信任陌生人，去扩大信任圈。面对80亿陌生人要想完成合作，需要坚定的乐观，需要相信好事多于坏事。</p><p>我认为在新技术助力下，未来可以实现100万人合作同一个项目。这些看似不可思议的事情，将会给我们带来极大的震撼和惊喜。</p><h3 id="不应否认问题存在。问题中隐藏着机会和前所未有的解决方案。"><a href="#不应否认问题存在。问题中隐藏着机会和前所未有的解决方案。" class="headerlink" title="不应否认问题存在。问题中隐藏着机会和前所未有的解决方案。"></a>不应否认问题存在。问题中隐藏着机会和前所未有的解决方案。</h3><blockquote><p>问题中蕴藏着机会和前所未有的解决方案</p></blockquote><p>通常，我们并非主动自发地发明创造。存在问题是必不可少的一环，它以一种特殊的方式发挥作用，推动我们前进，推动了发明创造。因此，乐观主义者欢迎问题，而不是否认问题。</p><p>大问题需要大的解决方案，解决方案囊括各种协作，各种资源调配。比如全球性问题的解决，是人类文明进程的一个新阶段，我们需要寻求全球性解决方案。我认为新技术将会帮助我们实现这一点。</p><p>因此，全球气候问题这一事实对我们来说是一个机遇，乐观主义者对此会欣然接受。问题的特征就是无穷无尽、永无休止、层出不穷，这意味着总有进步的空间，这意味着发展的潜力也是无限的。</p><p>所以，我认为乐观是一种责任，我们应该尽可能保持乐观。</p><h2 id="8个当下应该保持乐观的理由"><a href="#8个当下应该保持乐观的理由" class="headerlink" title="8个当下应该保持乐观的理由"></a>8个当下应该保持乐观的理由</h2><p>在2022年，我们有更多应该保持乐观的理由。我想列举8个理由，它们也是8大前沿技术领域，我认为新的商业巨头、企业和企业家将在其中显现。</p><p>很多伟大卓越的产品，20年前还不存在。20年前我们没有智能手机，没有社交媒体，没有特斯拉，没有无人机。它们都是过去20年里的新生事物。那么，接下来的20年将会有更多变化。</p><p>我认为到2042年，我们会迎来一场真正的繁荣，我们应该为之努力。当下就是这场繁荣的开端。</p><p>如果你想先下手为强，抢占突破性技术，这些千载难逢的机遇值得关注。</p><h3 id="1）全球化"><a href="#1）全球化" class="headerlink" title="1）全球化"></a>1）全球化</h3><p>无论受什么样的政治因素影响，无论爆发什么样的战争，无论国家之间如何紧张都不重要，全球化已成既定趋势。世界上再也没有任何一个国家可以独自发展了，我们被联结在一起，这是避无可避的趋势。</p><p>你可以把连接到一同个服务器上的所有手机，看做是一台巨型机器。手机是一个个晶体管，将我们所有人联系在一起，从而带来全球经济一体化。</p><p>每当一项新的发明传播于世界各地，都会将人们联系得更加紧密。放眼世界，无论在非洲、南美还是亚洲，学校教授的课程几乎是相同的，数学、物理、历史、文学、地理……这是新兴的全球文化一体化。</p><p>我们的工作方式也变得更加全球化。很多新兴公司选择线上，或者远程办公，即使同事就坐在彼此的隔壁。</p><p>同时，我们可以获得全球大数据，比如水源储备量，哪里干旱，这些信息都可以通过地球监测卫星收集到。</p><p>我再强调一次，全球化带来的机会绝无仅有，这是一股巨大的力量，影响将延续数十年。</p><h3 id="2）总体城市化"><a href="#2）总体城市化" class="headerlink" title="2）总体城市化"></a>2）总体城市化</h3><p>90%的世界人口将生活在城市地区，这一趋势已经持续了很久，很快就会出现一个数值高峰。大部分人们生活在人口稠密的大城市里，剩下的土地要么空着，要么绿化，要么用于农业，这是全世界范围内的趋势。</p><p>也许到时你不必非要拥有物品。你可能没有车，但智能汽车可以像优步一样接你。如果缺少什么物品，你可以选择送货上门服务，用完后再把它寄回去。我们使用东西，而不是拥有东西，这是从拥有权到使用权的转变的趋势。</p><h3 id="3）绿色能源"><a href="#3）绿色能源" class="headerlink" title="3）绿色能源"></a>3）绿色能源</h3><p>随着城市化进程，就有了第三个趋势，绿色能源。我们正处在这样一个历史时刻，整个地球都将停止碳消耗，通过太阳能、核能或风力发电。这一全球性巨大转变将有助于改善气候。我认为将来50%的交通工具都将是电动的，未来大部分燃油车会切换成电动汽车，一些小型飞机也会使用电能。未来我们将实现全部电气化。</p><h3 id="4）全球互联"><a href="#4）全球互联" class="headerlink" title="4）全球互联"></a>4）全球互联</h3><p>全球互联让我们可以随时随地联系他人，它让大规模协作成为可能。它还带来了虚拟世界、数字孪生世界。在虚拟世界所有事物都有数字版本，我们可以检查它、操纵它，这就是我所说的镜像世界。</p><p>元宇宙就是差不多的概念。通过元宇宙技术，通过虚拟叠加现实，我们可以看到虚拟的鲸鱼在真实的体育馆里跳跃。可以把不在现场的虚拟人物拉到自己身边，感受他们的存在。</p><h3 id="5）人工智能"><a href="#5）人工智能" class="headerlink" title="5）人工智能"></a>5）人工智能</h3><p>无处不在的人工智能是最重要的推力之一。它可以应用于农业、金融业、工业、医疗、设计等等领域。</p><p>例如在AI驱动下，我们革新农耕，AI驱动的拖拉机可以查看并跟踪单支树苗的生长情况，它可以精准地告诉你哪棵需要浇水，哪棵需要肥料，这就是人工智能的力量，也是人力无法实现的力量。</p><p>但我想着重强调的是，人工智能并不是要取代人类，而是会改变你的工作方式。它们会帮你完成很多重复性工作。一些不确定的事情，需要一些创新思维的事情，则交给人脑完成。我们将会和人工智能一起工作，组成团队。共同思考，合作完成任务。</p><p>…..</p><h2 id="预测未来的12个技巧"><a href="#预测未来的12个技巧" class="headerlink" title="预测未来的12个技巧"></a>预测未来的12个技巧</h2><p>在畅想发展趋势时我积累了12个技巧，用来预测一项技术的未来发展方向：</p><h3 id="1）跟随免费的潮流"><a href="#1）跟随免费的潮流" class="headerlink" title="1）跟随免费的潮流"></a>1）跟随免费的潮流</h3><p>找出人们在哪些方面使用不花钱的新技术。看看人们有哪些新爱好。看看哪些领域出现物物交换、共享模式。看看哪里有礼物经济这样真正的激情驱动。你不能靠金钱来探测技术的价值。</p><h3 id="2）注意力浪费"><a href="#2）注意力浪费" class="headerlink" title="2）注意力浪费"></a>2）注意力浪费</h3><p>关注人们如何浪费时间，可以用来预测未来。</p><p>主动浪费：我之前提到过，研究人们把空闲时间浪费在哪非常重要。这件事情可能具有潜在价值，只是目前尚未被发现。</p><p>被动浪费：还要注意人们被迫浪费的时间，和不喜欢做的事情。比如填写表格，或其他效率低下的工作。人们不愿也不想花时间做的事情往往蕴含机遇。</p><h3 id="3）新词"><a href="#3）新词" class="headerlink" title="3）新词"></a>3）新词</h3><p>语言可以被视为判断新兴领域的指标。</p><p>语言空白和新词出现都可能是未来的迹象。如果一个人花费大量时间做了一件难以定义的事，这意味着它先进到尚未有语言能够表述。最终它会被命名，也可能会成为职业。</p><p>看看哪里发明了新词，比如出现大量俚语也很重要，这是另一个迹象，表明重要的事情正在发生。</p><h3 id="4）推算"><a href="#4）推算" class="headerlink" title="4）推算"></a>4）推算</h3><p>预测未来的另一个标准方式是推算。很多人会观测目前为止的趋势，然后假设它会继续下去。有些推算可能是很准确的，它们不像其他事物变化那么快。比如人口统计，某地的人口数量变化。</p><p>但推算可能遇到的最大问题是，它的结果往往是错误的。尽管如此，推算仍会带来有价值的信息，比如它能帮你了解人们期望看到什么，我们称之为官方未来。</p><p>推算最好用来预测全新的东西，图表和曲线能帮你感受速率、增长指数等等。但你必须非常谨慎，因为官方未来未必会发生。某种意义上，官方未来可以告诉你，什么是不可能发生的。</p><h3 id="5）观察空白"><a href="#5）观察空白" class="headerlink" title="5）观察空白"></a>5）观察空白</h3><p>观察两个不相关领域的重叠地带，想象它们融合在一起。比如把农业和人工智能融合在一起，想象人工智能会对农业有何助益。</p><p>你可以做一个游戏，随机选取不同的事物，试想二者之间可能有关联的地方。思考如何连接各领域间的空白地带，然后去空白处寻找未来。这种方式非常有效，你想象到的可能成为现实。</p><h3 id="6）想象不可思议"><a href="#6）想象不可思议" class="headerlink" title="6）想象不可思议"></a>6）想象不可思议</h3><p>想象未来可能发生，但目前不可思议的事情，然后反转假设。对预测未来很有助益。</p><p>假设它真的实现了，会出现什么样的情况？是如何实现的？在实现的过程中发生了什么？这是一种对想象力的锻炼，你不必设想出全部故事，在虚构故事的同时，你可能会萌生新的想法。</p><h3 id="7）场景预设法"><a href="#7）场景预设法" class="headerlink" title="7）场景预设法"></a>7）场景预设法</h3><p>场景预设法是最有效的方法，也是一些商学院正在教授的方法。</p><p>它强调的是，未来是关于可能性的。所以无论未来发生什么，都必须在可能性定律范围内才能发生。所以，当想象未来时，要想象我们认为可能发生的极端情况，未来发生的事情必定不会超出那个可能性范围。</p><p>场景预设法并不是要预测未来，而是设想诸多可能出现的场景，试图填充可能性的空间。这样你就不会对未来发生的事情感到惊讶，因为你已经预先设想过它们。</p><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——好用不过官方库之strings</title>
      <link href="/hypo-Z.github.io/2022/08/08/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-strings/"/>
      <url>/hypo-Z.github.io/2022/08/08/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-strings/</url>
      
        <content type="html"><![CDATA[<h1 id="好用不过官方库之strings"><a href="#好用不过官方库之strings" class="headerlink" title="好用不过官方库之strings"></a>好用不过官方库之strings</h1><p>拒绝重复造轮子，看看那些好用的官方库的包，这里仅仅总结我自己觉得好用的库及应用点，具体包函数可查看<a href="https://studygolang.com/pkgdoc">go官方库</a></p><p>strings包实现了用于操作字符的简单函数。</p><h2 id="strings-判断"><a href="#strings-判断" class="headerlink" title="strings 判断"></a>strings 判断</h2><h3 id="func-EqualFold"><a href="#func-EqualFold" class="headerlink" title="func EqualFold"></a>func EqualFold</h3><p>func EqualFold(s, t string) bool</p><p>判断两个utf-8编码字符串（将unicode大写、小写、标题三种格式字符视为相同）是否相同。不论大小写，只判断字符。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">EqualFold</span><span class="token punctuation">(</span><span class="token string">"Go"</span><span class="token punctuation">,</span> <span class="token string">"go"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="func-HasPrefix"><a href="#func-HasPrefix" class="headerlink" title="func HasPrefix"></a>func HasPrefix</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">HasPrefix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token comment">//字符串长度大于等于前缀且等于字符串前几位等于前缀</span><span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">==</span> prefix<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>判断s是否有前缀字符串prefix。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span><span class="token string">"abcefg"</span><span class="token punctuation">,</span> <span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span><span class="token string">"abcefg"</span><span class="token punctuation">,</span> <span class="token string">"e"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="func-HasSuffix"><a href="#func-HasSuffix" class="headerlink" title="func HasSuffix"></a>func HasSuffix</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">HasSuffix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> suffix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>   <span class="token comment">//字符串长度大于等于后缀且等于字符串后几位等于后缀</span>   <span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">len</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">==</span> suffix<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>判断s是否有后缀字符串suffix。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span><span class="token string">"abcefg"</span><span class="token punctuation">,</span> <span class="token string">"efg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span><span class="token string">"abcefg"</span><span class="token punctuation">,</span> <span class="token string">"e"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="func-Index"><a href="#func-Index" class="headerlink" title="func Index"></a>func Index</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Index</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> sep <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>子串sep在字符串s中第一次出现的位置，不存在则返回-1。</p><h3 id="func-LastIndex"><a href="#func-LastIndex" class="headerlink" title="func LastIndex"></a>func LastIndex</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">LastIndex</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> sep <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>子串sep在字符串s中最后一次出现的位置，不存在则返回-1。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Index</span><span class="token punctuation">(</span><span class="token string">"go gopher"</span><span class="token punctuation">,</span> <span class="token string">"go"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//0</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">LastIndex</span><span class="token punctuation">(</span><span class="token string">"go gopher"</span><span class="token punctuation">,</span> <span class="token string">"go"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//3</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">LastIndex</span><span class="token punctuation">(</span><span class="token string">"go gopher"</span><span class="token punctuation">,</span> <span class="token string">"rodent"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="func-Contains"><a href="#func-Contains" class="headerlink" title="func Contains"></a>func Contains</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Contains</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> substr <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token comment">//即Index函数大于0则包含字串</span><span class="token keyword">return</span> <span class="token function">Index</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> substr<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>判断字符串s是否包含子串substr。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token string">"seafood"</span><span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="strings-处理"><a href="#strings-处理" class="headerlink" title="strings 处理"></a>strings 处理</h2><h3 id="func-ToLower"><a href="#func-ToLower" class="headerlink" title="func ToLower"></a>func ToLower</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ToLower</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回将所有字母都转为对应的小写版本的拷贝。</p><h3 id="func-ToUpper"><a href="#func-ToUpper" class="headerlink" title="func ToUpper"></a>func ToUpper</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ToUpper</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回将所有字母都转为对应的大写版本的拷贝。</p><h3 id="func-Repeat"><a href="#func-Repeat" class="headerlink" title="func Repeat"></a>func Repeat</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Repeat</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">,</span> count <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回count个s串联的字符串。</p><h3 id="func-Replace"><a href="#func-Replace" class="headerlink" title="func Replace"></a>func Replace</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Replace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> old<span class="token punctuation">,</span> <span class="token builtin">new</span> <span class="token builtin">string</span><span class="token punctuation">,</span> n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&lt;0会替换所有old子串。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">ToLower</span><span class="token punctuation">(</span><span class="token string">"Gopher"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//gopher</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span><span class="token string">"Gopher"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//GOPHER</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ba"</span> <span class="token operator">+</span> strings<span class="token punctuation">.</span><span class="token function">Repeat</span><span class="token punctuation">(</span><span class="token string">"na"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//banana</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">"oink oink oink"</span><span class="token punctuation">,</span> <span class="token string">"k"</span><span class="token punctuation">,</span> <span class="token string">"ky"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//oinky oinky oink</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Replace</span><span class="token punctuation">(</span><span class="token string">"oink oink oink"</span><span class="token punctuation">,</span> <span class="token string">"oink"</span><span class="token punctuation">,</span> <span class="token string">"moo"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//moo moo moo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="func-TrimPrefix"><a href="#func-TrimPrefix" class="headerlink" title="func TrimPrefix"></a>func TrimPrefix</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TrimPrefix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> prefix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token function">HasPrefix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>prefix<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">return</span> s<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回去除s可能的前缀prefix的字符串。</p><h3 id="func-TrimSuffix"><a href="#func-TrimSuffix" class="headerlink" title="func TrimSuffix"></a>func TrimSuffix</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">TrimSuffix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> suffix <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token function">HasSuffix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> suffix<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">len</span><span class="token punctuation">(</span>suffix<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">return</span> s<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回去除s可能的后缀suffix的字符串。</p><h2 id="strings-分割"><a href="#strings-分割" class="headerlink" title="strings 分割"></a>strings 分割</h2><h3 id="func-Fields"><a href="#func-Fields" class="headerlink" title="func Fields"></a>func Fields</h3><pre class="line-numbers language-none"><code class="language-none">func Fields(s string) []string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。</p><h3 id="func-Split"><a href="#func-Split" class="headerlink" title="func Split"></a>func Split</h3><pre class="line-numbers language-none"><code class="language-none">func Split(s, sep string) []string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">Fields</span><span class="token punctuation">(</span><span class="token string">"  foo bar  baz   "</span><span class="token punctuation">)</span><span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">"a,b,c"</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">"a man a plan a canal panama"</span><span class="token punctuation">,</span> <span class="token string">"a "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">" xyz "</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%q\n"</span><span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"Bernardo O'Higgins"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//["foo" "bar" "baz"]</span><span class="token comment">//["a" "b" "c"]</span><span class="token comment">//["" "man " "plan " "canal panama"]</span><span class="token comment">//[" " "x" "y" "z" " "]</span><span class="token comment">//[""]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="strings-合并"><a href="#strings-合并" class="headerlink" title="strings 合并"></a>strings 合并</h2><h3 id="func-Join"><a href="#func-Join" class="headerlink" title="func Join"></a>func Join</h3><pre class="line-numbers language-none"><code class="language-none">func Join(a []string, sep string) string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将一系列字符串连接为一个字符串，之间用sep来分隔。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"baz"</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">", "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//foo, bar, baz</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——好用不过官方库之strconv</title>
      <link href="/hypo-Z.github.io/2022/08/05/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-strconv/"/>
      <url>/hypo-Z.github.io/2022/08/05/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-strconv/</url>
      
        <content type="html"><![CDATA[<h1 id="好用不过官方库之strconv"><a href="#好用不过官方库之strconv" class="headerlink" title="好用不过官方库之strconv"></a>好用不过官方库之strconv</h1><p>拒绝重复造轮子，看看那些好用的官方库的包，这里仅仅总结我自己觉得好用的库及应用点，具体包函数可查看<a href="https://studygolang.com/pkgdoc">go官方库</a></p><p>strconv包实现了基本数据类型和其字符串表示的相互转换。底层源码也简单，下面进行分析</p><h2 id="String-And-Bool"><a href="#String-And-Bool" class="headerlink" title="String And Bool"></a>String And Bool</h2><h3 id="func-ParseBool"><a href="#func-ParseBool" class="headerlink" title="func ParseBool"></a>func ParseBool</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">ParseBool</span><span class="token punctuation">(</span>str <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">switch</span> str <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">,</span> <span class="token string">"T"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">,</span> <span class="token string">"TRUE"</span><span class="token punctuation">,</span> <span class="token string">"True"</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token keyword">case</span> <span class="token string">"0"</span><span class="token punctuation">,</span> <span class="token string">"f"</span><span class="token punctuation">,</span> <span class="token string">"F"</span><span class="token punctuation">,</span> <span class="token string">"false"</span><span class="token punctuation">,</span> <span class="token string">"FALSE"</span><span class="token punctuation">,</span> <span class="token string">"False"</span><span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token function">syntaxError</span><span class="token punctuation">(</span><span class="token string">"ParseBool"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p><h3 id="func-FormatBool"><a href="#func-FormatBool" class="headerlink" title="func FormatBool"></a>func FormatBool</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">FormatBool</span><span class="token punctuation">(</span>b <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span><span class="token keyword">if</span> b <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">"true"</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token string">"false"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据b的值返回”true”或”false”。</p><h3 id="func-AppendBool"><a href="#func-AppendBool" class="headerlink" title="func AppendBool"></a>func AppendBool</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">AppendBool</span><span class="token punctuation">(</span>dst <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> b <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token punctuation">{</span><span class="token keyword">if</span> b <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token function">append</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">append</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> <span class="token string">"false"</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价于append(dst, FormatBool(b)…)</p><h2 id="String-And-Integer"><a href="#String-And-Integer" class="headerlink" title="String And Integer"></a>String And Integer</h2><p>大多数会使用到的两个string与整数转换函数和简写函数</p><h3 id="func-ParseInt"><a href="#func-ParseInt" class="headerlink" title="func ParseInt"></a>func ParseInt</h3><pre class="line-numbers language-none"><code class="language-none">func ParseInt(s string, base int, bitSize int) (i int64, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>string to “int”返回字符串表示的整数值，接受正负号。</p><p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p><p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。</p><p>要理解ParseInt函数就要理解ParseUInt函数，实际上就是内部判断是否有符号，再根据无符号数进行转换</p><h3 id="func-Atoi"><a href="#func-Atoi" class="headerlink" title="func Atoi"></a>func Atoi</h3><pre class="line-numbers language-none"><code class="language-none">func Atoi(s string) (i int, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Atoi是ParseInt(s, 10, 0)的简写。</p><h3 id="func-FormatInt"><a href="#func-FormatInt" class="headerlink" title="func FormatInt"></a>func FormatInt</h3><pre class="line-numbers language-none"><code class="language-none">func FormatInt(i int64, base int) string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>“int” to string返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p><h3 id="func-Itoa"><a href="#func-Itoa" class="headerlink" title="func Itoa"></a>func Itoa</h3><pre class="line-numbers language-none"><code class="language-none">func Itoa(i int) string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Itoa是FormatInt(i, 10) 的简写。</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"strconv"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>b<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseBool</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ParseBool="</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>i<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseInt</span><span class="token punctuation">(</span><span class="token string">"-123"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ParseInt="</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>ui<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseInt</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ParseInt="</span><span class="token punctuation">,</span> ui<span class="token punctuation">)</span>f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">ParseFloat</span><span class="token punctuation">(</span><span class="token string">"0.002343241"</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ParseFloat="</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span>is <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">FormatUint</span><span class="token punctuation">(</span><span class="token number">1313</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"FormatUint="</span><span class="token punctuation">,</span> is<span class="token punctuation">)</span>ii<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span><span class="token string">"12313"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Atoi="</span><span class="token punctuation">,</span> ii<span class="token punctuation">)</span>ss <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token number">12312</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Itoa="</span><span class="token punctuation">,</span> ss<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//输出：<span class="token assign-left variable">ParseBool</span><span class="token operator">=</span> <span class="token boolean">true</span><span class="token assign-left variable">ParseInt</span><span class="token operator">=</span> -123<span class="token assign-left variable">ParseInt</span><span class="token operator">=</span> <span class="token number">123</span><span class="token assign-left variable">ParseFloat</span><span class="token operator">=</span> <span class="token number">0.002343241</span><span class="token assign-left variable">FormatUint</span><span class="token operator">=</span> <span class="token number">1313</span><span class="token assign-left variable">Atoi</span><span class="token operator">=</span> <span class="token number">12313</span><span class="token assign-left variable">Itoa</span><span class="token operator">=</span> <span class="token number">12312</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——好用不过官方库之os\signal</title>
      <link href="/hypo-Z.github.io/2022/08/04/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-os-signal/"/>
      <url>/hypo-Z.github.io/2022/08/04/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-os-signal/</url>
      
        <content type="html"><![CDATA[<h1 id="好用不过官方库之os-signal"><a href="#好用不过官方库之os-signal" class="headerlink" title="好用不过官方库之os\signal"></a>好用不过官方库之os\signal</h1><p>拒绝重复造轮子，看看那些好用的官方库的包，这里仅仅总结我自己觉得好用的库及应用点，具体包函数可查看<a href="https://studygolang.com/pkgdoc">go官方库</a></p><p>signal包实现了对输入信号的访问。</p><h3 id="func-Notify"><a href="#func-Notify" class="headerlink" title="func Notify"></a>func Notify</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Notify</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span><span class="token operator">&lt;-</span> os<span class="token punctuation">.</span>Signal<span class="token punctuation">,</span> sig <span class="token operator">...</span>os<span class="token punctuation">.</span>Signal<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Notify函数让signal包将输入信号转发到c。如果没有列出要传递的信号，会将所有输入信号传递到c；否则只传递列出的输入信号。</p><p>signal包不会为了向c发送信息而阻塞（就是说如果发送时c阻塞了，signal包会直接放弃）：调用者应该保证c有足够的缓存空间可以跟上期望的信号频率。对使用单一信号用于通知的通道，缓存为1就足够了。</p><p>可以使用同一通道多次调用Notify：每一次都会扩展该通道接收的信号集。唯一从信号集去除信号的方法是调用Stop。可以使用同一信号和不同通道多次调用Notify：每一个通道都会独立接收到该信号的一个拷贝。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><h5 id="func-Server-Shutdown"><a href="#func-Server-Shutdown" class="headerlink" title="func (*Server) Shutdown"></a>func (*Server) Shutdown</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>srv <span class="token operator">*</span> Server <span class="token punctuation">)</span> <span class="token function">Shutdown</span><span class="token punctuation">(</span>ctx context <span class="token punctuation">.</span> Context <span class="token punctuation">)</span> <span class="token builtin">error</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Shutdown 优雅地关闭服务器而不中断任何活动连接。关闭首先关闭所有打开的侦听器，然后关闭所有空闲连接，然后无限期地等待连接返回空闲状态，然后关闭。如果提供的上下文在关闭完成之前过期，则 Shutdown 返回上下文的错误，否则返回关闭服务器的底层侦听器返回的任何错误。</p><p>当调用 Shutdown 时，Serve、ListenAndServe 和 ListenAndServeTLS 立即返回 ErrServerClosed。确保程序不会退出，而是等待 Shutdown 返回。</p><p>Shutdown 不会尝试关闭或等待被劫持的连接，例如 WebSockets。Shutdown 的调用者应单独通知此类长期连接的关闭并等待它们关闭（如果需要）。有关注册关闭通知功能的方法，请参阅 RegisterOnShutdown。</p><p>一旦在服务器上调用了 Shutdown，它就不能被重用；将来对 Serve 等方法的调用将返回 ErrServerClosed。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"context"</span><span class="token string">"log"</span><span class="token string">"net/http"</span><span class="token string">"os"</span><span class="token string">"os/signal"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    srv <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">{</span>        Addr<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        Handler<span class="token punctuation">:</span> Handler<span class="token punctuation">,</span>    <span class="token punctuation">}</span>idleConnsClosed <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>sigint <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> os<span class="token punctuation">.</span>Signal<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>signal<span class="token punctuation">.</span><span class="token function">Notify</span><span class="token punctuation">(</span>sigint<span class="token punctuation">,</span> os<span class="token punctuation">.</span>Interrupt<span class="token punctuation">)</span><span class="token operator">&lt;-</span>sigint<span class="token comment">// We received an interrupt signal, shut down.</span><span class="token keyword">if</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">Shutdown</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token comment">// Error from closing listeners, or context timeout:</span>log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"HTTP server Shutdown: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>idleConnsClosed<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">:=</span> srv<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> http<span class="token punctuation">.</span>ErrServerClosed <span class="token punctuation">{</span><span class="token comment">// Error starting or closing listener:</span>log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"HTTP server ListenAndServe: %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&lt;-</span>idleConnsClosed<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多例子也可看<a href="https://www.liwenzhou.com/posts/Go/graceful_shutdown/">李文周的博客-优雅地关机或重启</a></p><h3 id="func-Stop"><a href="#func-Stop" class="headerlink" title="func Stop"></a>func Stop</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Stop</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span><span class="token operator">&lt;-</span> os<span class="token punctuation">.</span>Signal<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Stop函数让signal包停止向c转发信号。它会取消之前使用c调用的所有Notify的效果。当Stop返回后，会保证c不再接收到任何信号。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——好用不过官方库之os\exec</title>
      <link href="/hypo-Z.github.io/2022/08/03/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-os-exec/"/>
      <url>/hypo-Z.github.io/2022/08/03/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-os-exec/</url>
      
        <content type="html"><![CDATA[<h1 id="好用不过官方库之os-exec"><a href="#好用不过官方库之os-exec" class="headerlink" title="好用不过官方库之os/exec"></a>好用不过官方库之os/exec</h1><p>拒绝重复造轮子，看看那些好用的官方库的包，这里仅仅总结我自己觉得好用的库及应用点，具体包函数可查看<a href="https://studygolang.com/pkgdoc">go官方库</a></p><p>exec包执行外部命令。它包装了os.StartProcess函数以便更容易的修正输入和输出，使用管道连接I/O，以及作其它的一些调整。</p><h3 id="type-Cmd"><a href="#type-Cmd" class="headerlink" title="type Cmd"></a>type Cmd</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Cmd <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token comment">// Path是将要执行的命令的路径。</span>    <span class="token comment">//</span>    <span class="token comment">// 该字段不能为空，如为相对路径会相对于Dir字段。</span>    Path <span class="token builtin">string</span>    <span class="token comment">// Args保管命令的参数，包括命令名作为第一个参数；如果为空切片或者nil，相当于无参数命令。</span>    <span class="token comment">//</span>    <span class="token comment">// 典型用法下，Path和Args都应被Command函数设定。</span>    Args <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    <span class="token comment">// Env指定进程的环境，如为nil，则是在当前进程的环境下执行。</span>    Env <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>    <span class="token comment">// Dir指定命令的工作目录。如为空字符串，会在调用者的进程当前目录下执行。</span>    Dir <span class="token builtin">string</span>    <span class="token comment">// Stdin指定进程的标准输入，如为nil，进程会从空设备读取（os.DevNull）</span>    Stdin io<span class="token punctuation">.</span>Reader    <span class="token comment">// Stdout和Stderr指定进程的标准输出和标准错误输出。</span>    <span class="token comment">//</span>    <span class="token comment">// 如果任一个为nil，Run方法会将对应的文件描述符关联到空设备（os.DevNull）</span>    <span class="token comment">//</span>    <span class="token comment">// 如果两个字段相同，同一时间最多有一个线程可以写入。</span>    Stdout io<span class="token punctuation">.</span>Writer    Stderr io<span class="token punctuation">.</span>Writer    <span class="token comment">// ExtraFiles指定额外被新进程继承的已打开文件流，不包括标准输入、标准输出、标准错误输出。</span>    <span class="token comment">// 如果本字段非nil，entry i会变成文件描述符3+i。</span>    <span class="token comment">//</span>    <span class="token comment">// BUG: 在OS X 10.6系统中，子进程可能会继承不期望的文件描述符。</span>    <span class="token comment">// http://golang.org/issue/2603</span>    ExtraFiles <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>os<span class="token punctuation">.</span>File    <span class="token comment">// SysProcAttr保管可选的、各操作系统特定的sys执行属性。</span>    <span class="token comment">// Run方法会将它作为os.ProcAttr的Sys字段传递给os.StartProcess函数。</span>    SysProcAttr <span class="token operator">*</span>syscall<span class="token punctuation">.</span>SysProcAttr    <span class="token comment">// Process是底层的，只执行一次的进程。</span>    Process <span class="token operator">*</span>os<span class="token punctuation">.</span>Process    <span class="token comment">// ProcessState包含一个已经存在的进程的信息，只有在调用Wait或Run后才可用。</span>    ProcessState <span class="token operator">*</span>os<span class="token punctuation">.</span>ProcessState    <span class="token comment">// 内含隐藏或非导出字段</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Cmd代表一个正在准备或者在执行中的外部命令。</p><h3 id="func-Command"><a href="#func-Command" class="headerlink" title="func Command"></a>func Command</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Command</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> arg <span class="token operator">...</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>Cmd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数返回一个*Cmd，用于使用给出的参数执行name指定的程序。返回值只设定了Path和Args两个参数。</p><p>如果name不含路径分隔符，将使用LookPath获取完整路径；否则直接使用name。参数arg不应包含命令名。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//重开一个新的端口运行命令</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    com <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"some-command"</span><span class="token punctuation">)</span>cmd <span class="token operator">:=</span> exec<span class="token punctuation">.</span><span class="token function">Command</span><span class="token punctuation">(</span><span class="token string">"/bin/bash"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> com<span class="token punctuation">)</span>cmd<span class="token punctuation">.</span>Stdout <span class="token operator">=</span> os<span class="token punctuation">.</span>Stdout <span class="token comment">//结果输出至控制台</span>cmd<span class="token punctuation">.</span>Stderr <span class="token operator">=</span> os<span class="token punctuation">.</span>Stderr <span class="token comment">//错误输出至控制台</span>err <span class="token operator">=</span> cmd<span class="token punctuation">.</span><span class="token function">Run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"failed to call cmd.Run(): %v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="func-Cmd-Run"><a href="#func-Cmd-Run" class="headerlink" title="func (*Cmd) Run"></a>func (*Cmd) Run</h4><pre class="line-numbers language-none"><code class="language-none">func (c *Cmd) Run() error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Run执行c包含的命令，并阻塞直到完成。</p><p>如果命令成功执行，stdin、stdout、stderr的转交没有问题，并且返回状态码为0，方法的返回值为nil；如果命令没有执行或者执行失败，会返回*ExitError类型的错误；否则返回的error可能是表示I/O问题。</p><h4 id="func-Cmd-Start"><a href="#func-Cmd-Start" class="headerlink" title="func (*Cmd) Start"></a>func (*Cmd) Start</h4><pre class="line-numbers language-none"><code class="language-none">func (c *Cmd) Start() error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Start开始执行c包含的命令，但并不会等待该命令完成即返回。Wait方法会返回命令的返回状态码并在命令返回后释放相关的资源。</p><h4 id="func-Cmd-Wait"><a href="#func-Cmd-Wait" class="headerlink" title="func (*Cmd) Wait"></a>func (*Cmd) Wait</h4><pre class="line-numbers language-none"><code class="language-none">func (c *Cmd) Wait() error<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Wait会阻塞直到该命令执行完成，该命令必须是被Start方法开始执行的。</p><p>如果命令成功执行，stdin、stdout、stderr的转交没有问题，并且返回状态码为0，方法的返回值为nil；如果命令没有执行或者执行失败，会返回*ExitError类型的错误；否则返回的error可能是表示I/O问题。Wait方法会在命令返回后释放相关的资源。</p><h4 id="func-Cmd-Output"><a href="#func-Cmd-Output" class="headerlink" title="func (*Cmd) Output"></a>func (*Cmd) Output</h4><pre class="line-numbers language-none"><code class="language-none">func (c *Cmd) Output() ([]byte, error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行命令并返回标准输出的切片。</p><p>Example</p><pre class="line-numbers language-none"><code class="language-none">out, err := exec.Command("date").Output()if err != nil {    log.Fatal(err)}fmt.Printf("The date is %s\n", out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="func-Cmd-CombinedOutput"><a href="#func-Cmd-CombinedOutput" class="headerlink" title="func (*Cmd) CombinedOutput"></a>func (*Cmd) CombinedOutput</h4><pre class="line-numbers language-none"><code class="language-none">func (c *Cmd) CombinedOutput() ([]byte, error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行命令并返回标准输出和错误输出合并的切片。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——好用不过官方库之os</title>
      <link href="/hypo-Z.github.io/2022/08/02/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-os/"/>
      <url>/hypo-Z.github.io/2022/08/02/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-os/</url>
      
        <content type="html"><![CDATA[<h1 id="好用不过官方库之os"><a href="#好用不过官方库之os" class="headerlink" title="好用不过官方库之os"></a>好用不过官方库之os</h1><p>拒绝重复造轮子，看看那些好用的官方库的包，这里仅仅总结我自己觉得好用的库及应用点，具体包函数可查看<a href="https://studygolang.com/pkgdoc">go官方库</a></p><h2 id="os包"><a href="#os包" class="headerlink" title="os包"></a>os包</h2><p>os包提供了操作系统函数的不依赖平台的接口。设计为Unix风格的，虽然错误处理是go风格的；失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。</p><h3 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h3><pre class="line-numbers language-none"><code class="language-none">const (    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件    O_EXCL   int = syscall.O_EXCL   // 和O_CREATE配合使用，文件必须不存在    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步I/O    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于包装底层系统的参数用于Open函数，不是所有的flag都能在特定系统里使用的。</p><pre class="line-numbers language-none"><code class="language-none">const (    SEEK_SET int = 0 // 相对于文件起始位置seek    SEEK_CUR int = 1 // 相对于文件当前位置seek    SEEK_END int = 2 // 相对于文件结尾位置seek)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指定Seek函数从何处开始搜索（即相对位置）</p><pre class="line-numbers language-none"><code class="language-none">const (    PathSeparator     = '/' // 操作系统指定的路径分隔符    PathListSeparator = ':' // 操作系统指定的表分隔符)const DevNull = "/dev/null"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DevNull是操作系统空设备的名字。在类似Unix的操作系统中，是”/dev/null”；在Windows中，为”NUL”。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre class="line-numbers language-none"><code class="language-none">var (    ErrInvalid    = errors.New("invalid argument")    ErrPermission = errors.New("permission denied")    ErrExist      = errors.New("file already exists")    ErrNotExist   = errors.New("file does not exist"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些可移植的、共有的系统调用错误。</p><pre class="line-numbers language-none"><code class="language-none">var (    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Stdin、Stdout和Stderr是指向标准输入、标准输出、标准错误输出的文件描述符。</p><pre class="line-numbers language-none"><code class="language-none">var Args []string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h3><p>Args保管了命令行参数，第一个元素是程序名。如果你只是简单的想要获取命令行参数，可使用以下函数：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//os.Args demo</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//os.Args是一个[]string</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Args<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> arg <span class="token operator">:=</span> <span class="token keyword">range</span> os<span class="token punctuation">.</span>Args <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"args[%d]=%v\n"</span><span class="token punctuation">,</span> index<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码执行<code>go build -o "args_demo"</code>编译之后，执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./args_demo a b c dargs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>./args_demoargs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>aargs<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span>bargs<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span>cargs<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">=</span>d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//文件信息接口</span><span class="token keyword">type</span> FileInfo <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>    <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span>    <span class="token function">Mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> FileMode    <span class="token function">ModTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> time<span class="token punctuation">.</span>Time    <span class="token function">IsDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>    <span class="token function">Sys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> any<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//func Lstat(name string) (fi FileInfo, err error)</span><span class="token comment">//Lstat返回描述命名文件的FileInfo，如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接的信息，本函数不会试图跳转该链接。若是stat则会跳转。</span>fi<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Lstat</span><span class="token punctuation">(</span><span class="token string">"some-file"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>    <span class="token comment">//fi.Mode()是一个接口</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"permissions: %#o\n"</span><span class="token punctuation">,</span> fi<span class="token punctuation">.</span><span class="token function">Mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Perm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 0400, 0777, etc.</span><span class="token keyword">switch</span> mode <span class="token operator">:=</span> fi<span class="token punctuation">.</span><span class="token function">Mode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">{</span><span class="token keyword">case</span> mode<span class="token punctuation">.</span><span class="token function">IsRegular</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"regular file"</span><span class="token punctuation">)</span><span class="token keyword">case</span> mode<span class="token punctuation">.</span><span class="token function">IsDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"directory"</span><span class="token punctuation">)</span><span class="token keyword">case</span> mode<span class="token operator">&amp;</span>fs<span class="token punctuation">.</span>ModeSymlink <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"symbolic link"</span><span class="token punctuation">)</span><span class="token keyword">case</span> mode<span class="token operator">&amp;</span>fs<span class="token punctuation">.</span>ModeNamedPipe <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"named pipe"</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>fi<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fi<span class="token punctuation">.</span><span class="token function">ModTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fi<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//Getwd返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（因为硬链接），Getwd会返回其中一个。</span>dir<span class="token punctuation">,</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Getwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//Mkdir使用指定的权限和名称创建一个目录。如果出错，会返回*PathError底层类型的错误。</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Mkdir</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>perm<span class="token punctuation">)</span><span class="token comment">//MkdirAll使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回nil，否则返回错误。权限位perm会应用在每一个被本函数创建的目录上。如果path指定了一个已经存在的目录，MkdirAll不做任何操作并返回nil。</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">MkdirAll</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span>perm<span class="token punctuation">)</span><span class="token comment">//Rename修改一个文件的名字，移动一个文件。可能会有一些个操作系统特定的限制。</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Rename</span><span class="token punctuation">(</span>oldpath<span class="token punctuation">,</span>newpath<span class="token punctuation">)</span><span class="token comment">//Remove删除name指定的文件或目录。如果出错，会返回*PathError底层类型的错误。</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token comment">//RemoveAll删除path指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果path指定的对象不存在，RemoveAll会返回nil而不返回错误。</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">RemoveAll</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">type File struct {    // 内含隐藏或非导出字段}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>File代表一个打开的文件对象。</p><pre class="line-numbers language-none"><code class="language-none">func Create(name string) (file *File, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError。</p><pre class="line-numbers language-none"><code class="language-none">func Open(name string) (file *File, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。</p><pre class="line-numbers language-none"><code class="language-none">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。</p><p>更多请看<a href="https://hypo.ltd/2021/11/24/go-yu-yan-ji-chu-wen-jian-cao-zuo/">Go语言基础——文件操作</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——好用不过官方库之fmt</title>
      <link href="/hypo-Z.github.io/2022/08/01/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-fmt/"/>
      <url>/hypo-Z.github.io/2022/08/01/go-yu-yan-ji-chu-hao-yong-bu-guo-guan-fang-ku-zhi-fmt/</url>
      
        <content type="html"><![CDATA[<h1 id="好用不过官方库之fmt"><a href="#好用不过官方库之fmt" class="headerlink" title="好用不过官方库之fmt"></a>好用不过官方库之fmt</h1><p>拒绝重复造轮子，看看那些好用的官方库的包，这里仅仅总结我自己觉得好用的库及应用点，具体包函数可查看<a href="https://studygolang.com/pkgdoc">go官方库</a></p><h2 id="fmt包"><a href="#fmt包" class="headerlink" title="fmt包"></a>fmt包</h2><p>fmt包实现了类似C语言printf和scanf的格式化I/O。格式化动作（’verb’）源自C语言但更简单</p><h3 id="Printf"><a href="#Printf" class="headerlink" title="Printf"></a>Printf</h3><ul><li>通用：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//示例结构体</span><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>Name    <span class="token builtin">string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数打印</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>示例</th><th>输出</th></tr></thead><tbody><tr><td>%v</td><td>值的默认格式表示</td><td>Printf(“%v”,person )</td><td>{hypo}</td></tr><tr><td>%+v</td><td>类似%v，但输出结构体时会添加字段名</td><td>Printf(“%+v”,person )</td><td>{Name:hypo}</td></tr><tr><td>%#v</td><td>值的Go语法表示</td><td>Printf(“#v”,person )</td><td>main.Person={hypo}</td></tr><tr><td>%T</td><td>值的类型的Go语法表示</td><td>Printf(“%T”,person )</td><td>main.Person</td></tr><tr><td>%%</td><td>百分号</td><td>Printf(“%%”)</td><td>%</td></tr></tbody></table><ul><li>可以打印精度和宽度，通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">%f:  //默认宽度，默认精度%9f  //宽度9，默认精度%.2f //默认宽度，精度2%9.2f //宽度9，精度2%9.f  //宽度9，精度0 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>整数进制转换</li></ul><table><thead><tr><th>占位符</th><th>说明</th><th>示例</th><th>输出</th></tr></thead><tbody><tr><td>%b</td><td>二进制表示</td><td>Printf(“%b”,5)</td><td>101</td></tr><tr><td>%c</td><td>该值对应的unicode码值</td><td>Printf(“%c”,0x4E2d)</td><td>中</td></tr><tr><td>%d</td><td>十进制表示</td><td>Printf(“%d”,0x12)</td><td>18</td></tr><tr><td>%o</td><td>八进制表示</td><td>Printf(“%o”,10)</td><td>12</td></tr><tr><td>%q</td><td>单引号围绕的字符字面值，由Go语法安全的转译</td><td>Printf(“%q”,0x4E2d)</td><td>‘中’</td></tr><tr><td>%x</td><td>十六进制表示，字母形式为小写a-f</td><td>Printf(“%x”,13)</td><td>d</td></tr><tr><td>%X</td><td>十六进制表示，字母形式为大写A-F</td><td>Printf(“%X”,13)</td><td>D</td></tr><tr><td>%U</td><td>表示为Unicode格式：U+1234，等价于”U+%04X”</td><td>Printf(“%U”,0x4E2d)</td><td>U+4E2D</td></tr></tbody></table><h3 id="Fprintf"><a href="#Fprintf" class="headerlink" title="Fprintf"></a>Fprintf</h3><p>// 功能同上面三个函数，只不过将转换结果写入到 w 中。<br>func Fprint(w io.Writer, a …interface{}) (n int, err error)<br>func Fprintln(w io.Writer, a …interface{}) (n int, err error)<br>func Fprintf(w io.Writer, format string, a …interface{}) (n int, err error)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//创建文件</span>f<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token string">"./test.txt"</span><span class="token punctuation">)</span><span class="token keyword">defer</span> f<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//定义零值Buffer类型变量b</span><span class="token keyword">var</span> b bytes<span class="token punctuation">.</span>Buffer<span class="token comment">//使用Write方法为写入字符串</span>b<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//写入缓存</span>f<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"你好"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//写入文件</span><span class="token comment">//这个是把一个字符串拼接到Buffer里</span>fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">,</span> <span class="token string">"https://hypo.ltd"</span><span class="token punctuation">)</span><span class="token comment">//这是是把一个字符串拼接并写入文件中</span>fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">,</span> <span class="token string">"https://hypo.ltd"</span><span class="token punctuation">)</span><span class="token comment">//把Buffer里的内容打印到终端控制台</span>b<span class="token punctuation">.</span><span class="token function">WriteTo</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">)</span><span class="token comment">//读出文件内容并打印</span>content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./test.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//官方示例，直接输出至控制台</span><span class="token keyword">const</span> name<span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token string">"Kim"</span><span class="token punctuation">,</span> <span class="token number">22</span>fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token string">" is "</span><span class="token punctuation">,</span> age<span class="token punctuation">,</span> <span class="token string">" years old.\n"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Sprintf"><a href="#Sprintf" class="headerlink" title="Sprintf"></a>Sprintf</h3><p>// 功能同上面三个函数，只不过将转换结果以字符串形式返回。<br>func Sprint(a …interface{}) string<br>func Sprintln(a …interface{}) string<br>func Sprintf(format string, a …interface{}) string</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//可使用此函数标准化输出字符串string</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// go 中格式化字符串并赋值给新串，使用 fmt.Sprintf</span><span class="token comment">// %s 表示字符串</span><span class="token keyword">var</span> stockcode <span class="token operator">=</span> <span class="token string">"000987"</span><span class="token keyword">var</span> enddate <span class="token operator">=</span> <span class="token string">"2020-12-31"</span><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token string">"Code=%s&amp;endDate=%s"</span><span class="token keyword">var</span> target_url <span class="token operator">=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> stockcode<span class="token punctuation">,</span> enddate<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>target_url<span class="token punctuation">)</span><span class="token comment">// 另外一个实例，%d 表示整型</span><span class="token keyword">const</span> name<span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token string">"Kim"</span><span class="token punctuation">,</span> <span class="token number">22</span>s <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s is %d years old.\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>io<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token comment">// 简单起见，忽略一些错误</span><span class="token punctuation">}</span><span class="token comment">//输出</span>Code <span class="token operator">=</span> <span class="token number">000987</span><span class="token operator">&amp;</span>endDate <span class="token operator">=</span> <span class="token number">2020</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span><span class="token number">31</span>Kim is <span class="token number">22</span> years old<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h3><p>// 功能同 Sprintf，只不过结果字符串被包装成了 error 类型。<br>func Errorf(format string, a …interface{}) error</p><h3 id="Scanf"><a href="#Scanf" class="headerlink" title="Scanf"></a>Scanf</h3><p>// 从标准输入扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。</p><p>func Scanf(format string, a …interface{}) (n int, err error)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 当程序执行到fmt.Scanl(&amp;name),程序会停止这里,等待用户输入,多个参数使用空格,并回车</span>fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>Age<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Name:%v,Age:%v \n"</span><span class="token punctuation">,</span> Name<span class="token punctuation">,</span> Age<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Fscanf"><a href="#Fscanf" class="headerlink" title="Fscanf"></a>Fscanf</h3><p>//Fscanf从r扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。</p><p>func Fscanf(r io.Reader, format string, a …interface{}) (n int, err error)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> name <span class="token builtin">string</span><span class="token keyword">var</span> age <span class="token builtin">int</span>of<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./test.txt"</span><span class="token punctuation">)</span> <span class="token comment">//文件里写hypo 18</span><span class="token keyword">defer</span> of<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//也可以根据官方示例学习</span>fmt<span class="token punctuation">.</span><span class="token function">Fscanf</span><span class="token punctuation">(</span>of<span class="token punctuation">,</span> <span class="token string">"%s %d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token comment">//可从文件中读入参数</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"name=%s,age=%d\n"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token comment">//name=hypo,age=18   </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="SScanf"><a href="#SScanf" class="headerlink" title="SScanf"></a>SScanf</h3><p>//Sscanf从字符串str扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。</p><p>func Sscanf(str string, format string, a …interface{}) (n int, err error)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//官方示例</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> name <span class="token builtin">string</span><span class="token keyword">var</span> age <span class="token builtin">int</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sscanf</span><span class="token punctuation">(</span><span class="token string">"Kim is 22 years old"</span><span class="token punctuation">,</span> <span class="token string">"%s is %d years old"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>name<span class="token punctuation">,</span> <span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d: %s, %d\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//输出</span><span class="token number">2</span><span class="token punctuation">:</span> Kim<span class="token punctuation">,</span> <span class="token number">22</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《蛤蟆先生去看心理医生》读后感</title>
      <link href="/hypo-Z.github.io/2022/07/29/38-ha-ma-xian-sheng-qu-kan-xin-li-yi-sheng-du-hou-gan/"/>
      <url>/hypo-Z.github.io/2022/07/29/38-ha-ma-xian-sheng-qu-kan-xin-li-yi-sheng-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="《蛤蟆先生去看心理医生》"><a href="#《蛤蟆先生去看心理医生》" class="headerlink" title="《蛤蟆先生去看心理医生》"></a>《蛤蟆先生去看心理医生》</h1><p><img src="http://rfxlwr9xo.hn-bkt.clouddn.com/hypo.ltd/%E8%9B%A4%E8%9F%86%E5%85%88%E7%94%9F.jpg" alt="书本封面"></p><h2 id="内容简介："><a href="#内容简介：" class="headerlink" title="内容简介："></a>内容简介：</h2><p>蛤蟆先生一向爱笑爱闹，如今却一反常态地郁郁寡欢，他一个人躲在屋里，连起床梳洗的力气都没有。朋友们非常担心他，建议他去做心理咨询。在10次心理咨询中，蛤蟆在咨询师苍鹭的带领下，勇敢地探索了自己的内心世界，也逐渐找回了信心与希望……</p><p>这并不是一本写给孩子看的书，而是一本非常有深度的心理疗愈读物。出版20多年来，已成为英国国民级心理咨询入门书。它基于TA沟通分析心理学的理论，讲述了一个抑郁症病人通过十次心理咨询，终于找回快乐和自信的全过程。在书中，可以看到心理咨询的倾听、共情、沟通技巧，也可以看到一个标准的心理咨询流程的模板。读者犹如亲临现场，体验心理咨询的每一个细节，见证疗愈和改变的发生。</p><p>在这本书里，作者借由蛤蟆和心理咨询师苍鹭的互动，探索了蛤蟆自卑、软弱、爱炫耀的个性与抑郁的情绪究竟来源于何处，让读者看到童年经历对人格的深刻影响，以及如何才能在心理上真正长大成人，独立、自信、充满希望地生活。</p><h2 id="内容摘抄："><a href="#内容摘抄：" class="headerlink" title="内容摘抄："></a>内容摘抄：</h2><ul><li><p>“‘儿童自我状态’，是由我们童年残留的遗迹搭建而成，包含我们小时候体验过的所有情感。你一定知道在刚出生时，我们只具备几种最基本的情感。幼年时，这些基本情感逐渐发展演变成更微妙、更复杂的行为模式，这些行为模式成为自我的核心，融为我们自身的一部分，定义了我们一生的行为。正因为这样，某些特定的情形和场景会激发我们的基本行为模式，让我们自动做出反应，所以我们会和小时候一样去行动和感受。具体的情形和场景因人而异。”</p></li><li><p>在我看来，困惑是学习过程的第一阶段，这说明固有知识的局限开始被打破了。你要直面新的信息，这些新的信息会挑战你现有的观念和行为模式。由此产生的焦虑是让你改变的动力，很可能也会开启你的创造力</p></li><li><p>所谓活得真实，就是真诚地回应当下的需求</p></li></ul><h2 id="推荐语"><a href="#推荐语" class="headerlink" title="推荐语"></a>推荐语</h2><p>如果你的愤怒无处发泄你可以看这本书，如果你心有困惑你可以看这本书，如果你对你的童年生活不满意你可以看这本书。</p><p>心情不好时看看这本书，它会戳中你、治愈你、改变你，给你力量</p><p>这本书可以给你带来一些思考，对于心理也会有帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
            <tag> 好书推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界向内走还是向外走</title>
      <link href="/hypo-Z.github.io/2022/07/27/37-shi-jie-xiang-nei-zou-huan-shi-xiang-wai-zou/"/>
      <url>/hypo-Z.github.io/2022/07/27/37-shi-jie-xiang-nei-zou-huan-shi-xiang-wai-zou/</url>
      
        <content type="html"><![CDATA[<h1 id="世界向内走还是向外走"><a href="#世界向内走还是向外走" class="headerlink" title="世界向内走还是向外走"></a>世界向内走还是向外走</h1><p>我们生活在一个意义建构的世界（Man lives in a world of meaning）——<a href="https://baike.baidu.com/item/%E4%B9%94%E6%B2%BB%C2%B7%E8%B5%AB%E4%BC%AF%E7%89%B9%C2%B7%E7%B1%B3%E5%BE%B7/6474725">G. H.米德</a></p><h2 id="人类探索太空史"><a href="#人类探索太空史" class="headerlink" title="人类探索太空史"></a>人类探索太空史</h2><p>——来自<a href="https://baike.baidu.com/item/%E4%BA%BA%E7%B1%BB%E6%8E%A2%E7%B4%A2%E5%A4%AA%E7%A9%BA%E5%8F%B2/9852857">百度百科，详情可查看</a></p><ul><li><p>二战后，美国和<a href="https://baike.baidu.com/item/%E5%89%8D%E8%8B%8F%E8%81%94">前苏联</a>在德国的研究基础上继续从事火箭及其他航天技术的研究工作。到20世纪50年代，美国和前苏联研制的各种类型导弹武器相继问世，形成了<a href="https://baike.baidu.com/item/%E5%AF%BC%E5%BC%B9%E6%AD%A6%E5%99%A8%E7%B3%BB%E7%BB%9F">导弹武器系统</a>，同时也积累了研制运载火箭的经验，建立了与之配套且初具规模的工业设施。</p></li><li><p>1957年10月4日，前苏联采用改装的P－7<a href="https://baike.baidu.com/item/%E6%B4%B2%E9%99%85%E5%AF%BC%E5%BC%B9/552486">洲际导弹</a>把世界上第一颗<a href="https://baike.baidu.com/item/%E4%BA%BA%E9%80%A0%E5%9C%B0%E7%90%83%E5%8D%AB%E6%98%9F">人造地球卫星</a>送入太空。 　人类要实现上天的愿望必须满足三个条件：第一要有强大的运载工具，第二要有乘坐宇航员的先进的航天器，第三必须弄清高空环境和飞行环境对人体的影响，并找到防护措施。到20世纪50年代，美国和前苏联在这几方面都取得了长足的进步，为<a href="https://baike.baidu.com/item/%E8%BD%BD%E4%BA%BA%E8%88%AA%E5%A4%A9/886728">载人航天</a>奠定了坚实的技术基础。</p></li><li><p>1961年4月12日，前苏联首先将载有世界上第一名宇航员<a href="https://baike.baidu.com/item/%E5%B0%A4%E9%87%8C%C2%B7%E5%8A%A0%E5%8A%A0%E6%9E%97">尤里·加加林</a>的“东方1号”宇宙飞船送入离地面181～327千米的空间轨道。尤里·加加林的航天飞行，实现了人类梦寐以求的飞天愿望，开创了载人航天的新时代。</p></li><li><p>美国也紧随其后，1969年7月20日，“<a href="https://baike.baidu.com/item/%E9%98%BF%E6%B3%A2%E7%BD%97/8328201">阿波罗</a>11号”<a href="https://baike.baidu.com/item/%E7%99%BB%E6%9C%88%E8%88%B1/6805720">登月舱</a>在月球“静海”区安全着陆，美国宇航员N·A·阿姆斯特朗和E·E·奥尔德林登上月球，实现了人类几千年的梦想，使嫦娥奔月的神话变成了现实，人类探索太空的成就达到了新的高峰。</p></li><li><p>自第一颗人造卫星成功发射后，在短短不到半个世纪的时间里，人类对太空的探索已取得了飞速发展。从人造卫星的应用到星际探索，从月球探险到火星、土星勘探计划再到彗星“<a href="https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E6%92%9E%E5%87%BB/535368">深度撞击</a>”。截至2004年底，世界各国共进行了航天发射4000多次，把5500多个各类航天器送入太空，目前，仍在轨道上或宇宙中运行的航天器大约有1300多个。迄今为止，人类已经研制成功了<a href="https://baike.baidu.com/item/%E8%BD%BD%E4%BA%BA%E9%A3%9E%E8%88%B9/377970">载人飞船</a>、空间站、航天飞机等三种不同的<a href="https://baike.baidu.com/item/%E8%BD%BD%E4%BA%BA%E8%88%AA%E5%A4%A9%E5%99%A8/10130846">载人航天器</a>，将500多人送入太空，有12人登上月球，并已开始建造永久性载人空间站。</p></li><li><p><strong>星链</strong>（英语：Starlink）是太空服务公司<a href="https://zh.m.wikipedia.org/wiki/SpaceX">SpaceX</a>计划推出的一项透过<a href="https://zh.m.wikipedia.org/wiki/%E8%BF%91%E5%9C%B0%E8%BD%A8%E9%81%93">近地轨道</a><a href="https://zh.m.wikipedia.org/wiki/%E5%8D%AB%E6%98%9F">卫星</a>群，提供覆盖全球的高速<a href="https://zh.m.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">互联网</a>接入服务。2015年，SpaceX首席执行官<a href="https://zh.m.wikipedia.org/wiki/%E4%BC%8A%E9%9A%86%C2%B7%E9%A9%AC%E6%96%AF%E5%85%8B">伊隆·马斯克</a>在<a href="https://zh.m.wikipedia.org/wiki/%E8%A5%BF%E9%9B%85%E5%9B%BE">西雅图</a>宣布推出一项太空高速互联网计划：星链计划。借由远远超过传统卫星互联网的性能，以及不受地面基础设施限制的全球网路，星链可以为网路服务不可靠、费用昂贵或完全没有网络的位置提供高速互联网服务，另外也有可能结束当今世界存在的<a href="https://zh.m.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B0%81%E9%94%81">网络封锁</a>。旨在为世界上的每一个人提供高速互联网服务。星链计划的宗旨是开发出“全球卫星互联网系统”，并能运用在例如火星等环境上，在太阳系内部署通信基础建设。</p></li><li><p>今年将完成中国空间站在轨建造，共计划实施6次飞行任务——5月发射天舟四号货运飞船；6月发射神舟十四号载人飞船，神舟十四号载人飞船乘组也是由三名航天员组成，他们将在轨驻留6个月时间；7月发射空间站问天实验舱，10月发射空间站梦天实验舱。空间站的三个舱段将形成“T”字基本构型，完成中国空间站的在轨建造，之后还将实施天舟五号货运飞船和神舟十五号载人飞船发射任务。其中，神舟十五号载人飞船飞行乘组也是由三名航天员组成，这三名航天员将在轨和神舟十四号的航天员完成轮换以后，工作和生活6个月</p></li></ul><p>以上这些都是人类对于现实世界的探索，每一步都是新的成就，是对地球之外领域的探索。</p><p>而在此期间人类向内探索的脚步也不停止，我想说的即是互联网</p><h2 id="互联网发展史"><a href="#互联网发展史" class="headerlink" title="互联网发展史"></a>互联网发展史</h2><p>——来自<a href="https://www.secrss.com/articles/11938">安全内参，详情可查看</a></p><p><strong>第一阶段</strong>，20世纪60年代的基础技术阶段，以计算机广域网和数字通信技术的成熟为标志，尤其是包交换技术的突破，为互联网前身——ARPA网的诞生奠定了基础；</p><p><strong>第二阶段</strong>，20世纪70年代的基础协议阶段，最大的突破就是TCP/IP的诞生，使得不同计算机和不同网络之间互联成为大势所趋；</p><p><strong>第三阶段</strong>，20世纪80年代是基础应用阶段，全球各种网络如雨后春笋一般冒出，并且通过电子邮件、BBS和USEnet等应用的普及，促成了互联网在全球学术界的联网，TCP/IP和NSFNET成为协议大战和网络大战的胜出者。</p><p>上述三个阶段，包含史前阶段，是互联网商业化之前孕育、积累和完善的30年。没有风险投资，没有一夜暴富，互联网故事大多平淡乏味，缺乏轰动效应。然而正是这长达30年的“寂寞期”，积蓄了互联网厚积薄发的巨大能量。</p><p><strong>第四阶段</strong>，20世纪90年代的Web 1.0阶段，主要是万维网（WWW）的诞生和商业化浪潮，推动着互联网走向大众，以浏览器、门户和电子商务等应用开启了互联网发展的第一次投资热潮；</p><p><strong>第五阶段</strong>，是21世纪头10年的Web 2.0阶段，主要是博客、社交媒体等兴起，网民成为内容的生产主体；</p><p><strong>第六阶段</strong>，是21世纪10年代的移动互联阶段，随着智能手机全面崛起，移动互联网成为全球互联网新一轮扩散的主力军，更加深入地改变着人们的日常生活；</p><p><strong>第七阶段</strong>，就是21世纪20年代开启的智能物联阶段，随着5G应用的展开，全球将进入万物互联新阶段。</p><p>显然，以10年为一个阶段进行年代划分也不尽准确，肯定会出现某些错位，甚而有固化和武断之嫌。比如作为Web 2.0代表的博客在2001年“9·11事件”中已开始崭露头角，但真正体现大众公认的内涵则要到2004年，从2000年开始计算显然过早。再如智能物联时代，其实从2016年李世石大战阿尔法狗事件开始，人工智能就已成为全球热点；虽然人们将2019年称为5G商用元年，但真正奠定智能物联时代基础的5G要形成大规模商用，恐怕还要等到2020年之后。不过，上述偏差并不影响对全球互联网50年历史整体的分析和研判，这种新的阶段划分将使得整个互联网历史更具概括性和条理性，具有比较清晰的体系。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote><p>现在和未来人类的发展即是对虚拟世界和现实世界的探索，那哪个对人类更重要呢？</p></blockquote><h3 id="太空探索的未来"><a href="#太空探索的未来" class="headerlink" title="太空探索的未来"></a>太空探索的未来</h3><p>说起太空探索，对于我们普通人来说都隔得太远，我们就只能在电视或者网络空间上看到中国的太空建设和探索，但近两年中国的航天事业越来越引起世界的目光。</p><p>去年，中国将“天宫”空间站的第一个模块送入轨道。中国计划在今年年底前增加更多的模块，比如“梦天”实验舱。</p><p>明年，它将发射一个名为“巡天”的太空望远镜。它将飞近空间站，并与空间站对接，进行维修和加油。</p><p>“天宫”空间站将拥有自己的动力、推进、生命保障系统和生活区。</p><p>中国是继苏联（现在为俄罗斯）和美国后，历史上第三个将两名太空人送入太空并建造空间站的国家。</p><p>中国对“天宫一号”抱有远大抱负，希望它能取代定于2031年停止运作的国际空间站（ISS）。</p><p>中国太空人被排除在国际空间站之外，因为美国法律禁止美国国家航空航天局与中国共享数据。</p><h4 id="为什么中国要进入太空？"><a href="#为什么中国要进入太空？" class="headerlink" title="为什么中国要进入太空？"></a>为什么中国要进入太空？</h4><p>中国热衷于发展其卫星技术，为了电信、空中交通管理、天气预报和导航等等。但它的许多卫星也有军事用途。他们可以帮助中国监视敌对势力，并引导远程导弹。</p><p>朴茨茅斯大学太空项目经理卢辛达 · 金（Lucinda King）说，中国不仅仅关注高调的太空任务：“他们在太空的各个方面都很高产。他们有政治动机和资源来投资他们计划中的项目。”中国登月任务部分动机是从月球表面提取稀土金属，如锂。</p><p>但是，伦敦大学伦敦太空政策与法律研究所所长萨伊德 · 莫斯特沙尔（Sa’id Mosteshar）教授表示，这不能抵消中国多次向月球发射采矿任务的开销。相反，他表示，中国的太空计划更多是为了给世界其他国家留下深刻印象，“这是权力的投射，也是技术进步的证明”。</p><h4 id="其他国家在做什么？"><a href="#其他国家在做什么？" class="headerlink" title="其他国家在做什么？"></a>其他国家在做什么？</h4><p>中国在太空领域影响力不断扩大，其他一些国家也在努力实现登月目标。</p><p>美国国家航空航天局计划从2025年开始，与来自美国和其他国家的宇航员一起重返月球，并已经在肯尼迪航天中心空间站推出了新的巨型SLS火箭。</p><p>日本、韩国、俄罗斯、印度和阿拉伯联合酋长国也在进行各自的登月任务。</p><p>印度已经进行了第二个重要的登月任务，并希望在2030年拥有自己的空间站。</p><p>与此同时，正在与美国宇航局合作进行月球任务的欧洲航天局，也计划建立一个月球卫星网络，让宇航员与地球的通信更加容易。</p><h3 id="虚拟世界的未来"><a href="#虚拟世界的未来" class="headerlink" title="虚拟世界的未来"></a>虚拟世界的未来</h3><h4 id="元宇宙与Web3-0"><a href="#元宇宙与Web3-0" class="headerlink" title="元宇宙与Web3.0"></a>元宇宙与Web3.0</h4><blockquote><p>Web3.0是技术发展方向的未来，元宇宙是应用场景和生活方式的未来，二者之间相辅相成。</p></blockquote><p>Web1.0为“可读”（read），Web2.0为“可读+可写”（read+write），而Web3.0将是“可读+可写+拥有”（read+write+own）。</p><p>具体来说，在Web1.0和2.0时代用户虽然可以免费使用服务，且在早期引流时还会得到优惠券和消费红包类的福利，但用户数据会被互联网平台占有，用户作为生态的重要参与者和贡献者无法从中获益。</p><p>到了Web3.0时代，用户将享有真正的数据自主权。个人信息将成为用户自主掌控的数据资产。用户可以在数据流转和交易中真正获益，使自己的数据不再是互联网平台的免费资源：</p><blockquote><p>Web1.0是过去，解决用户浏览内容的问题，Web2.0是现在，解决用户创造内容的问题，Web3.0是未来，将解决用户信息安全和内容所有权的问题。</p></blockquote><p>展望未来，Web3.0不仅是智能互联网，而且是立体全息互联网。</p><blockquote><p>Web3.0需要包括沉浸式AR/VR终端、脑机接口、触觉手套、触觉紧身衣等先进设备，以及虚拟化身（Avatar）、动作捕捉、手势识别、空间感知、数字孪生等相关技术。</p></blockquote><h4 id="关系：元宇宙是上层建筑，Web3-0是基础设施"><a href="#关系：元宇宙是上层建筑，Web3-0是基础设施" class="headerlink" title="关系：元宇宙是上层建筑，Web3.0是基础设施"></a>关系：元宇宙是上层建筑，Web3.0是基础设施</h4><p>那么，元宇宙与Web 3.0究竟有何关系呢？</p><p>元宇宙和Web3.0均代表互联网的未来，Web3.0是技术发展方向的未来，元宇宙是应用场景和生活方式的未来，二者之间是相辅相成、一体两面的依存关系。</p><p>具体来讲：</p><blockquote><ul><li>Web3.0技术方向包含了区块链、人工智能、大数据等技术创新和DAO（DecentralizedAutonomousOrganization即用户共识社区）网络组织模式创新。</li><li>在元宇宙中，AR/VR解决元宇宙前端的技术需要，而Web3.0在后端提供强有力的技术支撑。</li></ul></blockquote><h4 id="各个国家的态度？"><a href="#各个国家的态度？" class="headerlink" title="各个国家的态度？"></a>各个国家的态度？</h4><p>美国：除了全球三大电商巨头“齐聚”Web3外，社交巨头Meta、支付巨头Mastercard等“重磅玩家”也都放出大招。Meta创始人扎克伯格宣布扩大NFT的测试范围；支付巨头Mastercard则在本月一口气和7家Web3公司展开合作，将支付网络渗透进这一新的赛道，支付巨头美国运通也表示看好加密支付的长期价值。原Facebook公司直接改名为Meta（即元世界），all in ARVR。</p><p>日本：国内掀起了Web3学习的热潮，甚至日本首相计划从政治角度推动Web3的发展。日本首相岸田文雄在5月26日发表声明：“Web3时代的到来可能会引领（日本）经济增长，我们相信，整合元宇宙和NFT等新的数字服务将为日本带来经济增长。随着我们进入Web3时代，我强烈认为我们必须从政治角度坚决推动这种环境。”</p><p>而邻国印度，也在抢夺Web3亚洲主导者的地位。由于人口比肩中国、程序员数量比肩中国、本土互联网生态趋向成熟、印度国内独角兽数量大爆发等原因，红杉资本等巨头也在今年将资金（20亿美元）向印度大幅度倾斜，而Crypto和Web3是红杉资本十分看重的一个赛道。</p><p>中国：腾讯和字节相继投入到元宇宙赛道中，腾讯在社交、游戏和影业直播等领域的多年布局，使其形成了相对完整的版图。字节跳动想要凭借自身的社交、内容、全球化优势，将 Tiktok、飞书（Lark）应用到下一代颠覆手机的终端设备中，去构建属于自己的“元宇宙”。不仅腾讯和字节，中国各大互联网公司和软硬件公司都在积极布局相关产品。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自此，我们大概了解到太空探索和虚拟世界探索的历史以及未来世界的走向。</p><p>可以看出太空探索是一个需要耗费大量人力物力且必须以国家意志为导向才能完成的宏大项目。对于太空的探索：一是可以展示出一个国家的技术实力、二也是为了人类对外太空航行和星球勘探积累经验。</p><p>而互联网发展则就是由几家互联网巨头公司就可以对其进行生态建设，但其对人类的生活习惯的影响是极其深远的。</p><p>对于这两个世界的探索，我认为都同样重要。太空探索是人类对于生命科学的探索，而虚拟世界探索是人类对于经济科学的探索</p><p>探索的本质即是寻求答案，人类也会在寻求答案的路上不停前进。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm一天一道算法</title>
      <link href="/hypo-Z.github.io/2022/07/08/algorithm-yi-tian-yi-dao-suan-fa/"/>
      <url>/hypo-Z.github.io/2022/07/08/algorithm-yi-tian-yi-dao-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="一天一道算法题"><a href="#一天一道算法题" class="headerlink" title="一天一道算法题"></a>一天一道算法题</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//解法一</span><span class="token keyword">func</span> <span class="token function">twoSum1</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> target <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token comment">//遍历所有的加法组合，直到找到符合相加得到目标数的两个数,并且两数不是同一个数</span>   l<span class="token operator">:=</span><span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span>   <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>      <span class="token keyword">for</span> j<span class="token operator">:=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>l<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">{</span>         <span class="token keyword">if</span> target<span class="token operator">==</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">!=</span>j<span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>i<span class="token punctuation">,</span>j<span class="token punctuation">}</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token comment">//这种方法比较笨，且较慢，时间复杂度O(n^2)</span><span class="token comment">//解法二</span><span class="token keyword">func</span> <span class="token function">twoSum2</span><span class="token punctuation">(</span>nums <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> target <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>   <span class="token comment">//创建一个map存储遍历后的数组对，键值对个数为数组长度</span>   num2index <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//遍历数组</span>   <span class="token keyword">for</span> i<span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">{</span>      <span class="token comment">//核心是用目标值减去循环遍历出来的值，判断是否是数组内的值</span>      pair <span class="token operator">:=</span> target <span class="token operator">-</span> num      <span class="token comment">//</span>      <span class="token keyword">if</span> j<span class="token punctuation">,</span> ok <span class="token operator">:=</span> num2index<span class="token punctuation">[</span>pair<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> j <span class="token punctuation">{</span>         <span class="token comment">// 注意返回值顺序，向后遍历 nums，所以 i 在 j 后</span>         <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>j<span class="token punctuation">,</span> i<span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token comment">//循环一边就存入map</span>      <span class="token comment">//第一遍map[2]=0,没有相同</span>      <span class="token comment">//第二遍map[7]=1,没有相同且存在pair := target - num</span>      num2index<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> i   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token comment">//这种方法虽牺牲空间但速度快，时间复杂度O(log2n)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-翻转字符串"><a href="#2-翻转字符串" class="headerlink" title="2.翻转字符串"></a>2.翻转字符串</h2><p>给定一串字符串，将字符串进行翻转</p><p>示例1：输入”abc”,输出”cba”;</p><p>示例2：输入”1313adfasf”,输出”fsada3131”;</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//解法</span><span class="token keyword">func</span> <span class="token function">Reverse</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token comment">//[]rune符文是int32的别名，在所有方面都与int32等效。按照惯例，它用于区分字符值和整数值。</span>   a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment">//从两端开始进行转变位置</span>   <span class="token keyword">for</span> i<span class="token punctuation">,</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> i<span class="token punctuation">,</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>       <span class="token comment">//go语言内部会构造一个虚拟变量</span>      a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-回文判断"><a href="#3-回文判断" class="headerlink" title="3.回文判断"></a>3.回文判断</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>例如，121 是回文，而 123 不是。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//我的解法</span><span class="token keyword">func</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token comment">//负数不是回文</span>   <span class="token keyword">if</span> x<span class="token operator">&lt;</span><span class="token number">0</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span>   <span class="token punctuation">}</span>    <span class="token comment">//提示：转为字符串方便</span>   a<span class="token operator">:=</span>strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>   s<span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>   l<span class="token operator">:=</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token comment">//由翻转想到的灵感，不是最好</span>   <span class="token keyword">for</span> i<span class="token punctuation">,</span>j<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">,</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">;</span>i<span class="token punctuation">,</span>j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">{</span>      <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token boolean">false</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-最大容器问题"><a href="#4-最大容器问题" class="headerlink" title="4.最大容器问题"></a>4.最大容器问题</h2><p>给定一个长度为 n 的整数数组height。有n条垂线，第 i 条线的两个端点是(i, 0)和(i, height[i])。<br>找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。<br>返回容器可以储存的最大水量。</p><p>说明：你不能倾斜容器。</p><p>示例 1：</p><p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49<br>解释：垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。<br>示例 2：</p><p>输入：height = [1,1]<br>输出：1</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 两条线段之间的面积受限与最短的线段，线段间距越长，面积越大</span><span class="token comment">// 使用 2 个指针指向首部和尾部，将短指针向长指针方向移动，看能不能找到更长的线，使面积更大</span><span class="token comment">// 依据：向长线方向每次移动 1 格，虽然宽度-1，但是(高度变高)*(宽度-1) &gt;= 高度*宽度</span><span class="token comment">// 双指针法</span><span class="token keyword">func</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>height <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>maxarea<span class="token operator">:=</span><span class="token number">0</span><span class="token comment">//分别取左右两个指针</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>j<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token function">len</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>j <span class="token punctuation">{</span><span class="token comment">//面积等于短指针高度*两个指针距离</span>maxarea<span class="token operator">=</span><span class="token function">max</span><span class="token punctuation">(</span>maxarea<span class="token punctuation">,</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//如果右指针更高，则左指针向右一格</span><span class="token keyword">if</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>i<span class="token operator">++</span><span class="token comment">//反之，右指针向左一格</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> maxarea<span class="token punctuation">}</span><span class="token comment">//两数最小</span><span class="token keyword">func</span> <span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span><span class="token keyword">if</span> a<span class="token operator">&gt;</span>b <span class="token punctuation">{</span><span class="token keyword">return</span> b<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//两数最大</span><span class="token keyword">func</span> <span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">if</span> a<span class="token operator">&gt;</span>b <span class="token punctuation">{</span><span class="token keyword">return</span> a<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span><span class="token keyword">return</span> b<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-最长前缀问题"><a href="#5-最长前缀问题" class="headerlink" title="5.最长前缀问题"></a>5.最长前缀问题</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串””。</p><p>示例 1：</p><p>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”<br>示例 2：</p><p>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"strings"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//test1</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"flower"</span><span class="token punctuation">,</span> <span class="token string">"fly"</span><span class="token punctuation">,</span> <span class="token string">"flight"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// fl</span><span class="token comment">//test2</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token string">"racecar"</span><span class="token punctuation">,</span> <span class="token string">"car"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// ""</span><span class="token punctuation">}</span><span class="token comment">// 维护一个前缀库，不断往后遍历，判断前缀逐步剪短前缀库的大小</span><span class="token keyword">func</span> <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>strs <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">""</span>    <span class="token punctuation">}</span>    s1 <span class="token operator">:=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    prefixes <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//将第一个字符串遍历为一个字符串前缀库</span><span class="token comment">//test1：[]prefixes{"f","fl","flo","flow","flowe","flower"}</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> s1 <span class="token punctuation">{</span>        prefixes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s1<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token comment">//遍历输入的字符串数组</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> s <span class="token operator">:=</span> <span class="token keyword">range</span> strs <span class="token punctuation">{</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> pre <span class="token operator">:=</span> <span class="token keyword">range</span> prefixes <span class="token punctuation">{</span><span class="token comment">//HasPrefix判断字符串s是否以pre前缀开头。</span>            <span class="token keyword">if</span> <span class="token operator">!</span>strings<span class="token punctuation">.</span><span class="token function">HasPrefix</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> pre<span class="token punctuation">)</span> <span class="token punctuation">{</span>                prefixes <span class="token operator">=</span> prefixes<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span>                <span class="token keyword">break</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>prefixes<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">//返回最后一个字符串即最长前缀</span>        <span class="token keyword">return</span> prefixes<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>prefixes<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Pandoc把Markdown转为PDF文件</title>
      <link href="/hypo-Z.github.io/2022/07/06/36-shi-yong-pandoc-ba-markdown-zhuan-wei-pdf-wen-jian/"/>
      <url>/hypo-Z.github.io/2022/07/06/36-shi-yong-pandoc-ba-markdown-zhuan-wei-pdf-wen-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Pandoc-把-Markdown-转为-PDF-文件"><a href="#使用-Pandoc-把-Markdown-转为-PDF-文件" class="headerlink" title="使用 Pandoc 把 Markdown 转为 PDF 文件"></a>使用 Pandoc 把 Markdown 转为 PDF 文件</h1><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li>首先当然是 Pandoc，下载<a href="https://github.com/jgm/pandoc/releases">最新的安装包</a>，安装完以后，记得把 Pandoc 安装目录加入系统 <code>PATH</code> 变量。</li><li>TeX 发行版。请确保你的系统已经安装了 TeX 软件，你可以使用 <a href="https://www.tug.org/texlive/">TeX Live</a> 或者 <a href="https://miktex.org/">MiKTeX</a>，安装完成之后可能需要设置 <code>PATH</code>，推荐安装 TeX Live。</li><li>一个强大的文本编辑器</li></ul><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><a href="https://pandoc.org/">Pandoc</a> 可以很方便地对不同 Markup 语言的文件进行格式转换，因此被誉为格式转换的「瑞士军刀」。使用 Pandoc 把 Markdown 文件转为 PDF 文件，实际上包含两个步骤：</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ul><li>第一步， Markdown 文件被转为 LaTeX 源文件。</li><li>第二步，调用系统的 <code>pdflatex</code>, <code>xelatex</code> 或者其他 TeX 命令，将 <code>.tex</code> 文件转换为最终的 PDF 文件 (见上图)。</li></ul><p>由于我的文档是中文，并且包含引用，表格等比较复杂的格式，在文件转换过程中遇到了一些问题，下面介绍具体解决办法。</p><h3 id="如何处理中文"><a href="#如何处理中文" class="headerlink" title="如何处理中文"></a>如何处理中文</h3><p>Pandoc 默认使用的 pdflatex 命令无法处理 Unicode 字符，如果要把包含中文的Markdown 文件转为 PDF，在生成 PDF 的过程中会报错。我们需要使用 xelatex 来处理中文，并且需要使用 CJKmainfont 选项指定支持中文的字体。 在 Windows 系统中，对于 Pandoc 2.0 版本以上，可以使用以下的命令生成 PDF 文件：</p><pre class="line-numbers language-none"><code class="language-none">pandoc --pdf-engine=xelatex -V CJKmainfont="Noto Sans Mono CJK SC:style=Regular" test.md -o test.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>CJKmainfont 后面跟的是支持中文的字体名称。那么如何找到支持中文的字体呢？ 首先，你需要知道你所使用的语言的 language code, 例如，中文(即Chinese)的 language code 是 zh。 然后使用 fc-list 命令查看支持中文的字体(对于 Windows 系统，fc-list 命令在安装 TeX Live 完整版以后可以使用, Unix 系统一般会预装这个程序)：</p><pre class="line-numbers language-none"><code class="language-none">fc-list :lang=zh # zh 是中文的 「language code」<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Linux 系统上，找出支持中文的字体的方式与 Windows 系统是一样的。</p><h3 id="添加文档标题，作者，更新时间信息"><a href="#添加文档标题，作者，更新时间信息" class="headerlink" title="添加文档标题，作者，更新时间信息"></a>添加文档标题，作者，更新时间信息</h3><p>Pandoc 支持 YAML 格式的 header，通过 header 可以指定文章的标题，作者，更新时间等信息，一个示例 header 如下：</p><hr><p>data:”2022.7.7”<br>title: “My demo title”<br>author: “sfsf”</p><hr><h3 id="给-block-code-加上-highlight"><a href="#给-block-code-加上-highlight" class="headerlink" title="给 block code 加上 highlight"></a>给 block code 加上 highlight</h3><p>Pandoc 支持给 block code 里面的代码加上背景高亮，并提供了不同的高亮主题，支持非常多的语言。要列出 Pandoc 提供的高亮方案，使用下面命令，</p><pre class="line-numbers language-none"><code class="language-none">pandoc --list-highlight-styles<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要列出所有支持的语言，使用下面命令，</p><pre class="line-numbers language-none"><code class="language-none">pandoc --list-highlight-languages<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要使用语法高亮，Markdown 文件中的 block code 必须指定语言，同时在命令行使用–highlight-style 选项，例如：</p><pre class="line-numbers language-none"><code class="language-none">pandoc --pdf-engine=xelatex --highlight-style zenburn test.md -o test.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令，使用了 zenburn 主题, 另外，也推荐使用 tango, zenburn 或者breezedark 高亮主题。</p><h3 id="给链接加上颜色"><a href="#给链接加上颜色" class="headerlink" title="给链接加上颜色"></a>给链接加上颜色</h3><p>根据 Pandoc user guide 的说明，我们可以通过 colorlinks 选项给各种链接加上颜色，便于和普通文本区分开来：</p><pre class="line-numbers language-none"><code class="language-none">colorlinks    add color to link text; automatically enabled if any of linkcolor, filecolor, citecolor, urlcolor, or toccolor are set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同时，为了精确控制不同类型链接颜色，Pandoc 还提供了对不同链接颜色的个性化设置选项：</p><pre class="line-numbers language-none"><code class="language-none">linkcolor, filecolor, citecolor, urlcolor, toccolor    color for internal links, external links, citation links, linked URLs, and    links in table of contents, respectively: uses options allowed by xcolor,    including the dvipsnames, svgnames, and x11names lists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>例如，如果我们想给 URL 链接加上颜色，并且 urlcolor 要设为 NavyBlue, 可以使用下面的命令：</p><pre class="line-numbers language-none"><code class="language-none">pandoc --pdf-engine=xelatex -V colorlinks -V urlcolor=NavyBlue test.md -o test.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他链接的颜色可以按照上述方式设置。</p><p>值得注意的是，urlcolor 选项并不能给文中直接展示的 raw URL link 加上颜色。 要给直接展示的 URL link 加上颜色，可以用 &lt;&gt; 包围要展示的链接，例如&lt;<a href="http://www.google.com>./">www.google.com&gt;。</a></p><p>另外，也可以使用选项 -f gfm，参考这里。完整命令如下，</p><pre class="line-numbers language-none"><code class="language-none">pandoc --pdf-engine=xelatex -f gfm -Vurlcolor=cyan -o test.pdf test.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 -f gfm 的一个缺点是 gfm 不支持公式，因此如果在 Markdown 中包含公式，将不能正确渲染。解决办法是去掉 -f gfm flag，或者使用 Pandoc 自带的 markdown格式。</p><h3 id="更改-PDF-的-margin"><a href="#更改-PDF-的-margin" class="headerlink" title="更改 PDF 的 margin"></a>更改 PDF 的 margin</h3><p>使用默认设置生成的 PDF margin 太大，根据 Pandoc 官方FAQ，可以使用下面的选项更改 margin：</p><pre class="line-numbers language-none"><code class="language-none">-V geometry:"top=2cm, bottom=1.5cm, left=2cm, right=2cm"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完整命令为：</p><pre class="line-numbers language-none"><code class="language-none">pandoc --pdf-engine=xelatex -V geometry:"top=2cm, bottom=1.5cm, left=2cm, right=2cm" -o test.pdf test.md<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Markdown-文件中使用斜杠-backslash-会出错"><a href="#Markdown-文件中使用斜杠-backslash-会出错" class="headerlink" title="Markdown 文件中使用斜杠 backslash 会出错"></a>Markdown 文件中使用斜杠 backslash 会出错</h3><p>原始的 Markdown 格式，支持在文件中使用 backslash，但是 Pandoc 把 backslash 以及后面的内容理解成 LaTeX 命令，因此在编译包含 backslash 的文件时，可能会遇到undefined command 错误或者更加奇怪的错误。参考这里以及这里，解决办法是让 Pandoc 把 Markdown文件当成正常的 Markdown，不要解读 LaTeX 命令，使用下面的 flag:</p><pre class="line-numbers language-none"><code class="language-none">pandoc -f markdown-raw_tex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="直接上命令"><a href="#直接上命令" class="headerlink" title="直接上命令"></a>直接上命令</h3><pre class="line-numbers language-none"><code class="language-none">pandoc --pdf-engine=xelatex -V geometry:"top=2cm, bottom=1.5cm, left=2cm, right=2cm" -V CJKmainfont="Noto Sans Mono CJK SC:style=Regular" -V colorlinks -V urlcolor=NavyBlue -f markdown-raw_tex test.md -o test.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><blockquote><p>以上的方法一是直接使用pandoc进行转化，下面介绍一下两步转化，即先转为tex文件再转成pdf文件</p></blockquote><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#使用pandoc先将test.md文件转为无格式的output.tex文件pandoc -r markdown-auto_identifiers --no-highlight -w latex -o output.tex test.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 其中一些字段需要修改的可以使用linux自带的sed命令，比如将verbatim替换成listings(用于代码块)、或者不想要标题号section替换成section*(无标题号)<br> 使用 sed 替换字符串的语法。</p> <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sed -i 's/Search_String/Replacement_String/g' Input_File <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 首先我们需要了解 sed 语法来做到这一点。请参阅有关的细节。</p><p>sed：这是一个 Linux 命令。<br>-i：这是 sed 命令的一个选项，它有什么作用？默认情况下，sed 打印结果到标准输出。当你使用 sed 添加这个选项时，那么它会在适当的位置修改文件。当你添加一个后缀（比如，-i.bak）时，就会创建原始文件的备份。<br>s：字母 s 是一个替换命令。<br>Search_String：搜索一个给定的字符串或正则表达式。<br>Replacement_String：替换的字符串。<br>g：全局替换标志。默认情况下，sed 命令替换每一行第一次出现的模式，它不会替换行中的其他的匹配结果。但是，提供了该替换标志时，所有匹配都将被替换。<br>/：分界符。<br>Input_File：要执行操作的文件名。</p><p>然后将修改后的output.tex文件插入到latex的模板文件template.tex中，这里推荐一个模板</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex"><span class="token comment">% !TEX encoding = UTF-8 Unicode</span><span class="token function selector">\documentclass</span><span class="token punctuation">[</span>a4paper,11pt,twoside,fontset = none,UTF8<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">ctexart</span><span class="token punctuation">}</span> <span class="token comment">% 页面A4纸大小，11 磅大小的字体，式样为双面，字体集为Fandol，编码为UTF8，文档类型为cTex的art（支持中文）</span><span class="token function selector">\usepackage</span><span class="token punctuation">[</span>a4paper,scale=0.8,hcentering<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">geometry</span><span class="token punctuation">}</span> <span class="token comment">% A4纸大小，缩放80%，设置页面居中</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">hyperref</span><span class="token punctuation">}</span>      <span class="token comment">% 超链接</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">listings</span><span class="token punctuation">}</span>      <span class="token comment">% 代码块</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">courier</span><span class="token punctuation">}</span>       <span class="token comment">% 字体</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">fontspec</span><span class="token punctuation">}</span>      <span class="token comment">% 字体</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">fancyhdr</span><span class="token punctuation">}</span>      <span class="token comment">% 页眉页脚相关宏包</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">lastpage</span><span class="token punctuation">}</span>      <span class="token comment">% 引用最后一页</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">amsmath,amsthm,amsfonts,amssymb,bm</span><span class="token punctuation">}</span> <span class="token comment">%数学</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">graphicx</span><span class="token punctuation">}</span>      <span class="token comment">% 图片</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">subcaption</span><span class="token punctuation">}</span>    <span class="token comment">% 图片描述</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">longtable,booktabs</span><span class="token punctuation">}</span> <span class="token comment">% 表格</span><span class="token function selector">\setCJKsansfont</span><span class="token punctuation">{</span>Noto Sans SC<span class="token punctuation">}</span>  <span class="token comment">%设置字体为Noto Sans SC</span><span class="token function selector">\usepackage</span><span class="token punctuation">{</span><span class="token keyword">xcolor</span><span class="token punctuation">}</span><span class="token function selector">\lstset</span><span class="token punctuation">{</span>    language=Markdown,  <span class="token comment">%代码语言使用的是Markdown</span>    frame=single, <span class="token comment">%把代码用框圈起来</span>    numbers=left, <span class="token comment">% 显示行号</span>    numberstyle=<span class="token function selector">\tiny</span>,    <span class="token comment">% 行号字体</span>    stringstyle=<span class="token function selector">\ttfamily</span>, <span class="token comment">% 代码字符串的特殊格式</span>    breaklines=true, <span class="token comment">%对过长的代码自动换行</span>    extendedchars=false,  <span class="token comment">%解决代码跨页时，章节标题，页眉等汉字不显示的问题</span>    escapebegin=<span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">CJK*</span><span class="token punctuation">}</span>                    ,escapeend=    <span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">CJK*</span><span class="token punctuation">}</span>,      <span class="token comment">% 代码中出现中文必须加上，否则报错</span>    texcl=true<span class="token punctuation">}</span><span class="token function selector">\pagestyle</span><span class="token punctuation">{</span>fancy<span class="token punctuation">}</span>         <span class="token comment">% 页眉页脚风格</span><span class="token function selector">\fancyhf</span><span class="token punctuation">{</span><span class="token punctuation">}</span>                <span class="token comment">% 清空当前设置</span><span class="token function selector">\fancyfoot</span><span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token function selector">\thepage</span><span class="token function selector">\ </span><span class="token punctuation">}</span><span class="token comment">%页脚中间显示 当前页 / 总页数，把\label{LastPage}放在最后</span><span class="token function selector">\begin</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span><span class="token comment">%    insert_begin/</span><span class="token comment">%replace%</span><span class="token comment">%    insert_end/</span><span class="token function selector">\end</span><span class="token punctuation">{</span><span class="token keyword">document</span><span class="token punctuation">}</span><span class="token function selector">\label</span><span class="token punctuation">{</span><span class="token keyword">LastPage</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>之后将完整的latex文件使用以下命令，即可打印出pdf文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">latexmk -pdflatex=xelatex -synctex=1 -interaction=nonstopmode -file-line-error -pdf -outdir=test.pdf template.tex<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>祝各位成功！</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> pandoc </tag>
            
            <tag> markdown </tag>
            
            <tag> pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法的Golang实现</title>
      <link href="/hypo-Z.github.io/2022/06/28/chang-yong-pai-xu-suan-fa-de-golang-shi-xian/"/>
      <url>/hypo-Z.github.io/2022/06/28/chang-yong-pai-xu-suan-fa-de-golang-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="常用排序算法的Golang实现"><a href="#常用排序算法的Golang实现" class="headerlink" title="常用排序算法的Golang实现"></a>常用排序算法的Golang实现</h1><p>在实际生活中，经常会涉及到数字排序的问题，如何快速排序，人们就研究了许多的算法，下面就将常用的算法进行总结：</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="根据排序顺序分类："><a href="#根据排序顺序分类：" class="headerlink" title="根据排序顺序分类："></a>根据排序顺序分类：</h5><p><strong>1 .插入类排序：<font color="red">直接插入排序</font>和希尔排序</strong></p><p><strong>2 .选择类排序：直接选择排序和堆排序</strong></p><p><strong>3.交换类排序：<font color="red">冒泡排序</font>和快速排序</strong></p><p><strong>4.特殊类排序：<font color="red">并归排序</font></strong></p><h5 id="根据算法稳定性分类："><a href="#根据算法稳定性分类：" class="headerlink" title="根据算法稳定性分类："></a>根据算法稳定性分类：</h5><h5 id="稳定性概念"><a href="#稳定性概念" class="headerlink" title="稳定性概念"></a>稳定性概念</h5><blockquote><p>定义：能保证两个相等的数，经过排序之后，其在序列的前后位置顺序不变。（A1=A2，排序前A1在A2前面，排序后A1还在A2前面）</p></blockquote><blockquote><p>意义：稳定性本质是维持具有相同属性的数据的插入顺序，如果后面需要使用该插入顺序排序，则稳定性排序可以避免这次排序。</p></blockquote><h5 id="稳定："><a href="#稳定：" class="headerlink" title="稳定："></a>稳定：</h5><p>直接插入排序、冒泡排序、并归排序</p><h5 id="不稳定："><a href="#不稳定：" class="headerlink" title="不稳定："></a>不稳定：</h5><p>希尔排序、直接选择排序、堆排序、快速排序</p><h5 id="根据时间复杂度分类："><a href="#根据时间复杂度分类：" class="headerlink" title="根据时间复杂度分类："></a>根据时间复杂度分类：</h5><p><strong>平均时间复杂度在O(n^2)：</strong></p><p>直接插入排序、冒泡排序、直接选择排序</p><p><strong>平均时间复杂度在O(n^1.5)：</strong></p><p>希尔排序</p><p><strong>平均时间复杂度在O(nlogn)：</strong></p><p>并归排序、堆排序、快速排序</p><h5 id="快速了解："><a href="#快速了解：" class="headerlink" title="快速了解："></a>快速了解：</h5><blockquote><p>冒泡排序可以说是最差的排序算法。</p></blockquote><blockquote><p>我们把冒泡排序，直接选择排序，直接插入排序认为是初级的排序算法，其中直接插入排序的性能是综合最好的，一般来说，当排序数组规模 <code>n</code> 较小时，直接插入排序可能比任何排序算法都要快，建议只在小规模排序中使用。</p></blockquote><blockquote><p>希尔排序是对直接插入排序的改进版本，比直接选择排序和直接插入排序快，且随着规模的递增，这种性能提升越明显。因为算法容易理解，在排序数组中等规模下，我们可以使用它。在非常大的规模下，它的性能也不那么糟糕，但大规模排序还是建议使用以下的高级排序算法。</p></blockquote><blockquote><p>快速排序，归并排序和堆排序是比较高级的排序算法。</p></blockquote><blockquote><p>目前被认为综合最好的高级排序算法是快速排序，快速排序的平均用时最短，大多数的编程库内置的排序算法都是它。</p></blockquote><blockquote><p>堆排序也是一种很快的排序算法，通过维持一棵二叉树，树的根节点总是最大或最小从而可实现排序。</p></blockquote><blockquote><p>归并排序和快速排序一样使用分治法，递归地先使每个子序列有序，再将两个有序的序列进行合并成一个有序的序列。</p></blockquote><h4 id="糟糕排序算法之一：冒泡排序"><a href="#糟糕排序算法之一：冒泡排序" class="headerlink" title="糟糕排序算法之一：冒泡排序"></a>糟糕排序算法之一：冒泡排序</h4><p>原理：循环比较相邻两个数，直到数列从小到大排序</p><p>代码实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">BubbleSort</span><span class="token punctuation">(</span>list <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token comment">// 在一轮中有没有交换过</span>didSwap <span class="token operator">:=</span> <span class="token boolean">false</span><span class="token comment">// 进行 N-1 轮迭代</span><span class="token keyword">for</span> i <span class="token operator">:=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span><span class="token comment">// 每次从第一位开始比较，比较到第 i 位就不比较了，因为前一轮该位已经有序了</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 如果前面的数比后面的大，那么交换</span><span class="token keyword">if</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> list<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span>didSwap <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 如果在一轮中没有交换过，那么已经排好序了，直接返回</span><span class="token keyword">if</span> <span class="token operator">!</span>didSwap <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>list <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token function">BubbleSort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>冒泡排序交换和比较的次数相加是一个和 <code>N</code> 有关的平方数，所以冒泡排序的最好和最差时间复杂度都是：<code>O(n^2)</code>。也就是说在最好的情况下：对已经排好序的数列进行冒泡排序，只需比较 <code>N</code> 次，最好时间复杂度从 <code>O(n^2)</code><br>骤减为 <code>O(n)</code>。</p><p>冒泡排序算法是稳定的，因为如果两个相邻元素相等，是不会交换的，保证了稳定性的要求。</p><h4 id="糟糕排序算法之二：直接选择排序"><a href="#糟糕排序算法之二：直接选择排序" class="headerlink" title="糟糕排序算法之二：直接选择排序"></a>糟糕排序算法之二：直接选择排序</h4><p>原理：通过选择最小的元素，每轮迭代只需交换一次，放到对应位置，与打扑克牌类似。</p><p>代码实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">SelectSort</span><span class="token punctuation">(</span>list <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token comment">// 进行 N-1 轮迭代</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token comment">// 每次从第 i 位开始，找到最小的元素</span>min <span class="token operator">:=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// 最小数</span>minIndex <span class="token operator">:=</span> i  <span class="token comment">// 最小数的下标</span><span class="token keyword">for</span> j <span class="token operator">:=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">if</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min <span class="token punctuation">{</span><span class="token comment">// 如果找到的数比上次的还小，那么最小的数变为它</span>min <span class="token operator">=</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span>minIndex <span class="token operator">=</span> j<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// 这一轮找到的最小数的下标不等于最开始的下标，交换元素</span><span class="token keyword">if</span> i <span class="token operator">!=</span> minIndex <span class="token punctuation">{</span>list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>list <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token function">SelectSort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较的次数和冒泡排序一样多，因为扫描过程也是比较的过程，只不过交换的次数减少为每轮 1 次。最佳和最坏时间复杂度仍然是：<code>O(n^2)</code>。选择排序是一个不稳定的排序算法，因为它在交换时将后面的数字排列变化了。</p><h4 id="糟糕排序算法之三：直接插入排序"><a href="#糟糕排序算法之三：直接插入排序" class="headerlink" title="糟糕排序算法之三：直接插入排序"></a>糟糕排序算法之三：直接插入排序</h4><p>原理：每次把一个数插到已经排好序的数列里面形成新的排好序的数列，以此反复。与打麻将类似。</p><p>举个简单例子，有 4 个元素的数列：<code>4 2 9 1</code>，我们使用插入排序：</p><pre class="line-numbers language-none"><code class="language-none">[]表示排好序第一轮： [4] 2 9 1 拿待排序的第二个数 2，插入到排好序的数列 [4]与排好序的数列 [4] 比较第一轮进行中：2 比 4 小，插入到 4 前第二轮： [2 4] 9 1 拿待排序的第三个数 9，插入到排好序的数列 [2 4]与排好序的数列 [2 4] 比较第二轮进行中： 9 比 4 大，不变化第三轮： [2 4 9] 1 拿待排序的第四个数 1，插入到排好序的数列 [2 4 9]与排好序的数列 [2 4 9] 比较第三轮进行中： 1 比 9 小，插入到 9 前第三轮进行中： 1 比 4 小，插入到 4 前第三轮进行中： 1 比 2 小，插入到 2 前结果： [1 2 4 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">InsertSort</span><span class="token punctuation">(</span>list <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token comment">// 进行 N-1 轮迭代</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>deal <span class="token operator">:=</span> list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">// 待排序的数</span>j <span class="token operator">:=</span> i <span class="token operator">-</span> <span class="token number">1</span>      <span class="token comment">// 待排序的数左边的第一个数的位置</span><span class="token comment">// 如果第一次比较，比左边的已排好序的第一个数小，那么进入处理</span><span class="token keyword">if</span> deal <span class="token operator">&lt;</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token comment">// 一直往左边找，比待排序大的数都往后挪，腾空位给待排序插入</span><span class="token keyword">for</span> <span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> deal <span class="token operator">&lt;</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span> <span class="token punctuation">{</span>list<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment">// 某数后移，给待排序留空位</span><span class="token punctuation">}</span>list<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> deal <span class="token comment">// 结束了，待排序的数插入空位</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>list2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token function">InsertSort</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度和冒泡排序、直接选择排序一样，都是：<code>O(n^2)</code>。因为是从右到左，将一个个未排序的数，插入到左边已排好序的队列中，所以插入排序，相同的数在排序后顺序不会变化，这个排序算法是稳定的。</p><blockquote><p>小结：数组规模 <code>n</code> 较小的大多数情况下，我们可以使用插入排序，它比冒泡排序，选择排序都快，甚至比任何的排序算法都快。</p></blockquote><blockquote><p>数列中的有序性越高，插入排序的性能越高，因为待排序数组有序性越高，插入排序比较的次数越少。</p></blockquote><blockquote><p>大家都很少使用冒泡、直接选择，直接插入排序算法，因为在有大量元素的无序数列下，这些算法的效率都很低。</p></blockquote><h4 id="直接插入排序改进型：希尔排序"><a href="#直接插入排序改进型：希尔排序" class="headerlink" title="直接插入排序改进型：希尔排序"></a>直接插入排序改进型：希尔排序</h4><p>原理：这是一种分组插入方法，最后一次迭代就相当于是直接插入排序，其他迭代相当于每次移动 <code>n</code> 个距离的直接插入排序，这些整数是两个数之间的距离，我们称它们为增量。</p><p>我们取数列长度的一半为增量，以后每次减半，直到增量为1。</p><pre class="line-numbers language-none"><code class="language-none">x 表示不需要排序的数 取 d = 6 对 [5 x x x x x 6 x x x x x] 进行直接插入排序，没有变化。 取 d = 3 对 [5 x x 6 x x 6 x x 4 x x] 进行直接插入排序，排完序后：[4 x x 5 x x 6 x x 6 x x]。 取 d = 1 对 [4 9 1 5 8 14 6 49 25 6 6 3] 进行直接插入排序，因为 d=1 完全就是直接插入排序了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>越有序的数列，直接插入排序的效率越高，希尔排序通过分组使用直接插入排序，因为步长比 <code>1</code> 大，在一开始可以很快将无序的数列变得不那么无序，比较和交换的次数也减少，直到最后使用步长为 <code>1</code><br>的直接插入排序，数列已经是相对有序了，所以时间复杂度会稍好一点。</p><p>代码实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">// 增量序列折半的希尔排序</span><span class="token keyword">func</span> <span class="token function">ShellSort</span><span class="token punctuation">(</span>list <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 数组长度</span>n <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token comment">// 每次减半，直到步长为 1</span><span class="token keyword">for</span> step <span class="token operator">:=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> step <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> step <span class="token operator">/=</span> <span class="token number">2</span> <span class="token punctuation">{</span><span class="token comment">// 开始插入排序，每一轮的步长为 step</span><span class="token keyword">for</span> i <span class="token operator">:=</span> step<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">+=</span> step <span class="token punctuation">{</span><span class="token keyword">for</span> j <span class="token operator">:=</span> i <span class="token operator">-</span> step<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">-=</span> step <span class="token punctuation">{</span><span class="token comment">// 满足插入那么交换元素</span><span class="token keyword">if</span> list<span class="token punctuation">[</span>j<span class="token operator">+</span>step<span class="token punctuation">]</span> <span class="token operator">&lt;</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j<span class="token operator">+</span>step<span class="token punctuation">]</span> <span class="token operator">=</span> list<span class="token punctuation">[</span>j<span class="token operator">+</span>step<span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>list <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">467</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">567</span><span class="token punctuation">,</span> <span class="token number">335</span><span class="token punctuation">,</span> <span class="token number">677</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token function">ShellSort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>希尔排序不是稳定的，因为每一轮分组，都使用了直接插入排序，希尔排序的时间复杂度大约在这个范围：<code>O(n^1.3)~O(n^2)</code>。</p><blockquote><p>按照之前分析的几种排序算法，一般建议待排序数组为小规模情况下使用直接插入排序，在规模中等的情况下可以使用希尔排序，但在大规模还是要使用快速排序，归并排序或堆排序。</p></blockquote><p>以下三种算法由于代码实现复杂，此阶段仅作原理了解：</p><hr><p>2022.7.15更新，将之前没有补完的算法解析补上，接着撸代码…</p><h4 id="优秀排序算法之一：并归排序"><a href="#优秀排序算法之一：并归排序" class="headerlink" title="优秀排序算法之一：并归排序"></a>优秀排序算法之一：并归排序</h4><p>原理：归并排序先排序较小的数组，再将有序的小数组合并形成更大有序的数组。</p><p>归并排序有两种递归做法，一种是自顶向下，一种是自底向上。</p><h5 id="自顶向下："><a href="#自顶向下：" class="headerlink" title="自顶向下："></a>自顶向下：</h5><p>从一个大数组开始，不断地往下切分，从上往下进行递归，直到切分的小数组无法切分了，然后不断地对这些有序数组进行合并。</p><p>每次都是一分为二，特别均匀，所以最差和最坏时间复杂度都一样，总的时间复杂度为：<code>O(nlogn)</code>。</p><h5 id="自底向上："><a href="#自底向上：" class="headerlink" title="自底向上："></a>自底向上：</h5><p>从小数组开始排序，不断地合并形成更大的有序数组。时间复杂度和自顶向上归并排序一样，也都是 <code>O(nlogn)</code></p><p>代码实现：使用自顶向下法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"math/rand"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token comment">//确定数组长度</span>length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token comment">//长度小于等于一直接返回</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span><span class="token keyword">return</span> data<span class="token punctuation">}</span><span class="token comment">//切分数组</span>num <span class="token operator">:=</span> length <span class="token operator">/</span> <span class="token number">2</span><span class="token comment">//不断切分数组,递归调用函数，直到切分最小</span><span class="token comment">//小于等于num为左数组</span>left <span class="token operator">:=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>num<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//大于num为右数组</span>right <span class="token operator">:=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>num<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//并调用数组排序并合并</span><span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//数组合并，对左右数组并入到一个新数组</span><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>result <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>l<span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token comment">//左右数组不超过原数组</span><span class="token keyword">for</span> l <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> r <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//若左数组最小位小于右数组最小位，则将左数组元素加至数组尾部</span><span class="token keyword">if</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token punctuation">{</span>result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> left<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span>l<span class="token operator">++</span><span class="token comment">//反之，则将右数组元素加至数组尾部</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>r<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//因为左右数组的长度会变化，所以(数组[0:]...)表示可变长度的数组</span><span class="token comment">//将新的左数组全部添加至新数组</span>result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> left<span class="token punctuation">[</span>l<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">//再将新的右数组全部添加至新数组</span>result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right<span class="token punctuation">[</span>r<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token comment">//回参已经定义了就直接return</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优秀排序算法之二：堆排序"><a href="#优秀排序算法之二：堆排序" class="headerlink" title="优秀排序算法之二：堆排序"></a>优秀排序算法之二：堆排序</h4><p>原理：优先队列是一种能完成以下任务的队列：插入一个数值，取出最小或最大的数值（获取数值，并且删除）。</p><p>优先队列可以用二叉树来实现，我们称这种结构为二叉堆。</p><p>最小堆和最大堆是二叉堆的一种，是一棵完全二叉树（一种平衡树）。</p><p>最小堆的性质：</p><ol><li>父节点的值都小于左右儿子节点，且左儿子小于右儿子。</li><li>这是一个递归的性质。</li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">   1  / \ 2   3/ \ / \4 5 6 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最大堆的性质：</p><ol><li>父节点的值都大于左右儿子节点，且左儿子小于右儿子。</li><li>这是一个递归的性质。</li></ol><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">   7  / \ 5   6/ \ / \1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最大堆和最小堆实现方式一样，只不过根节点一个是最大的，一个是最小的。时间复杂度为：<code>O(nlogn)</code></p><p>这个算法实现起来非常抽象，借用菜鸟教程的动态演示可能会更加清晰<br><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="动图演示"><br>再配合<a href="https://zhuanlan.zhihu.com/p/142095184">堆排序详解</a> 食用，理解更加通透</p><p>代码实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"math/rand"</span><span class="token punctuation">)</span><span class="token comment">//堆排序函数</span><span class="token keyword">func</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>arrLen <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">//第一步，先构造最大堆</span><span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span><span class="token comment">//构造最大堆完成后</span><span class="token keyword">for</span> i <span class="token operator">:=</span> arrLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span><span class="token comment">//交换最大根和尾部子树</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token comment">//长度减一</span>arrLen <span class="token operator">-=</span> <span class="token number">1</span><span class="token comment">//从根部开始构建最大堆</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> arr<span class="token punctuation">}</span><span class="token comment">//构造最大堆函数</span><span class="token keyword">func</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> arrLen <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token punctuation">(</span>arrLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//核心算法，将大于根的子树进行交换</span><span class="token keyword">func</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arrLen <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//左子树下标</span>left <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token comment">//右子树下标</span>right <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token comment">//根下标</span>largest <span class="token operator">:=</span> i<span class="token comment">//当arrLen&gt;left和right 时，表示该子树存在</span><span class="token comment">//并且左子树大于根，则根的下标等于作子树的下标</span><span class="token keyword">if</span> left <span class="token operator">&lt;</span> arrLen <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>largest <span class="token operator">=</span> left<span class="token punctuation">}</span><span class="token comment">//在这个时候largest = left,就相当于右子树和左子树进行比较</span><span class="token comment">//若右子树大于左子树，则根的下标等于右子树的下标</span><span class="token keyword">if</span> right <span class="token operator">&lt;</span> arrLen <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>largest <span class="token operator">=</span> right<span class="token punctuation">}</span><span class="token comment">//若上面的if满足，则largest != i，进行元素交换</span><span class="token keyword">if</span> largest <span class="token operator">!=</span> i <span class="token punctuation">{</span><span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token comment">//递归变化位置后的子树，保证满足最大堆规则</span><span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//交换函数</span><span class="token keyword">func</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token function">heapSort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="优秀排序算法之三：快速排序"><a href="#优秀排序算法之三：快速排序" class="headerlink" title="优秀排序算法之三：快速排序"></a>优秀排序算法之三：快速排序</h4><p>原理：本质上来看，快速排序是对冒泡排序的一种改进，属于交换类的排序算法。</p><p>快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>步骤如下：</p><ol><li>先从数列中取出一个数作为基准数。一般取第一个数。</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>再对左右区间重复第二步，直到各区间只有一个数。</li></ol><p>举一个例子：<code>5 9 1 6 8 14 6 49 25 4 6 3</code>。</p><pre class="line-numbers language-none"><code class="language-none">一般取第一个数 5 作为基准，从它左边和最后一个数使用[]进行标志，如果左边的数比基准数大，那么该数要往右边扔，也就是两个[]数交换，这样大于它的数就在右边了，然后右边[]数左移，否则左边[]数右移。5 [9] 1 6 8 14 6 49 25 4 6 [3]  因为 9 &gt; 5，两个[]交换位置后，右边[]左移5 [3] 1 6 8 14 6 49 25 4 [6] 9  因为 3 !&gt; 5，两个[]不需要交换，左边[]右移5 3 [1] 6 8 14 6 49 25 4 [6] 9  因为 1 !&gt; 5，两个[]不需要交换，左边[]右移5 3 1 [6] 8 14 6 49 25 4 [6] 9  因为 6 &gt; 5，两个[]交换位置后，右边[]左移5 3 1 [6] 8 14 6 49 25 [4] 6 9  因为 6 &gt; 5，两个[]交换位置后，右边[]左移5 3 1 [4] 8 14 6 49 [25] 6 6 9  因为 4 !&gt; 5，两个[]不需要交换，左边[]右移5 3 1 4 [8] 14 6 49 [25] 6 6 9  因为 8 &gt; 5，两个[]交换位置后，右边[]左移5 3 1 4 [25] 14 6 [49] 8 6 6 9  因为 25 &gt; 5，两个[]交换位置后，右边[]左移5 3 1 4 [49] 14 [6] 25 8 6 6 9  因为 49 &gt; 5，两个[]交换位置后，右边[]左移5 3 1 4 [6] [14] 49 25 8 6 6 9  因为 6 &gt; 5，两个[]交换位置后，右边[]左移5 3 1 4 [14] 6 49 25 8 6 6 9  两个[]已经汇总，因为 14 &gt; 5，所以 5 和[]之前的数 4 交换位置第一轮切分结果：4 3 1 5 14 6 49 25 8 6 6 9  现在第一轮快速排序已经将数列分成两个部分：4 3 1 和 14 6 49 25 8 6 6 9左边的数列都小于 5，右边的数列都大于 5。使用递归分别对两个数列进行快速排序。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"math/rand"</span><span class="token punctuation">)</span><span class="token comment">//快速排序</span><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>data <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">//第一轮排序，先选出基准数</span>base <span class="token operator">:=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>l<span class="token punctuation">,</span> r <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token comment">//i是要交换位置的下标</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span> <span class="token punctuation">{</span><span class="token comment">//如果左边的数比基准数大，那么该数要往右边扔</span><span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> base <span class="token punctuation">{</span><span class="token comment">//将大于基准数的数字移至最右边</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">//右边进行比较的数下标减一位</span>r<span class="token operator">--</span><span class="token comment">//如果左边的数比基准数小，那么该数要往左边扔</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//将小于基准数的数字移至最左边</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment">//左边进行比较的下标加一位</span>l<span class="token operator">++</span><span class="token comment">//交换位置的下标加一位</span>i<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//一次循环结束后，以基准数位置分成左右两个部分分别在进行递归</span><span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">quickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token function">quickSort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度为：<code>O(nlogn)</code></p><p>参考文章：<br><a href="https://goa.lenggirl.com/#/algorithm/sort">数据结构与算法</a><br><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">菜鸟教程：排序算法</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——数据结构之栈和队列</title>
      <link href="/hypo-Z.github.io/2022/03/02/go-yu-yan-jin-jie-shu-ju-jie-gou-zhi-zhan-he-dui-lie/"/>
      <url>/hypo-Z.github.io/2022/03/02/go-yu-yan-jin-jie-shu-ju-jie-gou-zhi-zhan-he-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言进阶——数据结构之栈和队列"><a href="#Go语言进阶——数据结构之栈和队列" class="headerlink" title="Go语言进阶——数据结构之栈和队列"></a>Go语言进阶——数据结构之栈和队列</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>由之前的文章可知，存储数据元素将数据放入或删除存储空间内，最基本的结构是数组和链表，而获取数据元素的方式有多种形式，但最简单的是取最前或最后。</p><p>栈（stack）：先进后出，就像堆东西一样，需要将后面的取了才能取前面的。</p><p>队列（queue）：先进先出，排队。</p><p>我们可以用数据结构：<code>链表</code>（可连续或不连续的将数据与数据关联起来的结构），或 <code>数组</code>（连续的内存空间，按索引取值） 来实现 <code>栈（stack）</code> 和 <code>队列 (queue)</code>。</p><h2 id="二、数组栈ArrayStack"><a href="#二、数组栈ArrayStack" class="headerlink" title="二、数组栈ArrayStack"></a>二、数组栈ArrayStack</h2><p>数组形式的下压栈，后进先出：</p><p>使用切片来实现：</p><h3 id="2-1-结构"><a href="#2-1-结构" class="headerlink" title="2.1 结构"></a>2.1 结构</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 数组栈，后进先出</span><span class="token keyword">type</span> ArrayStack <span class="token keyword">struct</span> <span class="token punctuation">{</span>    array <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>   <span class="token comment">// 底层切片</span>    size  <span class="token builtin">int</span>        <span class="token comment">// 栈的元素数量</span>    lock  sync<span class="token punctuation">.</span>Mutex <span class="token comment">// 为了并发安全使用的锁</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-入栈："><a href="#2-2-入栈：" class="headerlink" title="2.2 入栈："></a>2.2 入栈：</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 入栈</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>ArrayStack<span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>v <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 放入切片中，后进的元素放在数组最后面</span>    stack<span class="token punctuation">.</span>array <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>array<span class="token punctuation">,</span> v<span class="token punctuation">)</span>    <span class="token comment">// 栈中元素数量+1</span>    stack<span class="token punctuation">.</span>size <span class="token operator">=</span> stack<span class="token punctuation">.</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将元素加到数组最后面，使用锁保证并发安全，切片容量会自动扩容。</p><h3 id="2-3-出栈"><a href="#2-3-出栈" class="headerlink" title="2.3 出栈"></a>2.3 出栈</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>ArrayStack<span class="token punctuation">)</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 栈中元素已空</span>    <span class="token keyword">if</span> stack<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"empty"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 栈顶元素</span>    v <span class="token operator">:=</span> stack<span class="token punctuation">.</span>array<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token comment">// 切片收缩，但可能占用空间越来越大</span>    <span class="token comment">//stack.array = stack.array[0 : stack.size-1]</span>    <span class="token comment">// 创建新的切片，空间占用不会越来越大，但可能移动元素次数过多</span>    newArray <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> stack<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> stack<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> stack<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        newArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span>    stack<span class="token punctuation">.</span>array <span class="token operator">=</span> newArray    <span class="token comment">// 栈中元素数量-1</span>    stack<span class="token punctuation">.</span>size <span class="token operator">=</span> stack<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> v<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回栈顶元素，使用锁保证并发安全，创建新的切片将余下的元素复制到新切片，即储存空间降容</p><h3 id="2-4-获取栈顶元素"><a href="#2-4-获取栈顶元素" class="headerlink" title="2.4 获取栈顶元素"></a>2.4 获取栈顶元素</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 获取栈顶元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>ArrayStack<span class="token punctuation">)</span> <span class="token function">Peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token comment">// 栈中元素已空</span>    <span class="token keyword">if</span> stack<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"empty"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 栈顶元素值</span>    v <span class="token operator">:=</span> stack<span class="token punctuation">.</span>array<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> v<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-获取栈大小和判断是否为空"><a href="#2-5-获取栈大小和判断是否为空" class="headerlink" title="2.5 获取栈大小和判断是否为空"></a>2.5 获取栈大小和判断是否为空</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 栈大小</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>ArrayStack<span class="token punctuation">)</span> <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span>size<span class="token punctuation">}</span><span class="token comment">// 栈是否为空</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>ArrayStack<span class="token punctuation">)</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-举个🌰"><a href="#2-6-举个🌰" class="headerlink" title="2.6 举个🌰"></a>2.6 举个🌰</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    arrayStack <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>ArrayStack<span class="token punctuation">)</span>    arrayStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"cat"</span><span class="token punctuation">)</span>    arrayStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>    arrayStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"hen"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">,</span> arrayStack<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"pop:"</span><span class="token punctuation">,</span> arrayStack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"pop:"</span><span class="token punctuation">,</span> arrayStack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">,</span> arrayStack<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    arrayStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"drag"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"pop:"</span><span class="token punctuation">,</span> arrayStack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">size<span class="token punctuation">:</span> <span class="token number">3</span>pop<span class="token punctuation">:</span> henpop<span class="token punctuation">:</span> dogsize<span class="token punctuation">:</span> <span class="token number">1</span>pop<span class="token punctuation">:</span> drag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、数组队列ArrayQueue"><a href="#三、数组队列ArrayQueue" class="headerlink" title="三、数组队列ArrayQueue"></a>三、数组队列ArrayQueue</h2><p>与数组栈类似，但是元素是先进先出</p><h3 id="3-1-结构："><a href="#3-1-结构：" class="headerlink" title="3.1 结构："></a>3.1 结构：</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 数组队列，先进先出</span><span class="token keyword">type</span> ArrayQueue <span class="token keyword">struct</span> <span class="token punctuation">{</span>    array <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>   <span class="token comment">// 底层切片</span>    size  <span class="token builtin">int</span>        <span class="token comment">// 队列的元素数量</span>    lock  sync<span class="token punctuation">.</span>Mutex <span class="token comment">// 为了并发安全使用的锁</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-入队"><a href="#3-2-入队" class="headerlink" title="3.2 入队"></a>3.2 入队</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 入队</span><span class="token keyword">func</span> <span class="token punctuation">(</span>queue <span class="token operator">*</span>ArrayQueue<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>v <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 放入切片中，后进的元素放在数组最后面</span>    queue<span class="token punctuation">.</span>array <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>array<span class="token punctuation">,</span> v<span class="token punctuation">)</span>    <span class="token comment">// 队中元素数量+1</span>    queue<span class="token punctuation">.</span>size <span class="token operator">=</span> queue<span class="token punctuation">.</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和入栈一样，元素都是直接存放数组的最后方</p><h3 id="3-3-出队"><a href="#3-3-出队" class="headerlink" title="3.3 出队"></a>3.3 出队</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 出队</span><span class="token keyword">func</span> <span class="token punctuation">(</span>queue <span class="token operator">*</span>ArrayQueue<span class="token punctuation">)</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 队中元素已空</span>    <span class="token keyword">if</span> queue<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"empty"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 队列最前面元素</span>    v <span class="token operator">:=</span> queue<span class="token punctuation">.</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment">/*    直接原位移动，但缩容后继的空间不会被释放        for i := 1; i &lt; queue.size; i++ {            // 从第一位开始进行数据移动            queue.array[i-1] = queue.array[i]        }        // 原数组缩容        queue.array = queue.array[0 : queue.size-1]    */</span>    <span class="token comment">// 创建新的数组，移动次数过多</span>    newArray <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> queue<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> queue<span class="token punctuation">.</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queue<span class="token punctuation">.</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token comment">// 从老数组的第一位开始进行数据移动</span>        newArray<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> queue<span class="token punctuation">.</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span>    queue<span class="token punctuation">.</span>array <span class="token operator">=</span> newArray    <span class="token comment">// 队中元素数量-1</span>    queue<span class="token punctuation">.</span>size <span class="token operator">=</span> queue<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> v<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>缩容</code>即将原切片第一位后面的元素复制到新切片</p><h2 id="四、链表栈LinkStack"><a href="#四、链表栈LinkStack" class="headerlink" title="四、链表栈LinkStack"></a>四、链表栈LinkStack</h2><h3 id="4-1结构"><a href="#4-1结构" class="headerlink" title="4.1结构"></a>4.1结构</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 链表栈，后进先出</span><span class="token keyword">type</span> LinkStack <span class="token keyword">struct</span> <span class="token punctuation">{</span>    root <span class="token operator">*</span>LinkNode  <span class="token comment">// 链表起点</span>    size <span class="token builtin">int</span>        <span class="token comment">// 栈的元素数量</span>    lock sync<span class="token punctuation">.</span>Mutex <span class="token comment">// 为了并发安全使用的锁</span><span class="token punctuation">}</span><span class="token comment">// 链表节点</span><span class="token keyword">type</span> LinkNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Next  <span class="token operator">*</span>LinkNode    Value <span class="token builtin">string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这使用最简单的列表结构</p><h3 id="4-2-入栈"><a href="#4-2-入栈" class="headerlink" title="4.2 入栈"></a>4.2 入栈</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 入栈</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>LinkStack<span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>v <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 如果栈顶为空，那么增加节点</span>    <span class="token keyword">if</span> stack<span class="token punctuation">.</span>root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        stack<span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span>        stack<span class="token punctuation">.</span>root<span class="token punctuation">.</span>Value <span class="token operator">=</span> v    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 否则新元素插入链表的头部</span>        <span class="token comment">// 原来的链表</span>        preNode <span class="token operator">:=</span> stack<span class="token punctuation">.</span>root        <span class="token comment">// 新节点</span>        newNode <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span>        newNode<span class="token punctuation">.</span>Value <span class="token operator">=</span> v        <span class="token comment">// 原来的链表链接到新元素后面</span>        newNode<span class="token punctuation">.</span>Next <span class="token operator">=</span> preNode        <span class="token comment">// 将新节点放在头部</span>        stack<span class="token punctuation">.</span>root <span class="token operator">=</span> newNode    <span class="token punctuation">}</span>    <span class="token comment">// 栈中元素数量+1</span>    stack<span class="token punctuation">.</span>size <span class="token operator">=</span> stack<span class="token punctuation">.</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将新元素放在原链表的头部即满足了栈的后进先出</p><h3 id="4-3-出栈"><a href="#4-3-出栈" class="headerlink" title="4.3 出栈"></a>4.3 出栈</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 出栈</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>LinkStack<span class="token punctuation">)</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> stack<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 栈中元素已空</span>    <span class="token keyword">if</span> stack<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"empty"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 顶部元素要出栈</span>    topNode <span class="token operator">:=</span> stack<span class="token punctuation">.</span>root    v <span class="token operator">:=</span> topNode<span class="token punctuation">.</span>Value    <span class="token comment">// 将顶部元素的后继链接链上</span>    stack<span class="token punctuation">.</span>root <span class="token operator">=</span> topNode<span class="token punctuation">.</span>Next    <span class="token comment">// 栈中元素数量-1</span>    stack<span class="token punctuation">.</span>size <span class="token operator">=</span> stack<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> v<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-获取栈顶元素"><a href="#4-4-获取栈顶元素" class="headerlink" title="4.4 获取栈顶元素"></a>4.4 获取栈顶元素</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 获取栈顶元素</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>LinkStack<span class="token punctuation">)</span> <span class="token function">Peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token comment">// 栈中元素已空</span>    <span class="token keyword">if</span> stack<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"empty"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 顶部元素值</span>    v <span class="token operator">:=</span> stack<span class="token punctuation">.</span>root<span class="token punctuation">.</span>Value    <span class="token keyword">return</span> v<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-获取栈大小和判断是否为空"><a href="#4-5-获取栈大小和判断是否为空" class="headerlink" title="4.5 获取栈大小和判断是否为空"></a>4.5 获取栈大小和判断是否为空</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 栈大小</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>LinkStack<span class="token punctuation">)</span> <span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span>size<span class="token punctuation">}</span><span class="token comment">// 栈是否为空</span><span class="token keyword">func</span> <span class="token punctuation">(</span>stack <span class="token operator">*</span>LinkStack<span class="token punctuation">)</span> <span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-6-举个🌰"><a href="#4-6-举个🌰" class="headerlink" title="4.6 举个🌰"></a>4.6 举个🌰</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    linkStack <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkStack<span class="token punctuation">)</span>    linkStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"cat"</span><span class="token punctuation">)</span>    linkStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>    linkStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"hen"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">,</span> linkStack<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"pop:"</span><span class="token punctuation">,</span> linkStack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"pop:"</span><span class="token punctuation">,</span> linkStack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"size:"</span><span class="token punctuation">,</span> linkStack<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    linkStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"drag"</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"pop:"</span><span class="token punctuation">,</span> linkStack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">size<span class="token punctuation">:</span> <span class="token number">3</span>pop<span class="token punctuation">:</span> henpop<span class="token punctuation">:</span> dogsize<span class="token punctuation">:</span> <span class="token number">1</span>pop<span class="token punctuation">:</span> drag<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、链表队列LinkQueue"><a href="#五、链表队列LinkQueue" class="headerlink" title="五、链表队列LinkQueue"></a>五、链表队列LinkQueue</h2><p>队列先进先出，和栈操作顺序相反，我们这里只实现入队，和出队操作，其他操作和栈一样。</p><h3 id="5-1-结构"><a href="#5-1-结构" class="headerlink" title="5.1 结构"></a>5.1 结构</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 链表队列，先进先出</span><span class="token keyword">type</span> LinkQueue <span class="token keyword">struct</span> <span class="token punctuation">{</span>    root <span class="token operator">*</span>LinkNode  <span class="token comment">// 链表起点</span>    size <span class="token builtin">int</span>        <span class="token comment">// 队列的元素数量</span>    lock sync<span class="token punctuation">.</span>Mutex <span class="token comment">// 为了并发安全使用的锁</span><span class="token punctuation">}</span><span class="token comment">// 链表节点</span><span class="token keyword">type</span> LinkNode <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Next  <span class="token operator">*</span>LinkNode    Value <span class="token builtin">string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-入队"><a href="#5-2-入队" class="headerlink" title="5.2 入队"></a>5.2 入队</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 入队</span><span class="token keyword">func</span> <span class="token punctuation">(</span>queue <span class="token operator">*</span>LinkQueue<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>v <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 如果栈顶为空，那么增加节点</span>    <span class="token keyword">if</span> queue<span class="token punctuation">.</span>root <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        queue<span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>root<span class="token punctuation">.</span>Value <span class="token operator">=</span> v    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 否则新元素插入链表的末尾</span>        <span class="token comment">// 新节点</span>        newNode <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span>        newNode<span class="token punctuation">.</span>Value <span class="token operator">=</span> v        <span class="token comment">// 一直遍历到链表尾部</span>        nowNode <span class="token operator">:=</span> queue<span class="token punctuation">.</span>root        <span class="token keyword">for</span> nowNode<span class="token punctuation">.</span>Next <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            nowNode <span class="token operator">=</span> nowNode<span class="token punctuation">.</span>Next        <span class="token punctuation">}</span>        <span class="token comment">// 新节点放在链表尾部</span>        nowNode<span class="token punctuation">.</span>Next <span class="token operator">=</span> newNode    <span class="token punctuation">}</span>    <span class="token comment">// 队中元素数量+1</span>    queue<span class="token punctuation">.</span>size <span class="token operator">=</span> queue<span class="token punctuation">.</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-出队"><a href="#5-3-出队" class="headerlink" title="5.3 出队"></a>5.3 出队</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 出队</span><span class="token keyword">func</span> <span class="token punctuation">(</span>queue <span class="token operator">*</span>LinkQueue<span class="token punctuation">)</span> <span class="token function">Remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> queue<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 队中元素已空</span>    <span class="token keyword">if</span> queue<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"empty"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment">// 顶部元素要出队</span>    topNode <span class="token operator">:=</span> queue<span class="token punctuation">.</span>root    v <span class="token operator">:=</span> topNode<span class="token punctuation">.</span>Value    <span class="token comment">// 将顶部元素的后继链接链上</span>    queue<span class="token punctuation">.</span>root <span class="token operator">=</span> topNode<span class="token punctuation">.</span>Next    <span class="token comment">// 队中元素数量-1</span>    queue<span class="token punctuation">.</span>size <span class="token operator">=</span> queue<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">return</span> v<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此可以总结这几种存储结构的优缺：</p><p>数组实现栈和队列：能快速随机访问存储的元素，通过下标 <code>index</code> 访问，支持随机访问，查询速度快，但存在元素在数组空间中大量移动的操作，增删效率低。</p><p>链表实现栈和队列：只支持顺序访问，在某些遍历操作中查询速度慢，但增删元素快。</p><p>文章参考：<br><a href="https://goa.lenggirl.com/#/algorithm/link?id=_11%e5%88%9d%e5%a7%8b%e5%8c%96%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8">数据结构和算法</a><br><a href="https://www.runoob.com/go/go-arrays.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——数据结构之链表与数组</title>
      <link href="/hypo-Z.github.io/2022/03/01/go-yu-yan-jin-jie-shu-ju-jie-gou-zhi-lian-biao/"/>
      <url>/hypo-Z.github.io/2022/03/01/go-yu-yan-jin-jie-shu-ju-jie-gou-zhi-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言进阶——数据结构之链表与数组"><a href="#Go语言进阶——数据结构之链表与数组" class="headerlink" title="Go语言进阶——数据结构之链表与数组"></a>Go语言进阶——数据结构之链表与数组</h1><h2 id="一、链表"><a href="#一、链表" class="headerlink" title="一、链表"></a>一、链表</h2><blockquote><p>链表由一个个数据节点组成的，它是一个递归结构，要么它是空的，要么它存在一个指向另外一个数据节点的引用。</p></blockquote><p>链表最基础的数据结构</p><ul><li>这是一个简单的单向链表结构：</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> LinkNode <span class="token keyword">struct</span><span class="token punctuation">{</span>Data     <span class="token builtin">int64</span>    NextNode <span class="token operator">*</span>LinkNode<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">singleRing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 新的节点</span>    node <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span>    node<span class="token punctuation">.</span>Data <span class="token operator">=</span> <span class="token number">2</span>    <span class="token comment">// 新的节点</span>    node1 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span>    node1<span class="token punctuation">.</span>Data <span class="token operator">=</span> <span class="token number">3</span>    node<span class="token punctuation">.</span>NextNode <span class="token operator">=</span> node1 <span class="token comment">// node1 链接到 node 节点上</span>    <span class="token comment">// 新的节点</span>    node2 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>LinkNode<span class="token punctuation">)</span>    node2<span class="token punctuation">.</span>Data <span class="token operator">=</span> <span class="token number">4</span>    node1<span class="token punctuation">.</span>NextNode <span class="token operator">=</span> node2 <span class="token comment">// node2 链接到 node1 节点上</span>    <span class="token comment">// 按顺序打印数据</span>    nowNode <span class="token operator">:=</span> node    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> nowNode <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token comment">// 打印节点值</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>nowNode<span class="token punctuation">.</span>Data<span class="token punctuation">)</span>            <span class="token comment">// 获取下一个节点</span>            nowNode <span class="token operator">=</span> nowNode<span class="token punctuation">.</span>NextNode            <span class="token keyword">continue</span>        <span class="token punctuation">}</span>        <span class="token comment">// 如果下一个节点为空，表示链表结束了</span>        <span class="token keyword">break</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行打印：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">2</span><span class="token number">3</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>接下来看看双链表的实现：</li></ul><p>在Go的官方标准库container/ring有实现：</p><p>双链表结构如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 循环链表</span><span class="token keyword">type</span> Ring <span class="token keyword">struct</span> <span class="token punctuation">{</span>    next<span class="token punctuation">,</span> prev <span class="token operator">*</span>Ring       <span class="token comment">// 前驱和后驱节点</span>    Value      <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 数据</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 初始化空的循环链表，前驱和后驱都指向自己，因为是循环的</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Ring <span class="token punctuation">{</span>    r<span class="token punctuation">.</span>next <span class="token operator">=</span> r    r<span class="token punctuation">.</span>prev <span class="token operator">=</span> r    <span class="token keyword">return</span> r<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 后驱指向下一个元素，所以值不能为空</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Ring <span class="token punctuation">{</span><span class="token keyword">if</span> r<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">.</span>next<span class="token punctuation">}</span><span class="token comment">// 前驱指向上一个元素，所以值不能为空</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token function">Prev</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Ring <span class="token punctuation">{</span><span class="token keyword">if</span> r<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">.</span>prev<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 创建一个元素为n的链表</span><span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Ring <span class="token punctuation">{</span><span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span>r <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Ring<span class="token punctuation">)</span>p <span class="token operator">:=</span> r<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>Ring<span class="token punctuation">{</span>prev<span class="token punctuation">:</span> p<span class="token punctuation">}</span>p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">}</span>p<span class="token punctuation">.</span>next <span class="token operator">=</span> rr<span class="token punctuation">.</span>prev <span class="token operator">=</span> p<span class="token keyword">return</span> r<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 计算链表的长度及元素个数</span><span class="token comment">// 它的执行时间与元素的数量成正比。</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>n <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">if</span> r <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>n <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">for</span> p <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> r<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next <span class="token punctuation">{</span>n<span class="token operator">++</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> n<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//遍历查找节点，当n小于零则向前n位，当n大于零则向后n位</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token function">Move</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Ring <span class="token punctuation">{</span><span class="token keyword">if</span> r<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">switch</span> <span class="token punctuation">{</span><span class="token keyword">case</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">for</span> <span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token operator">++</span> <span class="token punctuation">{</span>r <span class="token operator">=</span> r<span class="token punctuation">.</span>prev<span class="token punctuation">}</span><span class="token keyword">case</span> n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token keyword">for</span> <span class="token punctuation">;</span> n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token operator">--</span> <span class="token punctuation">{</span>r <span class="token operator">=</span> r<span class="token punctuation">.</span>next<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 往节点A，链接一个节点，并且返回之前节点A的后驱节点</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token function">Link</span><span class="token punctuation">(</span>s <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token operator">*</span>Ring <span class="token punctuation">{</span>    n <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> s <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        p <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">Prev</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        r<span class="token punctuation">.</span>next <span class="token operator">=</span> s        s<span class="token punctuation">.</span>prev <span class="token operator">=</span> r        n<span class="token punctuation">.</span>prev <span class="token operator">=</span> p        p<span class="token punctuation">.</span>next <span class="token operator">=</span> n    <span class="token punctuation">}</span>    <span class="token keyword">return</span> n<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 删除节点后面的 n 个节点</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Ring<span class="token punctuation">)</span> <span class="token function">Unlink</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Ring <span class="token punctuation">{</span>    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> r<span class="token punctuation">.</span><span class="token function">Link</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span><span class="token function">Move</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、数组与链表"><a href="#二、数组与链表" class="headerlink" title="二、数组与链表"></a>二、数组与链表</h2><p>数组是编程语言作为一种基本类型提供出来的，相同数据类型的元素按一定顺序排列的集合。</p><p>它的作用只有一种：存放数据，让你很快能找到存的数据。如果你不去额外改进它，它就只是存放数据而已，它不会将一个数据节点和另外一个数据节点关联起来。</p><p>数组这一数据类型，是被编程语言高度抽象封装的结构，<code>下标</code> 会转换成 <code>虚拟内存地址</code>，然后操作系统会自动帮我们进行寻址，这个寻址过程是特别快的，所以往数组的某个下标取一个值和放一个值，时间复杂度都为 <code>O(1)</code>。</p><p>它是一种将 <code>虚拟内存地址</code> 和 <code>数据元素</code> 映射起来的内置语法结构，数据和数据之间是挨着，存放在一个连续的内存区域，每一个固定大小（8字节）的内存片段都有一个虚拟的地址编号。当然这个虚拟内存不是真正的内存，每个程序启动都会有一个虚拟内存空间来映射真正的内存</p><p>数组和链表是两个不同的概念。一个是编程语言提供的基本数据类型，表示一个连续的内存空间，可通过一个索引访问数据。另一个是我们定义的数据结构，通过一个数据节点，可以定位到另一个数据节点，不要求连续的内存空间。</p><p>数组的优点是占用空间小，查询快，直接使用索引就可以获取数据元素，缺点是移动和删除数据元素要大量移动空间。</p><p>链表的优点是移动和删除数据元素速度快，只要把相关的数据元素重新链接起来，但缺点是占用空间大，查找需要遍历。</p><p>很多其他的数据结构都由数组和链表配合实现的。</p><p>具体可在<a href="https://hypo.ltd/2021/11/24/go-yu-yan-ji-chu-shu-zu-yu-qie-pian/">Go语言基础——数组与切片</a>了解详情</p><p>文章参考：<br><a href="https://goa.lenggirl.com/#/algorithm/link?id=_11%e5%88%9d%e5%a7%8b%e5%8c%96%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8">数据结构和算法</a><br><a href="https://www.runoob.com/go/go-arrays.html">菜鸟教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker时区调整方案</title>
      <link href="/hypo-Z.github.io/2022/02/23/docker-shi-qu-diao-zheng-fang-an/"/>
      <url>/hypo-Z.github.io/2022/02/23/docker-shi-qu-diao-zheng-fang-an/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-时区调整方案"><a href="#Docker-时区调整方案" class="headerlink" title="Docker 时区调整方案"></a>Docker 时区调整方案</h1><p>对于经常使用 Docker 的人来说，可能会碰到一个问题：时区问题。</p><p>大部分 Docker 镜像都是基于 Alpine，Ubuntu，Debian，CentOS 等基础镜像制作而成。</p><p>基本上都采用 UTC 时间，默认时区为零时区。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker run <span class="token operator">--</span>name test <span class="token operator">--</span>rm <span class="token operator">-</span>ti alpine <span class="token operator">/</span>bin<span class="token operator">/</span>sh<span class="token operator">/</span> # dateFri Nov <span class="token number">29</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">49</span> <span class="token constant">UTC</span> <span class="token number">2019</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>而我们主要用的是 CST 时间，北京时间，位于东八区。时区代号： Asia/Shanghai</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker run <span class="token operator">--</span>name test <span class="token operator">--</span>rm <span class="token operator">-</span>ti <span class="token operator">-</span>v <span class="token operator">/</span>etc<span class="token operator">/</span>timezone<span class="token operator">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>timezone<span class="token operator">:</span>ro <span class="token operator">-</span>v <span class="token operator">/</span>etc<span class="token operator">/</span>localtime<span class="token operator">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>localtime<span class="token operator">:</span>ro alpine <span class="token operator">/</span>bin<span class="token operator">/</span>sh<span class="token operator">/</span> # dateFri Nov <span class="token number">29</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">55</span> <span class="token constant">CST</span> <span class="token number">201</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对比一下，我们会发现，时间上相差 8 小时。</p><p>经过一系列探索实践，我们总结了一些 Docker 时区调整方案。</p><h2 id="一、运行-Docker-容器时调整时区"><a href="#一、运行-Docker-容器时调整时区" class="headerlink" title="一、运行 Docker 容器时调整时区"></a>一、运行 Docker 容器时调整时区</h2><p>在 Linux 系统中，控制时区和时间的主要是两个地方：</p><ul><li><code>/etc/timezone</code> 主要代表当前时区设置，一般链接指向<code>/usr/share/zoneinfo</code>目录下的具体时区。</li><li><code>/etc/localtime</code> 主要代表当前时区设置下的本地时间。</li></ul><h3 id="1-通用-docker-时区修改方案"><a href="#1-通用-docker-时区修改方案" class="headerlink" title="1. 通用 docker 时区修改方案"></a>1. 通用 docker 时区修改方案</h3><h4 id="宿主机为-Linux-系统"><a href="#宿主机为-Linux-系统" class="headerlink" title="宿主机为 Linux 系统"></a><a href="https://cloud.tencent.com/product/cdh?from=10680">宿主机</a>为 Linux 系统</h4><p>当宿主机为 Linux 系统时，我们可以直接将宿主机上的<code>/etc/timezone</code>和<code>/etc/localtime</code>挂载到容器中，这样可以保持容器和宿主机时区和时间一致。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">-</span>v <span class="token operator">/</span>etc<span class="token operator">/</span>timezone<span class="token operator">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>timezone<span class="token operator">:</span>ro <span class="token operator">-</span>v <span class="token operator">/</span>etc<span class="token operator">/</span>localtime<span class="token operator">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>localtime<span class="token operator">:</span>ro<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用示例如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker run <span class="token operator">--</span>name test <span class="token operator">--</span>rm <span class="token operator">-</span>ti <span class="token operator">-</span>v <span class="token operator">/</span>etc<span class="token operator">/</span>timezone<span class="token operator">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>timezone<span class="token operator">:</span>ro <span class="token operator">-</span>v <span class="token operator">/</span>etc<span class="token operator">/</span>localtime<span class="token operator">:</span><span class="token operator">/</span>etc<span class="token operator">/</span>localtime<span class="token operator">:</span>ro alpine <span class="token operator">/</span>bin<span class="token operator">/</span>sh<span class="token operator">/</span> # dateFri Nov <span class="token number">29</span> <span class="token number">16</span><span class="token operator">:</span><span class="token number">13</span><span class="token operator">:</span><span class="token number">55</span> <span class="token constant">CST</span> <span class="token number">2019</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-通过传递环境变量改变容器时区"><a href="#2-通过传递环境变量改变容器时区" class="headerlink" title="2. 通过传递环境变量改变容器时区"></a>2. 通过传递环境变量改变容器时区</h3><ul><li>适用于基于 Debian 基础镜像, CentOS 基础镜像 制作的 Docker 镜像</li><li>不适用于基于 Alpine 基础镜像, Ubuntu 基础镜像 制作的 Docker 镜像</li></ul><p>对于基于 Debian 基础镜像，CentOS 基础镜像制作的 Docker 镜像，在运行 Docker 容器时，传递环境变量<code>-e TZ=Asia/Shanghai</code>进去，能修改 docker 容器时区。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">-</span>e <span class="token constant">TZ</span><span class="token operator">=</span>Asia<span class="token operator">/</span>Shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用示例如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">docker run <span class="token operator">--</span>name test <span class="token operator">-</span>e <span class="token constant">TZ</span><span class="token operator">=</span>Asia<span class="token operator">/</span>Shanghai <span class="token operator">--</span>rm <span class="token operator">-</span>ti debian <span class="token operator">/</span>bin<span class="token operator">/</span>bash<span class="token operator">/</span># dateFri Nov <span class="token number">29</span> <span class="token number">18</span><span class="token operator">:</span><span class="token number">46</span><span class="token operator">:</span><span class="token number">18</span> <span class="token constant">CST</span> <span class="token number">2019</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="二、制作-Docker-镜像时调整时区"><a href="#二、制作-Docker-镜像时调整时区" class="headerlink" title="二、制作 Docker 镜像时调整时区"></a>二、制作 Docker 镜像时调整时区</h2><p>通过编写 Dockerfile,构建自己的 Docker 镜像，可以永久解决时区问题。</p><h3 id="1-Alpine"><a href="#1-Alpine" class="headerlink" title="1. Alpine"></a>1. Alpine</h3><p>根据<a href="https://wiki.alpinelinux.org/wiki/Setting_the_timezone">《Setting the timezone》</a>提示，我们可以将以下代码添加到 Dockerfile 中：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV TZ Asia/ShanghaiRUN apk add tzdata &amp;&amp; cp /usr/share/zoneinfo/${TZ} /etc/localtime \    &amp;&amp; echo ${TZ} &gt; /etc/timezone \    &amp;&amp; apk del tzdata<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-Debian"><a href="#2-Debian" class="headerlink" title="2. Debian"></a>2. Debian</h3><p>Debian 基础镜像 中已经安装了 tzdata 包，我们可以将以下代码添加到 Dockerfile 中：</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV TZ=Asia/Shanghai \    DEBIAN_FRONTEND=noninteractiveRUN ln -fs /usr/share/zoneinfo/${TZ} /etc/localtime \    &amp;&amp; echo ${TZ} &gt; /etc/timezone \    &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata \    &amp;&amp; rm -rf /var/lib/apt/lists/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Ubuntu"><a href="#3-Ubuntu" class="headerlink" title="3. Ubuntu"></a>3. Ubuntu</h3><p>Ubuntu 基础镜像中没有安装了 tzdata 包，因此我们需要先安装 tzdata 包。</p><p>我们可以将以下代码添加到 Dockerfile 中。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV TZ=Asia/Shanghai \    DEBIAN_FRONTEND=noninteractiveRUN apt update \    &amp;&amp; apt install -y tzdata \    &amp;&amp; ln -fs /usr/share/zoneinfo/${TZ} /etc/localtime \    &amp;&amp; echo ${TZ} &gt; /etc/timezone \    &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata \    &amp;&amp; rm -rf /var/lib/apt/lists/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-CentOS"><a href="#4-CentOS" class="headerlink" title="4. CentOS"></a>4. CentOS</h3><p>CentOS 基础镜像 中已经安装了 tzdata 包，我们可以将以下代码添加到 Dockerfile 中。</p><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">ENV TZ Asia/ShanghaiRUN ln -fs /usr/share/zoneinfo/${TZ} /etc/localtime \    &amp;&amp; echo ${TZ} &gt; /etc/timezone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>时区问题是大问题。</p><p>时间没统一好，业务会乱套。</p><p>希望通过上面的内容，能够帮助大家解决好 Docker 方面的时区问题。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶——逃逸分析</title>
      <link href="/hypo-Z.github.io/2022/02/21/go-yu-yan-jin-jie-tao-yi-fen-xi/"/>
      <url>/hypo-Z.github.io/2022/02/21/go-yu-yan-jin-jie-tao-yi-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h2><h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>要理解什么是逃逸分析会涉及堆和栈的一些基本知识,如果忘记的同学我们可以简单的回顾一下：</p><ul><li>堆（Heap）：一般来讲是人为手动进行管理,手动申请,分配,释放.堆适合不可预知大小的内存分配,这也意味着为此付出的代价是分配速度较慢,而且会形成内存碎片.</li><li>栈（Stack）：由编译器进行管理,自动申请,分配,释放.一般不会太大,因此栈的分配和回收速度非常快;我们常见的函数参数（不同平台允许存放的数量不同）,局部变量等都会存放在栈上. 栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”,分配和释放;而堆分配内存首先需要去找到一块大小合适的内存块,之后要通过垃圾回收才能释放.</li></ul><p>通俗比喻的说,<code>栈</code>就如我们去饭馆吃饭,只需要点菜（发出申请）–》吃吃吃（使用内存）–》吃饱就跑剩下的交给饭馆（操作系统自动回收）,而<code>堆</code>就如在家里做饭,大到家,小到买什么菜,每一个环节都需要自己来实现,但是自由度会大很多.</p><p>在编译程序优化理论中,逃逸分析是一种确定指针动态范围的方法,简单来说就是分析在程序的哪些地方可以访问到该指针.</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>再往简单的说,Go是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放栈上还是放堆上,不逃逸的对象放栈上,可能逃逸的放堆上;即我发现<code>变量</code>在退出函数后没有用了,那么就把丢到栈上,毕竟栈上的内存分配和回收比堆上快很多;反之,函数内的普通变量经过<code>逃逸分析</code>后,发现在函数退出后<code>变量</code>还有在其他地方上引用,那就将<code>变量</code>分配在堆上.做到按需分配（哪里的人民需要我,我就往哪去~~,一个党员的呐喊）.</p><h2 id="为何需要逃逸分析"><a href="#为何需要逃逸分析" class="headerlink" title="为何需要逃逸分析"></a>为何需要逃逸分析</h2><p>ok,了解完<code>堆</code>和<code>栈</code>各自的优缺点后,我们就可以更好的知道<code>逃逸分析</code>存在的目的了：</p><ol><li>减少<code>gc</code>压力,栈上的变量,随着函数退出后系统直接回收,不需要<code>gc</code>标记后再清除.</li><li>减少内存碎片的产生.</li><li>减轻分配堆内存的开销,提高程序的运行速度.</li></ol><h2 id="如何确定是否逃逸"><a href="#如何确定是否逃逸" class="headerlink" title="如何确定是否逃逸"></a>如何确定是否逃逸</h2><p>在<code>Go</code>中通过逃逸分析日志来确定变量是否逃逸,开启逃逸分析日志：</p><pre class="line-numbers language-none"><code class="language-none">go run -gcflags '-m -l' main.go<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>-m</code> 会打印出逃逸分析的优化策略,实际上最多总共可以用 4 个 <code>-m</code>,但是信息量较大,一般用 1 个就可以了.</li><li><code>-l</code> 会禁用函数内联,在这里禁用掉<code>内联</code>能更好的观察逃逸情况,减少干扰.</li></ul><h2 id="逃逸案例"><a href="#逃逸案例" class="headerlink" title="逃逸案例"></a>逃逸案例</h2><h3 id="案例一：取地址发生逃逸"><a href="#案例一：取地址发生逃逸" class="headerlink" title="案例一：取地址发生逃逸"></a>案例一：取地址发生逃逸</h3><pre class="line-numbers language-none"><code class="language-none">package maintype UserData struct {    Name  string}func main() {    var info UserData    info.Name = "WilburXu"    _ = GetUserInfo(info)}func GetUserInfo(userInfo UserData) *UserData {    return &amp;userInfo}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>go run -gcflags '-m -l' main.go</code> 后返回以下结果：</p><pre class="line-numbers language-none"><code class="language-none"># command-line-arguments.\main.go:14:9: &amp;userInfo escapes to heap.\main.go:13:18: moved to heap: userInfo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>GetUserInfo函数里面的变量 <code>userInfo</code> 逃到堆上了（分配到堆内存空间上了）. GetUserInfo 函数的返回值为 *UserData 指针类型,然后 将值变量<code>userInfo</code> 的地址返回,此时编译器会判断该值可能会在函数外使用,就将其分配到了堆上,所以变量<code>userInfo</code>就逃逸了.</p></blockquote><h4 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h4><pre class="line-numbers language-none"><code class="language-none">func main() {    var info UserData    info.Name = "WilburXu"    _ = GetUserInfo(&amp;info)}func GetUserInfo(userInfo *UserData) *UserData {    return userInfo}# command-line-arguments.\main.go:13:18: leaking param: userInfo to result ~r1 level=0.\main.go:10:18: main &amp;info does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对一个变量取地址,可能会被分配到堆上.但是编译器进行逃逸分析后,如果发现到在函数返回后,此变量不会被引用,那么还是会被分配到栈上.套个取址符,就想骗补助？</p><p>编译器傲娇的说：Too young,Too Cool…！</p><h3 id="案例二-：未确定类型"><a href="#案例二-：未确定类型" class="headerlink" title="案例二 ：未确定类型"></a>案例二 ：未确定类型</h3><pre class="line-numbers language-none"><code class="language-none">package maintype User struct {    name interface{}}func main() {    name := "WilburXu"    MyPrintln(name)}func MyPrintln(one interface{}) (n int, err error) {    var userInfo = new(User)    userInfo.name = one // 泛型赋值 逃逸咯    return}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>go run -gcflags '-m -l' main.go</code> 后返回以下结果：</p><pre class="line-numbers language-none"><code class="language-none"># command-line-arguments./main.go:12:16: leaking param: one./main.go:13:20: MyPrintln new(User) does not escape./main.go:9:11: name escapes to heap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里可能有同学会好奇,<code>MyPrintln</code>函数内并没有被引用的便利,为什么变了<code>name</code>会被分配到了<code>堆</code>上呢？</p><p>上一个案例我们知道了,普通的手法想去”骗取补助”,聪明灵利的编译器是不会“上当受骗的噢”;但是对于<code>interface</code>类型,很遗憾,编译器在编译的时候很难知道在函数的调用或者结构体的赋值过程会是怎么类型,因此只能分配到<code>堆</code>上.</p><h4 id="优化方案-1"><a href="#优化方案-1" class="headerlink" title="优化方案"></a>优化方案</h4><p>将结构体<code>User</code>的成员<code>name</code>的类型,函数<code>MyPringLn</code>参数<code>one</code>的类型改为 <code>string</code>,将得出：</p><pre class="line-numbers language-none"><code class="language-none"># command-line-arguments./main.go:12:16: leaking param: one./main.go:13:20: MyPrintln new(User) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="拓展分析"><a href="#拓展分析" class="headerlink" title="拓展分析"></a>拓展分析</h3><p>对于案例二的分析,我们还可以通过反编译命令<code>go tool compile -S main.go</code>查看,会发现如果为<code>interface</code>类型,main主函数在编译后会<code>额外</code>多出以下指令：</p><pre class="line-numbers language-none"><code class="language-none"># main.go:9 -&gt; MyPrintln(name)    0x001d 00029 (main.go:9)    PCDATA    $2, $1    0x001d 00029 (main.go:9)    PCDATA    $0, $1    0x001d 00029 (main.go:9)    LEAQ    go.string."WilburXu"(SB), AX    0x0024 00036 (main.go:9)    PCDATA    $2, $0    0x0024 00036 (main.go:9)    MOVQ    AX, ""..autotmp_5+32(SP)    0x0029 00041 (main.go:9)    MOVQ    $8, ""..autotmp_5+40(SP)    0x0032 00050 (main.go:9)    PCDATA    $2, $1    0x0032 00050 (main.go:9)    LEAQ    type.string(SB), AX    0x0039 00057 (main.go:9)    PCDATA    $2, $0    0x0039 00057 (main.go:9)    MOVQ    AX, (SP)    0x003d 00061 (main.go:9)    PCDATA    $2, $1    0x003d 00061 (main.go:9)    LEAQ    ""..autotmp_5+32(SP), AX    0x0042 00066 (main.go:9)    PCDATA    $2, $0    0x0042 00066 (main.go:9)    MOVQ    AX, 8(SP)    0x0047 00071 (main.go:9)    CALL    runtime.convT2Estring(SB)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>Go汇编语法</code>不熟悉的可以参考 <a href="https://studygolang.com/articles/2917">Golang汇编快速指南</a></p><h3 id="案例三：间接赋值（Assignment-to-indirection-escapes）"><a href="#案例三：间接赋值（Assignment-to-indirection-escapes）" class="headerlink" title="案例三：间接赋值（Assignment to indirection escapes）"></a>案例三：间接赋值（Assignment to indirection escapes）</h3><p>对某个引用类对象中的引用类成员进行赋值.Go 语言中的引用类数据类型有 <code>func</code>, <code>interface</code>, <code>slice</code>, <code>map</code>, <code>chan</code>, <code>*Type(指针)</code>.</p><pre class="line-numbers language-none"><code class="language-none">package maintype User struct {    name interface{}    age *int}func main() {    var (        userOne User        userTwo = new(User)    )    userOne.name = "WilburXuOne"    // 不逃逸    userTwo.name = "WilburXuTwo"    // 逃逸    userOne.age = new(int)    // 不逃逸    userTwo.age = new(int)    // 逃逸}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>go run -gcflags '-m -l' main.go</code> 后返回以下结果：</p><pre class="line-numbers language-none"><code class="language-none"># command-line-arguments.\main.go:14:17: "WilburXuTwo" escapes to heap.\main.go:17:19: new(int) escapes to heap.\main.go:11:16: main new(User) does not escape.\main.go:13:17: main "WilburXuOne" does not escape.\main.go:16:19: main new(int) does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么这里<code>值</code>类型不会逃逸而<code>引用类型</code>会逃逸呢？这是因为在 <code>userTwo = new(User)</code> 对象的创建时,编译器先是分析<code>userTwo</code> 对象可能分配在<code>堆</code>上,同时成员变量 <code>name</code> 和 <code>age</code> 也为<code>引用类型</code>,为了保证不出现<code>栈</code>回收后,导致对象<code>userTwo</code>的成员值也被回收,所以<code>name</code>和<code>age</code>需要逃逸.</p><p>但是,如果<code>name</code>和<code>age</code>为值类型,那么编译器虽然初步分析<code>userTwo</code>会分配在<code>堆</code>上,但由于<code>main</code>主函数结束后,变量都会被回收,也就是说对象没有被其他引用,那么就都会分配在<code>栈</code>上,所以<code>name</code>和<code>age</code>没有发生逃逸.</p><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><p>尽量不要将<code>引用对象</code>赋值给<code>引用对象</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不要盲目使用变量的指针作为函数参数,虽然它会减少复制操作.但其实当参数为变量自身的时候,复制是在栈上完成的操作,开销远比变量逃逸后动态地在堆上分配内存少的多.</p><p>Go的编译器就如一个聪明的<code>孩子</code>一般,大多时候在逃逸分析问题上的处理都令人眼前一亮,但有时<code>闹性子</code>的时候处理也是非常粗糙的分析或完全放弃,毕竟这是孩子天性不是吗？ 所以也需要我们在编写代码的时候多多观察,多多留意了.</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html">http://www.agardner.me/golang…</a></p><p><a href="https://segmentfault.com/a/1190000019234268">https://segmentfault.com/a/11…</a></p><p><a href="https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview#heading=h.3i6ywlgy4wrw">https://docs.google.com/docum…</a></p><p><a href="http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html">http://npat-efault.github.io/…</a></p><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><p>文章转载自<a href="https://mojotv.cn/2019/07/21/golang-escape">https://mojotv.cn/2019/07/21/golang-escape</a>，感谢大佬分享</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言常见问题</title>
      <link href="/hypo-Z.github.io/2022/02/21/go-yu-yan-chang-jian-wen-ti/"/>
      <url>/hypo-Z.github.io/2022/02/21/go-yu-yan-chang-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="go常见问题："><a href="#go常见问题：" class="headerlink" title="go常见问题："></a>go常见问题：</h1><h3 id="1-go关键字有那些？"><a href="#1-go关键字有那些？" class="headerlink" title="1. go关键字有那些？"></a>1. go关键字有那些？</h3><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p><table><thead><tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr></thead><tbody><tr><td>copy</td><td>false</td><td>float32</td><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>uint32</td></tr><tr><td>int32</td><td>int64</td><td>iota</td><td>len</td><td>make</td><td>new</td><td>nil</td><td>panic</td><td>uint64</td></tr><tr><td>print</td><td>println</td><td>real</td><td>recover</td><td>string</td><td>true</td><td>uint</td><td>uint8</td><td>uintptr</td></tr></tbody></table><p>程序一般由关键字、常量、变量、运算符、类型和函数组成。</p><p>程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。</p><p>程序中可能会使用到这些标点符号：.、,、;、: 和 …。</p><h3 id="2-new函数和make函数的区别？"><a href="#2-new函数和make函数的区别？" class="headerlink" title="2. new函数和make函数的区别？"></a>2. new函数和make函数的区别？</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">new</span><span class="token punctuation">(</span>Type<span class="token punctuation">)</span> <span class="token operator">*</span>Type<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>new的内置函数分配内存。第一个参数是一个类型，而不是一个值，返回的值是指向该类型新分配的零值的指针。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">make</span><span class="token punctuation">(</span>t Type<span class="token punctuation">,</span> size <span class="token operator">...</span>IntegerType<span class="token punctuation">)</span> Type<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>make内置函数分配并初始化类型为slice、map或channel（仅限）的对象。与new一样，第一个参数是类型，而不是值。与new不同，make的返回类型与其参数的类型相同，而不是指向它的指针。结果的规格取决于类型：</p><p>slice(切片)：size指定长度。切片的容量是等于它的长度。第二个整数参数可以提供给指定不同的容量；它不能小于长例如，make（[]int，0，10）分配一个底层数组大小为10，并返回长度为0、容量为10的切片由这个底层数组支持。</p><p>map(键对)：一张空地图被分配了足够的空间来存放地图指定的元素数。在这种情况下，尺寸可以省略分配了一个小的起始大小。</p><p>channel(通道)：size通道的缓冲区用指定的缓冲容量。如果为零，或省略了大小，则通道为没有缓冲。</p><p>就是说make函数只能用于创建slice、map和channel，而new函数可以创建多种类型</p><h3 id="3-数组和切片有什么区别？"><a href="#3-数组和切片有什么区别？" class="headerlink" title="3. 数组和切片有什么区别？"></a>3. 数组和切片有什么区别？</h3><p>Go语言中数组是固定长度的，<strong>不能动态扩容</strong>，在编译期就会确定大小，声明方式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> buffer <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">]</span><span class="token builtin">int</span>buffer <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切片是对数组的抽象，因为数组的长度是不可变的，在某些场景下使用起来就不是很方便，所以Go语言提供了一种灵活，功能强悍的内置类型切片(“动态数组”)，与数组相比切片的长度是不固定的，可以追加元素。切片是一种数据结构，切片不是数组，切片描述的是一块数组。</p><p>我们可以直接声明一个未指定大小的数组来定义切片，也可以使用make()函数来创建切片，声明方式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// 直接声明</span>slice <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span> <span class="token comment">// 字面量方式</span>slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// make创建</span>slice <span class="token operator">:=</span> array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token comment">// 截取下标的方式</span>slice <span class="token operator">:=</span> <span class="token operator">*</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// new一个</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>切片可以使用append追加元素，当cap不足时进行动态扩容</strong>。</p><p><strong>切片扩容策略：</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>  <span class="token comment">// 两倍扩容</span> doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap  <span class="token comment">// 新切片需要的容量大于两倍扩容的容量，则直接按照新切片需要的容量扩容</span> <span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&gt;</span> doublecap <span class="token punctuation">{</span>  newcap <span class="token operator">=</span> <span class="token builtin">cap</span> <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 原 slice 容量小于 1024 的时候，新 slice 容量按2倍扩容</span>  <span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">{</span>   newcap <span class="token operator">=</span> doublecap  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。</span>   <span class="token comment">// Check 0 &lt; newcap to detect overflow</span>   <span class="token comment">// and prevent an infinite loop.</span>   <span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">{</span>    newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切片在扩容时会进行内存对齐，这个和内存分配策略相关。</p><p>进行内存对齐之后，新 slice 的容量是要 大于等于老 slice 容量的 2倍或者1.25倍，则直接按照新切片需要的容量扩容；</p><p>当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；</p><p>原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">-</span>新容量<span class="token operator">=</span>所需的容量<span class="token operator">-</span>      <span class="token operator">&gt;</span>  <span class="token number">2</span>倍原容量  <span class="token operator">&gt;</span>      <span class="token operator">-</span>新容量<span class="token operator">=</span><span class="token number">2</span>倍原容量<span class="token operator">-</span>     <span class="token operator">&gt;</span>  <span class="token number">1024</span>  <span class="token operator">&gt;</span>     <span class="token operator">-</span>新容量<span class="token operator">=</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">4</span>倍原容量<span class="token operator">-</span>     <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-1-切片的拷贝："><a href="#3-1-切片的拷贝：" class="headerlink" title="3.1 切片的拷贝："></a>3.1 切片的拷贝：</h4><p>深浅拷贝都是进行复制，区别在于复制出来的新对象与原来的对象在它们发生改变时，是否会相互影响，本质区别就是复制出来的对象与原对象是否会指向同一个地址。在Go语言，切片拷贝有三种方式：</p><ul><li>使用=操作符拷贝切片，这种就是浅拷贝</li><li>使用[:]下标的方式复制切片，这种也是浅拷贝</li><li>使用Go语言的内置函数copy()进行切片拷贝，这种就是深拷贝</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">copy</span><span class="token punctuation">(</span>dst <span class="token punctuation">[</span><span class="token punctuation">]</span>Type<span class="token punctuation">,</span> src <span class="token punctuation">[</span><span class="token punctuation">]</span>Type<span class="token punctuation">)</span> <span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>copy内置函数将元素从源切片复制到目标切片。（作为特例，它还将把字符串中的字节复制到字节片中。）源和目标可能重叠。Copy返回复制的元素数，即 len（src）和 len（dst）的最小值。</p><h4 id="3-2-零切片、空切片、nil切片是什么？"><a href="#3-2-零切片、空切片、nil切片是什么？" class="headerlink" title="3.2 零切片、空切片、nil切片是什么？"></a>3.2 零切片、空切片、nil切片是什么？</h4><p>为什么问题中这么多种切片呢？因为在Go语言中切片的创建方式有五种，不同方式创建出来的切片也不一样；</p><ul><li>零切片</li></ul><p>我们把切片内部数组的元素都是零值或者底层数组的内容就全是 nil的切片叫做零切片，使用make创建的、长度、容量都不为0的切片就是零值切片：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// 0 0 0 0 0</span>slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// nil nil nil nil nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>nil切片</li></ul><p>nil切片的长度和容量都为0，并且和nil比较的结果为true，采用直接创建切片的方式、new创建切片的方式都可以创建nil切片：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//允许对值为 nil 的 slice 添加元素</span><span class="token keyword">var</span> slice <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>空切片</li></ul><p>空切片的长度和容量也都为0，但是和nil的比较结果为false，因为所有的空切片的数据指针都指向同一个地址 0xc42003bda0；使用字面量、make可以创建空切片：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> slice <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> slice <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>空切片指向的 zerobase 内存地址是一个神奇的地址，从 Go 语言的源代码中可以看到它的定义：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// base address for all 0-byte allocations</span><span class="token keyword">var</span> zerobase <span class="token builtin">uintptr</span><span class="token comment">// 分配对象内存</span><span class="token keyword">func</span> <span class="token function">mallocgc</span><span class="token punctuation">(</span>size <span class="token builtin">uintptr</span><span class="token punctuation">,</span> typ <span class="token operator">*</span>_type<span class="token punctuation">,</span> needzero <span class="token builtin">bool</span><span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span>Pointer <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token keyword">if</span> size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">Pointer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zerobase<span class="token punctuation">)</span> <span class="token punctuation">}</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言提供了range关键字用于for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素，有两种使用方式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token operator">:=</span> <span class="token keyword">range</span> slice <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">for</span> k <span class="token operator">:=</span> <span class="token keyword">range</span> slice <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一种是遍历下标和对应值，第二种是只遍历下标，使用range遍历切片时会先拷贝一份，然后在遍历拷贝数据</p><p>因为变量v是拷贝切片中的数据，所以修改v不会对原切片有影响。</p><h3 id="4-range-迭代-map是有序的吗？"><a href="#4-range-迭代-map是有序的吗？" class="headerlink" title="4. range 迭代 map是有序的吗？"></a>4. range 迭代 map是有序的吗？</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">/* 声明变量，默认 map 是 nil */</span><span class="token keyword">var</span> map_variable <span class="token keyword">map</span><span class="token punctuation">[</span>key_data_type<span class="token punctuation">]</span>value_data_type<span class="token comment">/* 使用 make 函数 ，如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对*/</span>map_variable <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>key_data_type<span class="token punctuation">]</span>value_data_type<span class="token punctuation">)</span><span class="token comment">/* range 迭代 map */</span><span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">range</span> map_variable <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"map`s key=%s,map`s value=%s"</span><span class="token punctuation">,</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p><p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p><p>一致方法：将map的key存入一有序数组中，然后遍历数组key值，依次取出map的value值</p><h3 id="5-go循环中switch语句和select语句的区别及for语句？"><a href="#5-go循环中switch语句和select语句的区别及for语句？" class="headerlink" title="5. go循环中switch语句和select语句的区别及for语句？"></a>5. go循环中switch语句和select语句的区别及for语句？</h3><h4 id="5-1-switch语句"><a href="#5-1-switch语句" class="headerlink" title="5.1 switch语句"></a>5.1 switch语句</h4><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。</p><p>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。</p><p>switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 <strong>fallthrough</strong> 。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">switch</span> val <span class="token punctuation">{</span>    <span class="token keyword">case</span> val1<span class="token punctuation">:</span>        <span class="token operator">...</span><span class="token comment">//自带 break 语句，匹配成功后就不会执行其他 case,直接返回</span>    <span class="token keyword">case</span> val2<span class="token punctuation">:</span>        <span class="token operator">...</span><span class="token comment">//如果我们需要执行后面的 case，可以使用fallthrough</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        <span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-2-select语句"><a href="#5-2-select语句" class="headerlink" title="5.2 select语句"></a>5.2 select语句</h4><p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。所以常用于goroutine的完美退出。</p><p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> communication clause  <span class="token punctuation">:</span>       <span class="token function">statement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">case</span> communication clause  <span class="token punctuation">:</span>       <span class="token function">statement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* 你可以定义任意数量的 case */</span>    <span class="token keyword">default</span> <span class="token punctuation">:</span> <span class="token comment">/* 可选 */</span>       <span class="token function">statement</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下描述了 select 语句的语法：</p><ul><li><p>每个 case 都必须是一个通信</p></li><li><p>所有 channel 表达式都会被求值</p></li><li><p>所有被发送的表达式都会被求值</p></li><li><p>如果任意某个通信可以进行，它就执行，其他被忽略。</p></li><li><p>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。</p><p>否则：</p><ol><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ol></li></ul><h4 id="5-3-for语句"><a href="#5-3-for语句" class="headerlink" title="5.3 for语句"></a>5.3 for语句</h4><p>for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环 for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。</p><h3 id="6-如何从-panic-中恢复？"><a href="#6-如何从-panic-中恢复？" class="headerlink" title="6. 如何从 panic 中恢复？"></a>6. 如何从 panic 中恢复？</h3><p>在一个 defer 延迟执行的函数中调用 recover ，它便能捕捉/中断 panic。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 错误的 recover 调用示例</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 什么都不会捕捉</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"not good"</span><span class="token punctuation">)</span> <span class="token comment">// 发生 panic，主程序退出</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 不会被执行</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 正确的 recover 调用示例</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"recovered: "</span><span class="token punctuation">,</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"not good"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>recover 必须在 defer 函数中运行。recover 捕获的是祖父级调用时的异常，直接调用时无效。</p><h3 id="7-闭包错误引用同一个变量问题怎么处理？"><a href="#7-闭包错误引用同一个变量问题怎么处理？" class="headerlink" title="7. 闭包错误引用同一个变量问题怎么处理？"></a>7. 闭包错误引用同一个变量问题怎么处理？</h3><p>在每轮迭代中生成一个局部变量 i 。如果没有 i := i 这行，将会打印同一个变量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        i <span class="token operator">:=</span> i        <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者是通过函数参数传入 i 。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-go语言触发异常的场景有哪些？"><a href="#8-go语言触发异常的场景有哪些？" class="headerlink" title="8. go语言触发异常的场景有哪些？"></a>8. go语言触发异常的场景有哪些？</h3><ul><li>空指针解析</li><li>下标越界</li><li>除数为0</li><li>调用 panic 函数</li></ul><h3 id="9-Go的Struct能不能比较？"><a href="#9-Go的Struct能不能比较？" class="headerlink" title="9. Go的Struct能不能比较？"></a>9. Go的Struct能不能比较？</h3><ul><li>相同struct类型的可以比较</li><li>不同struct类型的不可以比较,编译都不过，类型不匹配</li></ul><h3 id="10-协程和线程和进程的区别？"><a href="#10-协程和线程和进程的区别？" class="headerlink" title="10. 协程和线程和进程的区别？"></a>10. 协程和线程和进程的区别？</h3><p>并发掌握，goroutine和channel声明与使用！</p><ul><li><p>进程: 进程是具有一定独立功能的程序，进程是系统资源分配和调度的最小单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p></li><li><p>线程: 线程是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p></li><li><p>协程: 协程是一种用户态的轻量级线程，协程的调度完全是由用户来控制的。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p></li></ul><h4 id="10-1-Goroutine和线程的区别？"><a href="#10-1-Goroutine和线程的区别？" class="headerlink" title="10.1 Goroutine和线程的区别？"></a>10.1 Goroutine和线程的区别？</h4><ul><li>一个线程可以有多个协程</li><li>线程、进程都是同步机制，而协程是异步</li><li>协程可以保留上一次调用时的状态，当过程重入时，相当于进入了上一次的调用状态</li><li>协程是需要线程来承载运行的，所以协程并不能取代线程，「线程是被分割的CPU资源，协程是组织好的代码流程」</li></ul><h3 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h3><h3 id="1-垃圾回收（gabage-collection（简称GC））"><a href="#1-垃圾回收（gabage-collection（简称GC））" class="headerlink" title="1. 垃圾回收（gabage collection（简称GC））"></a>1. 垃圾回收（gabage collection（简称GC））</h3><p><strong>垃圾回收、三色标记原理</strong></p><p>垃圾回收就是对程序中不再使用的内存资源进行自动回收的操作。</p><h4 id="1-1-常见的垃圾回收算法："><a href="#1-1-常见的垃圾回收算法：" class="headerlink" title="1.1 常见的垃圾回收算法："></a>1.1 常见的垃圾回收算法：</h4><ul><li>引用计数：每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1 ，当计数为 0 时，回收该对象。<ul><li>优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。</li><li>缺点：不能很好的处理循环引用</li></ul></li><li>标记-清除(<strong>go</strong>使用)：从根变量开始遍历所有引用的对象，引用的对象标记“被引用”，没有被标记的则进行回收。<ul><li>优点：解决了引用计数的缺点。</li><li>缺点：需要 <strong>STW（stop the world）</strong>，暂时停止程序运行。</li></ul></li><li>分代收集(<strong>java</strong>使用)：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。<ul><li>优点：回收性能好</li><li>缺点：算法复杂</li></ul></li></ul><h4 id="1-2-三色标记法-即标记-清除算法"><a href="#1-2-三色标记法-即标记-清除算法" class="headerlink" title="1.2 三色标记法(即标记-清除算法)"></a>1.2 三色标记法(即<strong>标记-清除</strong>算法)</h4><ul><li>初始状态下所有对象都是白色的。</li><li>从根节点开始遍历所有对象，把遍历到的对象变成灰色对象</li><li>遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。</li><li>循环步骤3，直到灰色对象全部变黑色。</li><li>通过写屏障(write-barrier)检测对象有变化，重复以上操作</li><li>收集所有白色对象（垃圾）。</li><li>通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配。</li></ul><h4 id="1-3-STW（Stop-The-World）"><a href="#1-3-STW（Stop-The-World）" class="headerlink" title="1.3 STW（Stop The World）"></a>1.3 STW（Stop The World）</h4><ul><li>为了避免在 GC 的过程中，对象之间的引用关系发生新的变更，使得GC的结果发生错误（如GC过程中新增了一个引用，但是由于未扫描到该引用导致将被引用的对象清除了），停止所有正在运行的协程。</li><li>STW对性能有一些影响，Golang目前已经可以做到1ms以下的STW。</li></ul><h4 id="1-4-写屏障-Write-Barrier"><a href="#1-4-写屏障-Write-Barrier" class="headerlink" title="1.4 写屏障(Write Barrier)"></a>1.4 写屏障(Write Barrier)</h4><ul><li>为了避免GC的过程中新修改的引用关系到GC的结果发生错误，我们需要进行STW。但是STW会影响程序的性能，所以我们要通过写屏障技术尽可能地缩短STW的时间。</li></ul><p>造成引用对象丢失的条件:</p><p>一个黑色的节点A新增了指向白色节点C的引用，并且白色节点C没有除了A之外的其他灰色节点的引用，或者存在但是在GC过程中被删除了。以上两个条件需要同时满足：满足条件1时说明节点A已扫描完毕，A指向C的引用无法再被扫描到；满足条件2时说明白色节点C无其他灰色节点的引用了，即扫描结束后会被忽略 。</p><p>写屏障破坏两个条件其一即可</p><ul><li>破坏条件1：Dijistra写屏障</li></ul><p>满足强三色不变性：黑色节点不允许引用白色节点 当黑色节点新增了白色节点的引用时，将对应的白色节点改为灰色</p><ul><li>破坏条件2：Yuasa写屏障</li></ul><p>满足弱三色不变性：黑色节点允许引用白色节点，但是该白色节点有其他灰色节点间接的引用（确保不会被遗漏） 当白色节点被删除了一个引用时，悲观地认为它一定会被一个黑色节点新增引用，所以将它置为灰色</p><h4 id="1-5-GC-的触发条件？"><a href="#1-5-GC-的触发条件？" class="headerlink" title="1.5 GC 的触发条件？"></a>1.5 GC 的触发条件？</h4><p>主动触发(手动触发)，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。<br>被动触发，分为两种方式：</p><ul><li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。</li><li>使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。</li></ul><h3 id="2-GPM-调度-和-CSP-模型"><a href="#2-GPM-调度-和-CSP-模型" class="headerlink" title="2. GPM 调度 和 CSP 模型"></a>2. GPM 调度 和 CSP 模型</h3><p><strong>协程的深入剖析</strong></p><h4 id="2-1-CSP-模型？"><a href="#2-1-CSP-模型？" class="headerlink" title="2.1 CSP 模型？"></a>2.1 CSP 模型？</h4><p>CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通过共享内存来通信。用于描述两个独立的并发实体通过共享的通讯 channel (管道)进行通信的并发模型。</p><h4 id="2-2-GPM-分别是什么、分别有多少数量？"><a href="#2-2-GPM-分别是什么、分别有多少数量？" class="headerlink" title="2.2 GPM 分别是什么、分别有多少数量？"></a>2.2 GPM 分别是什么、分别有多少数量？</h4><ul><li>G（Goroutine）：即Go协程，每个go关键字都会创建一个协程。</li><li>M（Machine）：工作线程，在Go中称为Machine，数量对应真实的CPU数（真正干活的对象）。</li><li>P（Processor）：处理器（Go中定义的一个摡念，非CPU），包含运行Go代码的必要资源，用来调度 G 和 M 之间的关联关系，其数量可通过 GOMAXPROCS() 来设置，默认为核心数。</li></ul><p>M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。</p><h4 id="2-3-Goroutine调度策略"><a href="#2-3-Goroutine调度策略" class="headerlink" title="2.3 Goroutine调度策略"></a>2.3 Goroutine调度策略</h4><ul><li>队列轮转：P 会周期性的将G调度到M中执行，执行一段时间后，保存上下文，将G放到队列尾部，然后从队列中再取出一个G进行调度。除此之外，P还会周期性的查看全局队列是否有G等待调度到M中执行。</li><li>系统调用：当G0即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是M的缓存池，也可能是新建的。</li><li>当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。</li></ul><p><img src="https://topgoer.cn/uploads/blog/202111/attach_16b401ee1e07d54d.jpg" alt="null"></p><h3 id="3-CHAN-原理"><a href="#3-CHAN-原理" class="headerlink" title="3. CHAN 原理"></a>3. CHAN 原理</h3><h4 id="3-1-结构体"><a href="#3-1-结构体" class="headerlink" title="3.1 结构体"></a>3.1 结构体</h4><pre class="line-numbers language-none"><code class="language-none">   type hchan struct { qcount   uint  // 队列中的总元素个数 dataqsiz uint  // 环形队列大小，即可存放元素的个数 buf      unsafe.Pointer // 环形队列指针 elemsize uint16  //每个元素的大小 closed   uint32  //标识关闭状态 elemtype *_type // 元素类型 sendx    uint   // 发送索引，元素写入时存放到队列中的位置 recvx    uint   // 接收索引，元素从队列的该位置读出 recvq    waitq  // 等待读消息的goroutine队列 sendq    waitq  // 等待写消息的goroutine队列 lock mutex  //互斥锁，chan不允许并发读写}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-读写流程"><a href="#3-2-读写流程" class="headerlink" title="3.2 读写流程"></a>3.2 读写流程</h4><p><strong>向 channel 写数据:</strong></p><p>若等待接收队列 recvq 不为空，则缓冲区中无数据或无缓冲区，将直接从 recvq 取出 G ，并把数据写入，最后把该 G 唤醒，结束发送过程。</p><p>若缓冲区中有空余位置，则将数据写入缓冲区，结束发送过程。</p><p>若缓冲区中没有空余位置，则将发送数据写入 G，将当前 G 加入 sendq ，进入睡眠，等待被读 goroutine 唤醒。</p><p><strong>从 channel 读数据</strong></p><p>若等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G ，把 G 中数据读出，最后把 G 唤醒，结束读取过程。</p><p>如果等待发送队列 sendq 不为空，说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程。</p><p>如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程。</p><p>将当前 goroutine 加入 recvq ，进入睡眠，等待被写 goroutine 唤醒。</p><p><strong>关闭 channel</strong></p><p>1.关闭 channel 时会将 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。将 sendq 中的 G 全部唤醒，但是这些 G 会 panic。</p><p>panic 出现的场景还有：</p><ul><li><p>关闭值为 nil 的 channel</p></li><li><p>关闭已经关闭的 channel</p></li><li><p>向已经关闭的 channel 中写数据</p></li></ul><h4 id="3-2-无缓冲-Chan-的发送和接收是否同步"><a href="#3-2-无缓冲-Chan-的发送和接收是否同步" class="headerlink" title="3.2 无缓冲 Chan 的发送和接收是否同步?"></a>3.2 无缓冲 Chan 的发送和接收是否同步?</h4><pre class="line-numbers language-none"><code class="language-none">// 无缓冲的channel由于没有缓冲发送和接收需要同步ch := make(chan int)   //有缓冲channel不要求发送和接收操作同步ch := make(chan int, 2)  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>channel 无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据；channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。</p><h4 id="3-3-线程安全"><a href="#3-3-线程安全" class="headerlink" title="3.3 线程安全"></a>3.3 线程安全</h4><p>Channel 可以理解是一个先进先出的队列，通过管道进行通信,发送一个数据到Channel和从Channel接收一个数据都是原子性的。不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。设计Channel的主要目的就是在多任务间传递数据的，本身就是安全的。</p><h4 id="3-4-异步"><a href="#3-4-异步" class="headerlink" title="3.4 异步"></a>3.4 异步</h4><p>Channel是异步进行的, channel存在3种状态：</p><ul><li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li><li>active，正常的channel，可读或者可写</li><li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li></ul><table><thead><tr><th align="left">操作</th><th align="left">一个零值nil通道</th><th align="left">一个非零值但已关闭的通道</th><th align="left">一个非零值且尚未关闭的通道</th></tr></thead><tbody><tr><td align="left">关闭</td><td align="left">产生恐慌</td><td align="left">产生恐慌</td><td align="left">成功关闭</td></tr><tr><td align="left">发送数据</td><td align="left">永久阻塞</td><td align="left">产生恐慌</td><td align="left">阻塞或者成功发送</td></tr><tr><td align="left">接收数据</td><td align="left">永久阻塞</td><td align="left">永不阻塞</td><td align="left">阻塞或者成功接收</td></tr></tbody></table><h3 id="4-context-结构原理"><a href="#4-context-结构原理" class="headerlink" title="4. context 结构原理"></a>4. context 结构原理</h3><h4 id="4-1-用途"><a href="#4-1-用途" class="headerlink" title="4.1 用途"></a>4.1 用途</h4><p>Context（上下文）是Golang应用开发常用的并发控制技术 ，它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。Context 是并发安全的，主要是用于控制多个协程之间的协作、取消操作。</p><p><img src="https://topgoer.cn/uploads/blog/202111/attach_16b40224aa38da32.jpg" alt="null"></p><h4 id="4-2-数据结构"><a href="#4-2-数据结构" class="headerlink" title="4.2 数据结构"></a>4.2 数据结构</h4><p>Context 只定义了接口，凡是实现该接口的类都可称为是一种 context。</p><p>并发控制神器之Context</p><pre class="line-numbers language-none"><code class="language-none">  type Context interface {   Deadline() (deadline time.Time, ok bool)   Done() &lt;-chan struct{}   Err() error   Value(key interface{}) interface{}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>「Deadline」 方法：可以获取设置的截止时间，返回值 deadline 是截止时间，到了这个时间，Context 会自动发起取消请求，返回值 ok 表示是否设置了截止时间。</li><li>「Done」 方法：返回一个只读的 channel ，类型为 struct{}。如果这个 chan 可以读取，说明已经发出了取消信号，可以做清理操作，然后退出协程，释放资源。</li><li>「Err」 方法：返回Context 被取消的原因。</li><li>「Value」 方法：获取 Context 上绑定的值，是一个键值对，通过 key 来获取对应的值。</li></ul><h3 id="5-竞态、内存逃逸"><a href="#5-竞态、内存逃逸" class="headerlink" title="5. 竞态、内存逃逸"></a>5. 竞态、内存逃逸</h3><p><strong>并发控制，同步原语 sync 包</strong></p><h4 id="5-1-竞态"><a href="#5-1-竞态" class="headerlink" title="5.1 竞态"></a>5.1 竞态</h4><p>资源竞争，就是在程序中，同一块内存同时被多个 goroutine 访问。我们使用 go build、go run、go test 命令时，添加 -race 标识可以检查代码中是否存在资源竞争。</p><p>解决这个问题，我们可以给资源进行加锁，让其在同一时刻只能被一个协程来操作。</p><ul><li>sync.Mutex</li><li>sync.RWMutex</li></ul><h4 id="5-2-逃逸分析"><a href="#5-2-逃逸分析" class="headerlink" title="5.2 逃逸分析"></a>5.2 逃逸分析</h4><p><strong>面试官问我go逃逸场景有哪些，我？？？</strong></p><p>「逃逸分析」就是程序运行时内存的分配位置(栈或堆)，是由编译器来确定的。堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。</p><p>逃逸场景：</p><ul><li>指针逃逸</li><li>栈空间不足逃逸</li><li>动态类型逃逸</li><li>闭包引用对象逃逸</li></ul><p>具体内容看下一篇文章</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker基本操作手册</title>
      <link href="/hypo-Z.github.io/2022/02/17/docker-ji-ben-cao-zuo-shou-ce/"/>
      <url>/hypo-Z.github.io/2022/02/17/docker-ji-ben-cao-zuo-shou-ce/</url>
      
        <content type="html"><![CDATA[<h1 id="docker镜像常用命令"><a href="#docker镜像常用命令" class="headerlink" title="docker镜像常用命令"></a>docker镜像常用命令</h1><p>attach   将本地标准输入、输出和错误流附加到正在运行的容器中</p><p>build    从Dockerfile构建一个映像</p><p>commit   从容器的更改中创建一个新映像</p><p>cp     在容器和本地文件系统之间复制文件/文件夹</p><p>create   创建一个新容器</p><p>diff    检查容器文件系统上文件或目录的更改</p><p>events   从服务器获取实时事件</p><p>exec    在正在运行的容器中运行命令</p><p>export   将容器的文件系统导出为tar存档文件</p><p>history   显示图像的历史</p><p>images   图片列表</p><p>import   从tarball导入内容以创建文件系统映像</p><p>info    显示整个系统的信息</p><p>inspect   返回Docker对象的底层信息</p><p>kill    杀死一个或多个正在运行的容器</p><p>load    从tar存档或STDIN加载图像</p><p>login    登录到Docker注册表</p><p>logout   从Docker注册表注销</p><p>logs    获取容器的日志</p><p>pause    暂停一个或多个容器中的所有进程</p><p>port    列出容器的端口映射或特定映射</p><p>ps     列表容器</p><p>pull    从注册表中提取映像或存储库</p><p>push    将映像或存储库推入注册表</p><p>rename   重命名一个容器</p><p>restart   重新启动一个或多个容器</p><p>rm     移除一个或多个容器</p><p>rmi     删除一个或多个图像</p><p>run     在新容器中运行命令<br>常用设置参数：</p><ul><li>-rm 即运行结束后自动删除容器</li><li>-d 后台运行</li><li>-p 运行端口</li><li>-l 连接另一个容器</li></ul><p>save    将一个或多个图像保存到tar存档文件(默认情况下流到STDOUT)</p><p>search   在Docker集线器中搜索图像</p><p>start    启动一个或多个停止的容器</p><p>stats    显示容器资源使用统计数据的实时流</p><p>stop    停止一个或多个正在运行的容器</p><p>tag     创建一个引用SOURCE_IMAGE的标记TARGET_IMAGE</p><p>top     显示容器的运行进程</p><p>unpause   在一个或多个容器中暂停所有进程</p><p>update   更新一个或多个容器的配置</p><p>version   显示Docker版本信息</p><p>wait    阻塞，直到一个或多个容器停止，然后打印它们的退出代码</p><h1 id="docker容器基本操作"><a href="#docker容器基本操作" class="headerlink" title="docker容器基本操作"></a>docker容器基本操作</h1><p>一.宿主机的内容拷贝到启动的docker容器中<br>1.查看docker容器状态</p><pre class="line-numbers language-none"><code class="language-none">docker ps-a <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.如果没有启动docker容器则启动docker容器</p><pre class="line-numbers language-none"><code class="language-none">docker start 容器名或者容器ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.进入容器</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it 容器名/容器ID  /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.克隆宿主机会话并在宿主机创立文件<br>(1)进入容器的根目录</p><pre class="line-numbers language-none"><code class="language-none">cd /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(2)创建jhj文件,并写入内容123456</p><pre class="line-numbers language-none"><code class="language-none">echo 123456 &gt; jhj<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)拷贝到docker容器中</p><pre class="line-numbers language-none"><code class="language-none">docker cp 要拷贝的宿主机文件或目录 容器名称:容器文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>二、查看容器详情<br>1.查看容器运行内部细节，比如可看容器的IP</p><pre class="line-numbers language-none"><code class="language-none">docker inspect 容器名：容器ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.查看容器IP</p><pre class="line-numbers language-none"><code class="language-none">docker inspect --format='{{.NetworkSettings.IPAddress}}` 容器名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.删除容器注意只能删除停止的容器</p><pre class="line-numbers language-none"><code class="language-none">docker rm `docker ps -a -q`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.清理所有处于终止状态的容器:</p><pre class="line-numbers language-none"><code class="language-none">docker container prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="push至本地镜像仓库"><a href="#push至本地镜像仓库" class="headerlink" title="push至本地镜像仓库"></a>push至本地镜像仓库</h1><p>1.查看本地镜像</p><pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.给镜像打tag标签</p><pre class="line-numbers language-none"><code class="language-none">docker tag 原镜像名:版本号 本地仓库名/仓库管理者/原镜像名:版本号 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.验证镜像标签</p><pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.推送</p><pre class="line-numbers language-none"><code class="language-none">docker push 本地仓库名/仓库管理者/原镜像名:版本号 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愿你归来再少年</title>
      <link href="/hypo-Z.github.io/2022/02/16/35-yuan-ni-gui-lai-zai-shao-nian/"/>
      <url>/hypo-Z.github.io/2022/02/16/35-yuan-ni-gui-lai-zai-shao-nian/</url>
      
        <content type="html"><![CDATA[<p>我叫天客，我的背包是我做的自然科学博物馆，这是在骑行的林区路上和徒步的时候大江大河里面经常能捡到的东西，都是一些化石、贝壳之类的，我把它们做成了手链纪念品，供经过的旅人们挑选。</p><p>五六岁我就敢穿越这种森林，去山区里去寻鸟，煮两个青蛙吃，每次回来都会被打脚，在学校里时，跟学生们出去玩，个个都说是我带他们出去的。</p><p>我要去翻蛐蛐，我要去逮蜻蜓，我还要去偷山鸟回来，我还要去沟里面，河里面，那些山青青里面，到了山上，去爬悬崖，我还要走得更远我才满意。</p><p>因为触犯了人间的规矩，没学过也没人教过我。我的父母，她们是艺术家，画家，他们每一步都是规矩，在他们的观念和画里不能有一丝败笔，校长也不允许留下几个成绩不及格的有坏习惯的学生。</p><p>我不喜欢规矩，跟人打交道要规矩，在学校要规矩，在城市要规矩，在庙里遇到了一个和尚说：这是一步一规矩的地方。</p><p>这个地方这么多规矩，不如顺着这条河，顺着这个山峡一直穿越出去，看看山那边是什么样的，在大江大河里，在大石头上睡一觉，就又都忘记掉了。</p><p>我非常喜欢跟人打交流，但要讲规矩。我又不懂规矩，所以我就轻轻的打一下就好，然后就保持距离就完了，望着好看的女生就笑一笑，远远的望着我就觉得非常满足了。</p><p>有一次我遇到了一位男孩，大约有三十岁，我跟他说：“你是我交的最大的朋友”，他说怎么可能，我说因为平时只有小孩子才跟我交流。所以在卖给孩子们东西时，我心里想着把我身上的所有东西都给孩子我都不眨一下眼，因为我觉得我们是同一类人。</p><p>在那些无人区上，那些戈壁滩上，根本想不起还有人类，我只想着明天的草去哪里拔一包装满。一天到晚，找到的小草就手心里一小把，但是刚好够吃，我也觉得是天堂了。</p><p>到了一个新的火山口，一根草都没有，一个蚂蚁没有，一个人没有，一个牛羊没有，一个村庄也没有。只有空气和沙和石头。有时候看到的是一眼看不到边际的荒地，那这片荒地便是我的天堂，取了一把干草吃了，哎呀，又可以往前走了！又可以看远方天边的极光去了，那景象无与伦比，延绵千里的雪山，一眼看不到边的新疆的雪山。</p><p>登山回来，我最高兴的事就是看见一个人，给我激动的，然后他们跟我买东西，我就非常高兴，因为我知道我卖到钱又可以买到吃的，背的。然后我再也不怕我走的有多远了。</p><p>——天客</p><p>——一平凡但不孤独的旅行老人</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《天才在左，疯子在右》读后感</title>
      <link href="/hypo-Z.github.io/2022/02/12/34-tian-cai-zai-zuo-feng-zi-zai-you-du-hou-gan/"/>
      <url>/hypo-Z.github.io/2022/02/12/34-tian-cai-zai-zuo-feng-zi-zai-you-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="《天才在左，疯子在右》读后感"><a href="#《天才在左，疯子在右》读后感" class="headerlink" title="《天才在左，疯子在右》读后感"></a><strong>《天才在左，疯子在右》读后感</strong></h1><p><strong>真理属于人类，谬误属于时代。 —————歌德</strong></p><ul><li><p>维基百科：<strong>天才</strong>（英语：Genius）是指某人展现了卓越的智力、创意。而此创意则通常指在某一或某些领域展现前所未有的洞察力。有天才在风格和独创性规则创造性的高效率，普遍性。在科学上，对天才两个字并没有准确的定义。而天才这个用语模棱两可，也依旧是争论性的议题。天才可以形容一个人的某种特殊才能，也可以用在通晓各方面学问的博学家（通才），例如：亚里士多德、莱布尼兹、艾萨克·牛顿、列奥那多·达芬奇、高斯、尤拉、庞加莱，或是一个领域的佼佼者，例如：阿尔伯特·爱因斯坦，张爱玲，史蒂芬·霍金和莫札特。</p></li><li><p>百度百科：<strong>疯子</strong>，汉语词语，常比喻人的性格、外貌，多用于贬义。有时作为褒义词，表示对人敢打敢拼的一股闯劲的肯定。褒扬大无畏的牺牲精神、奋斗精神、奉献精神。精神病（或称做精神疾病、心理疾病、心理病），主要是一组以表现在行为、心理活动上的紊乱为主的神经系统疾病。研究所得到的结果认为主要是由于家庭、社会环境等外在原因，和患者自身的生理遗传因素、神经生化因素等内在原因相互作用所导致的心理活动、行为、及其神经系统功能紊乱为主要特征的病症。 [1]</p></li></ul><p>从释义解释的天才与疯子有巨大的区别，我理解的天才是在某一领域做到金字塔尖或他的某方面常人难以企及并且比别人更早的达到那个水平；而疯子我理解为你会在某些事走向极端化，死钻牛角尖难以自拔，或是精神上出现疾病以致常人难以理解。</p><p>《天才在左，疯子在右》这本书的作者是一个普通的人，就像许多人一样对这个世界有着许多的疑问难以去解答，但他一次与精神病人的对话使他对精神病人这个群体感到兴趣，随后就与多个病人进行沟通了解，并将对话的内容写成了这本书，带我们可以去了解到精神病人那些奇怪（在我眼里是“奇妙”）的视角看到的世界。</p><p>其中几个让我影响深刻的对话：</p><p>1.<strong>棋子</strong></p><pre class="line-numbers language-none"><code class="language-none">你：“你玩过象棋吧，还有扑克牌？那些游戏的乐趣就在于规则，各种不同的组合，根据各种不同的情况能有千变万化的结果，而且很多事情微妙到没办法形容。国际象棋起源于印度，我不熟悉那个最初的应用，所以不说那个，说中国象棋。中国象棋最初的目的是推演，其实就是古代的实战沙盘。每种不同的棋子，代表的是一种兵种，而且还包括军队性质。象棋里的‘俥’，我费了好大劲才查到，代表是精锐军。那个部队是最好用的，但不是轻易用的，虽然直来直去，但想操控自如可不是一般棋手能做到的。不过，象棋只是打仗而已，不是最精妙的。”我：“那什么是最精妙的？”他：“最精妙是围棋。”我：“为什么？”他：“围棋代表的是真正的智慧！围棋可以说是社会的浓缩，我不能理解围棋是怎么发明的，所以民间对于围棋的起源，有很大的传说性质。你想象一下，各19条平行线交叉，361个点，黑白一共360个棋子，没有高低贵贱之分，完全依靠操纵者的智慧。或者落手绵绵，或者落手铿锵，或者匪夷所思，或者杀声四起。你以为天下在握的时候，突然四面楚歌，生死难卜啊。这是什么？不就是社会吗？依靠的是什么？一个规则，一个简单的规则。棋子呢？就是人。大家都是一样的状态。但是落点决定了你的与众不同，而且每一个都是与众不同！这就是社会啊。我一直坚信，所有的历史、所有的辉煌，都是普通人创造的，而不是那些天才，不是那些聪明人。”我：“有道理是有道理，但是好像你在说宿命论。落点不是取决于自己，而是取决于操纵的那只手。”他：“才不是呢。每一个棋子，都有自己特定的位置，有自己特定的功能，少了一个，会出很大的问题，少了一个甚至全盘皆输。你作为一个棋子，要真正看清自己的位置，你才会明白到底怎么回事儿，也就是所谓全局。我再说一遍：我坚信所有的历史、所有的辉煌，绝对不是聪明人创造出来的，都是普通人创造出来的。而聪明人需要做的只是看清问题所在，顺应一个潮流罢了。实际上，那个聪明人即使不存在，也会有其他聪明人取代。但是，那些普通人，是绝对无法取代的。”  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.<strong>四维虫子</strong></p><pre class="line-numbers language-none"><code class="language-none">我：“可是你怎么能证实你的感觉是正确的，或者说你怎么能证明有谁给你感觉了呢？”他冷冷地看着我：“不用很远，只倒退一百多年，你对一个当时顶尖的物理学家说你拿着一个没有巴掌大、没一本书厚的东西就可以跟远方的人通话，而这要靠围着地球转的卫星和你手机里那个跟指甲盖一样大小的卡片；你可以坐在一个小屏幕前跟千里之外的陌生人交谈，而且还不需要任何连接线；你看地球另一边的球赛只需要按下电视遥控器。他会怎么想？他会认为你一定是疯子！因为那超出当时任何学科的范畴了，列在不可理喻的行列，对吗？”我：“但你说的是感觉。”他：“那只是个词，发现量子之前没人知道量子该叫什么，大多叫作能量什么的。你的思维，还是惯有的物质世界，那是三维的！我要告诉你的是‘四维’，非得用三维框架来描述，我觉得我们没办法沟通。”他再次表示我该滚蛋了。量子物理学教授：“你能告诉我那个四维生物还告诉你什么了吗？”“是绝对四维生物。”他不耐烦地纠正。量子物理学教授：“对，它还给你什么感觉了？”他：“它对我的看法。”我：“是怎么样的呢？”他严肃地转向我：“应该是我们，是对我们的看法。我们对它来说不是现在的样子，因为它的眼界跨越了时间，所以在它看来，我们都是跟蠕动的虫子一样的东西。”我忍不住回头和量子物理学教授对看了一眼。他：“你可以想象得出来，跨越时间地看，我们是一个很长很长的虫子怪物，从床上延伸到大街上，延伸到学校，延伸到公司，延伸到商场，延伸到好多地方。因为我们的动作在每个时间段都是不同的，所以跨越时间来看，我们都是一条条虫子。从某一个时间段开始，到某一个时间段结束。”我和量子物理学教授都愣愣地听着他说。他：“绝对四维生物可以先看到我们死亡，再看到我们出生，没有前后因果。其实这个我很早就理解了：时间不是流逝的，流逝的是我们。”他一字一句地说完后，任凭我们怎么问也不再回答了。那次谈话基本上还是以失败告终。不久后，少年接受了一次特地为他安排的量子物理考试，结果很糟。不知道为什么，我听了有些失望。如果，他真的是个天才，那么他也只能是一百年后，甚至更遥远未来的天才，而不属于我们这个时代——我是说时间段落？也许吧。我至今依旧很想知道，那个所谓的“绝对四维生物”是什么样子。它恐怖吗？我可能永远没办法知道了，即便那是真的。写到这里的时候，莫名地想起歌德说过的一句话：真理属于人类，谬误属于时代。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.<strong>刹那</strong></p><pre class="line-numbers language-none"><code class="language-none">他：“人死前，都会把自己的一生重新经历一遍，对吧？”我：“听说过。”他：“如果现在就是呢？”我：“嗯？你是说……”他：“所以我刚才问你，你有没有过似曾相识的时候？”我愣住了。他：“是的，现在就是！”我被这个想法吓了一跳：“可是……不对吧……从时间上看也不对……吧。”他：“如果你置身其中是无法正确认知到时间流的，不过从感觉上依然能感觉到时间的不稳定性。”我：“我不是太明白，我指时间不稳定性这个说法。”他：“你有没有时间越过越快的感觉？”我仔细回想了一下，好像有。他：“你应该有那种感觉吧，小时候时间似乎很慢、非常慢，但越大时间过得越快，是这样吧？”我：“对，不过，我觉得还是不大对劲……你说的是死前回溯那种……嗯……毕竟只是一刹那，怎么可能会是现在这种当下的感受呢？”他绝望地摇摇头：“在回溯的幻觉中，时间不重要。重要的是对自己一生的体会，回溯结束的时候，就会回到现实——死亡。”我：“可是……”他：“没有可是，实际就是这样的。第一，你似曾相识的感觉是真实的，而不是错觉，因为你自己刚才都承认了，不仅仅是熟悉，甚至还能预知到下一秒即将发生什么，就是说你真的经历过而不是一时的混乱。第二，时间流的不稳定性，时间只是相对的一个概念，并不是一成不变的，过去只是一瞬间，但是你的确都经历过，只有当下是最漫长的。因此我说很有可能我们现在都身处在死亡回溯中——那个刹那。”我：“话是这么说……不过有个悖论存在。”他：“什么悖论？”我：“许多人都有过似曾相识的感受，而且很多人都有时间流不稳定的感受，那他们都是身处在死亡回溯中吗？死亡回溯是相互交集的吗？”他：“每个人只是回溯自己的经历，与别人的交集只是曾经发生过的记忆，当然也就是从自己的角度。我们都是真实的，但现在，没法确定是你的记忆还是我的记忆，这种事情没有办法能证实，除非我们中的一个回溯结束，离开回忆，面对死亡。也许还要很久，也许就是下一秒。”我突然觉得很压抑。过了一会儿，他盯着我的眼睛一字一句地说：“在真实来临之前，你无法证明自己不在虚幻中。”<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这几个故事中，那些被人称为精神病人的思想是令我感到惊讶的，因为他们所想的都是我们常人难以想象的事物，所以如果跟人说的话就会被当成精神病人，但他们所描述的事件的逻辑性、思维性确实很完整，令人无法反驳。</p><p>在作者所遇见的病人中，有的就是钻牛角尖，有的是精神分裂，有的是想的事情太深难以自拔而造成人们的难以理解。</p><p>读完本书，作者带我进入到一个完全不同的世界，去认识的那些常人难以理解的<strong>“怪人”</strong>的思想，使我认识的在事情的认知和那些不同寻常的人的区别，作者的核心理念就是：我们认知的疯子与天才其实只有一线之隔，他们的共同点都是在某方面与常人有明显差距或不相同的，而他们的这些突出能力是否能被常人接受则与现实所影响。</p><p>就像梵高一样，在他所处的时代，他的画作并不受当时人们所接受，时过境迁他的画被奉为天才所作。所以天才只是生不逢时，常人难以理解，或许多年以后的人在看作者所写的书会觉得在正常不过了。。。</p><p>总之，非常推荐大家去阅读原书。。。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
            <tag> 好书推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列、堆、栈、堆栈的区别与defer的关系</title>
      <link href="/hypo-Z.github.io/2022/02/12/33-dui-lie-dui-zhan-dui-zhan-de-qu-bie-yu-defer-de-guan-xi/"/>
      <url>/hypo-Z.github.io/2022/02/12/33-dui-lie-dui-zhan-dui-zhan-de-qu-bie-yu-defer-de-guan-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Go的堆栈"><a href="#Go的堆栈" class="headerlink" title="Go的堆栈"></a>Go的堆栈</h2><p>在理解Go的堆栈分配前,我们先理解下什么是堆栈？在计算机中堆栈的概念分为：数据结构的堆栈和内存分配中堆栈。</p><h4 id="数据结构的堆栈："><a href="#数据结构的堆栈：" class="headerlink" title="数据结构的堆栈："></a>数据结构的堆栈：</h4><ul><li><p>堆: 堆可以被看成是一棵树，如：堆排序。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p></li><li><p>栈: 一种先进后出的数据结构。</p></li></ul><h4 id="在内存分配中的堆和栈"><a href="#在内存分配中的堆和栈" class="headerlink" title="在内存分配中的堆和栈:"></a>在内存分配中的堆和栈:</h4><ul><li><p>栈（操作系统）:由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p></li><li><p>堆（操作系统）:一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。</p></li></ul><h4 id="堆栈缓存方式"><a href="#堆栈缓存方式" class="headerlink" title="堆栈缓存方式"></a>堆栈缓存方式</h4><ul><li><p>栈使用的是一级缓存, 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</p></li><li><p>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p></li></ul><h4 id="变量是堆（heap）还是堆栈（stack）"><a href="#变量是堆（heap）还是堆栈（stack）" class="headerlink" title="变量是堆（heap）还是堆栈（stack）"></a>变量是堆（heap）还是堆栈（stack）</h4><p>官方给出的解释如下:</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">How do I know whether a variable is allocated on the heap or the stack?From a correctness standpoint, you don't need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function's stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面可以了解到, 您不需要知道。Go中的每个变量都存在，只要有对它的引用即可。实现选择的存储位置与语言的语义无关。</p><p>存储位置确实会影响编写高效的程序。如果可能，Go编译器将为该函数的堆栈帧中的函数分配本地变量。但是，如果编译器在函数返回后无法证明变量未被引用，则编译器必须在垃圾收集堆上分配变量以避免悬空指针错误。此外，如果局部变量非常大，将它存储在堆而不是堆栈上可能更有意义。</p><p>在当前的编译器中，如果变量具有其地址，则该变量是堆上分配的候选变量。但是，基础的逃逸分析可以将那些生存不超过函数返回值的变量识别出来，并且因此可以分配在栈上。</p><p>Go的编译器会决定在哪(堆or栈)分配内存，保证程序的正确性。</p><h4 id="Go的堆栈分配"><a href="#Go的堆栈分配" class="headerlink" title="Go的堆栈分配"></a>Go的堆栈分配</h4><ul><li>每个goroutine维护着一个栈空间，默认最大为4KB.</li><li>当goroutine的栈空间不足时，golang会调用<code>runtime.morestack</code>(汇编实现：asm_xxx.s)来进行动态扩容.</li><li>连续栈是当栈空间不足的时候申请一个2倍于当前大小的新栈，并把所有数据拷贝到新栈,接下来的所有调用执行都发生在新栈上.</li><li>每个function维护着各自的栈帧(stack frame)，当function退出时会释放栈帧.</li></ul><h4 id="Go-function内的栈操作"><a href="#Go-function内的栈操作" class="headerlink" title="Go function内的栈操作"></a>Go function内的栈操作</h4><p>用一段简单的代码来说明Go函数调用及传参时的栈操作：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span>p <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     c <span class="token operator">:=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>     <span class="token boolean">_</span> <span class="token operator">=</span> c<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行<code>go tool compile -S main.go</code>生成汇编，并截取其中的一部分来说明一下程序调用时的栈操作.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token string">""</span><span class="token punctuation">.</span>g t<span class="token operator">=</span><span class="token number">1</span> size<span class="token operator">=</span><span class="token number">17</span> args<span class="token operator">=</span><span class="token number">0x10</span> locals<span class="token operator">=</span><span class="token number">0x0</span>    <span class="token comment">// 初始化函数的栈地址</span>    <span class="token comment">// 0-16表示函数初始地址为0，数据大小为16字节(input: 8字节，output: 8字节)</span>    <span class="token comment">// SB是函数寄存器</span>    <span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">)</span>  TEXT    <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> $<span class="token number">0</span><span class="token operator">-</span><span class="token number">16</span>    <span class="token comment">// 函数的gc收集提示。提示0和1是用于局部函数调用参数，需要进行回收</span>    <span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">)</span>  FUNCDATA    $<span class="token number">0</span><span class="token punctuation">,</span> gclocals·<span class="token function">aef1f7ba6e2630c93a51843d99f5a28a</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>    <span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">)</span>  FUNCDATA    $<span class="token number">1</span><span class="token punctuation">,</span> gclocals·<span class="token function">33cdeccccebe80329f1fdbee7f5874cb</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>    <span class="token comment">// FP(frame point)指向栈底</span>    <span class="token comment">// 将FP+8位置的数据(参数p)放入寄存器AX</span>    <span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>  MOVQ    <span class="token string">""</span><span class="token punctuation">.</span>p<span class="token operator">+</span><span class="token function">8</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span><span class="token punctuation">,</span> AX    <span class="token number">0x0005</span> <span class="token number">00005</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>  MOVQ    <span class="token punctuation">(</span>AX<span class="token punctuation">)</span><span class="token punctuation">,</span> AX    <span class="token comment">// 寄存器值自增</span>    <span class="token number">0x0008</span> <span class="token number">00008</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>  INCQ    AX    <span class="token comment">// 从寄存器中取出值，放入FP+16位置(返回值)</span>    <span class="token number">0x000b</span> <span class="token number">00011</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>  MOVQ    AX<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span>~r1<span class="token operator">+</span><span class="token function">16</span><span class="token punctuation">(</span>FP<span class="token punctuation">)</span>    <span class="token comment">// 返回，返回后程序栈的空间会被回收</span>    <span class="token number">0x0010</span> <span class="token number">00016</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">)</span>  RET    <span class="token number">0x0000</span> <span class="token number">48</span> <span class="token number">8</span>b <span class="token number">44</span> <span class="token number">24</span> <span class="token number">08</span> <span class="token number">48</span> <span class="token number">8</span>b <span class="token number">00</span> <span class="token number">48</span> ff c0 <span class="token number">48</span> <span class="token number">89</span> <span class="token number">44</span> <span class="token number">24</span> <span class="token number">10</span>  H<span class="token punctuation">.</span>D$<span class="token punctuation">.</span>H<span class="token punctuation">.</span><span class="token punctuation">.</span>H<span class="token punctuation">.</span><span class="token punctuation">.</span>H<span class="token punctuation">.</span>D$<span class="token punctuation">.</span>    <span class="token number">0x0010</span> c3                                               <span class="token punctuation">.</span><span class="token string">""</span><span class="token punctuation">.</span>main t<span class="token operator">=</span><span class="token number">1</span> size<span class="token operator">=</span><span class="token number">32</span> args<span class="token operator">=</span><span class="token number">0x0</span> locals<span class="token operator">=</span><span class="token number">0x10</span>    <span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>  TEXT    <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span><span class="token punctuation">,</span> $<span class="token number">16</span><span class="token operator">-</span><span class="token number">0</span>    <span class="token number">0x0000</span> <span class="token number">00000</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>  SUBQ    $<span class="token number">16</span><span class="token punctuation">,</span> SP    <span class="token number">0x0004</span> <span class="token number">00004</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>  MOVQ    BP<span class="token punctuation">,</span> <span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>    <span class="token number">0x0009</span> <span class="token number">00009</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>  LEAQ    <span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> BP    <span class="token number">0x000e</span> <span class="token number">00014</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>  FUNCDATA    $<span class="token number">0</span><span class="token punctuation">,</span> gclocals·<span class="token function">33cdeccccebe80329f1fdbee7f5874cb</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>    <span class="token number">0x000e</span> <span class="token number">00014</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">)</span>  FUNCDATA    $<span class="token number">1</span><span class="token punctuation">,</span> gclocals·<span class="token function">33cdeccccebe80329f1fdbee7f5874cb</span><span class="token punctuation">(</span>SB<span class="token punctuation">)</span>    <span class="token comment">// SP(stack point)指向栈顶</span>    <span class="token comment">// 把4存入SP的位置</span>    <span class="token number">0x000e</span> <span class="token number">00014</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">)</span>  MOVQ    $<span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span>    <span class="token comment">// 这里会看到没有第9行`call g()`的调用出现，这是因为go汇编编译器会把一些短函数变成内嵌函数，减少函数调用</span>    <span class="token number">0x0016</span> <span class="token number">00022</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">)</span> MOVQ    <span class="token function">8</span><span class="token punctuation">(</span>SP<span class="token punctuation">)</span><span class="token punctuation">,</span> BP    <span class="token number">0x001b</span> <span class="token number">00027</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">)</span> ADDQ    $<span class="token number">16</span><span class="token punctuation">,</span> SP    <span class="token number">0x001f</span> <span class="token number">00031</span> <span class="token punctuation">(</span>test_stack<span class="token punctuation">.</span><span class="token keyword">go</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">)</span> RET<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>事实上，即便我定义了指针调用，以上的数据也都是在栈上拷贝的；那么Golang中的数据什么时候会被分配到堆上呢？</p><h4 id="Golang逃逸分析"><a href="#Golang逃逸分析" class="headerlink" title="Golang逃逸分析"></a>Golang逃逸分析</h4><ul><li>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，用于分析在程序的哪些地方可以访问到指针。</li><li>Golang在编译时的逃逸分析可以减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除。</li><li>如果你定义的对象的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行，提高效率。</li></ul><p>还是上面的那段程序代码，我们可以执行<code>go build -gcflags '-m -l' test_stack.go</code>来进行逃逸分析，输出结果如下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># command-line-arguments</span>./test_stack.go:3: g p does not escape./test_stack.go:9: main <span class="token operator">&amp;</span>c does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以看到，对象c是没有逃逸的，还是分配在栈上。</p><p>即便在一开始定义的时候直接把c定义为指针：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span>p <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">*</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">4</span>    <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逃逸分析的结果仍然不会改变:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># command-line-arguments</span>./test_stack.go:3: g p does not escape./test_stack.go:8: main new<span class="token punctuation">(</span>int<span class="token punctuation">)</span> does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>那么，在什么时候指针对象才会逃逸呢？</p><p>那就是在按值传递和按址传递时候.</p><ul><li>按值传递</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span>p <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    ret <span class="token operator">:=</span> p <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> ret<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token number">4</span>    <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回值ret是按值传递的，执行的是栈拷贝，不存在逃逸.</p><ul><li>按址传递</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span>p <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    ret <span class="token operator">:=</span> <span class="token operator">*</span>p <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token number">4</span>    <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>返回值&amp;ret是按址传递，传递的是指针对象，发生了逃逸，将对象存放在堆上以便外部调用.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># command-line-arguments</span>./test_stack.go:5:9: <span class="token operator">&amp;</span>ret escapes to heap./test_stack.go:4:14: moved to heap: ret./test_stack.go:3:17: g p does not escape./test_stack.go:9:10: main new<span class="token punctuation">(</span>int<span class="token punctuation">)</span> does not escape<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>golang只有在function内的对象可能被外部访问时，才会把该对象分配在堆上.</p><ul><li>在g()方法中，ret对象的引用被返回到了方法外，因此会发生逃逸；而p对象只在g()内被引用，不会发生逃逸.</li><li>在main()方法中，c对象虽然被g()方法引用了，但是由于引用的对象c没有在g()方法中发生逃逸，因此对象c的生命周期还是在main()中的，不会发生逃逸.</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">type</span> Result <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Data <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">g</span><span class="token punctuation">(</span>p <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>Result <span class="token punctuation">{</span>    <span class="token keyword">var</span> ret Result    ret<span class="token punctuation">.</span>Data <span class="token operator">=</span> p    <span class="token keyword">return</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token number">4</span>    <span class="token boolean">_</span> <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>逃逸分析结果</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># command-line-arguments</span>./test_stack.go:10:9: <span class="token operator">&amp;</span>ret escapes to heap./test_stack.go:8:6: moved to heap: ret./test_stack.go:7:17: leaking param: p to result ~r1 <span class="token assign-left variable">level</span><span class="token operator">=</span>-1./test_stack.go:14:10: new<span class="token punctuation">(</span>int<span class="token punctuation">)</span> escapes to heap<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以看到，ret和2.2中一样，存在外部引用，发生了逃逸.</li><li>由于<code>ret.Data</code>是一个指针对象，p赋值给<code>ret.Data</code>后，也伴随p发生了逃逸.</li><li>main()中的对象c，由于作为参数p传入g()后发生了逃逸，因此c也发生了逃逸.</li><li>当然，如果定义<code>ret.Data</code>为int(instead of *int)的话，对象p也是不会逃逸的(执行了拷贝).</li></ul><h4 id="开发建议大对象按址传递，小对象按值传递"><a href="#开发建议大对象按址传递，小对象按值传递" class="headerlink" title="开发建议大对象按址传递，小对象按值传递"></a>开发建议大对象按址传递，小对象按值传递</h4><ul><li>按址传递更高效，按值传递更安全(from William Kennedy).</li><li>90%的bug都来自于指针调用.</li></ul><h4 id="初始化一个结构体，使用引用的方式来传递指针"><a href="#初始化一个结构体，使用引用的方式来传递指针" class="headerlink" title="初始化一个结构体，使用引用的方式来传递指针"></a>初始化一个结构体，使用引用的方式来传递指针</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">r</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Result<span class="token punctuation">{</span>    <span class="token keyword">var</span> ret Result    ret<span class="token punctuation">.</span>Data <span class="token operator">=</span> <span class="token operator">...</span>    <span class="token operator">...</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>ret<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有返回ret对象的引用时才会把对象分配在堆上，我们不必要在一开始的时候就显式地把ret定义为指针.</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ret <span class="token operator">=</span> <span class="token operator">&amp;</span>Result<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token keyword">return</span> ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对阅读代码也会容易产生误导.****</p><h2 id="队列、堆、栈、堆栈的区别"><a href="#队列、堆、栈、堆栈的区别" class="headerlink" title="队列、堆、栈、堆栈的区别"></a>队列、堆、栈、堆栈的区别</h2><h3 id="堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）"><a href="#堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）" class="headerlink" title="堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）"></a>堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）</h3><h3 id="队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）"><a href="#队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）" class="headerlink" title="队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）"></a>队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）</h3><p>进程中每个线程都有自己的<strong>堆栈</strong>，这是一段线程创建时保留下的地址区域。我们的“<strong>栈内存</strong>”即在此。<br>至于“<strong>堆</strong>”内存，我个人认为在未用new定义时，<strong>堆</strong>应该就是未“保留”未“提交”的自由空间，new的功能是在这些自由空间中保留（并提交）出一个地址范围。</p><p><strong>栈</strong>(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。在编程中，例如C/C++中，所有的局部变量都是从<strong>栈</strong>中分配内存空间，实际上也不是什么分配，只是从<strong>栈顶</strong>向上用就行，在退出函数的时候，只是修改<strong>栈指针</strong>就可以把<strong>栈</strong>中的内容销毁，所以速度最快。</p><p><strong>堆</strong>（Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程，C/C++分别用malloc/New请求分配Heap，用free/delete销毁内存。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用<strong>堆</strong>的效率低的多！但是<strong>堆</strong>的好处是可以做的很大，C/C++对分配的Heap是不初始化的。</p><p>在Java中除了简单类型（int,char等）都是在<strong>堆</strong>中分配内存，这也是程序慢的一个主要原因。但是跟C/C++不同，Java中分配Heap内存是自动初始化的。在Java中所有的对象（包括int的wrapper  Integer）都是在<strong>堆</strong>中分配的，但是这个对象的引用却是在Stack中分配。也就是说在建立一个对象时从两个地方都分配内存，在Heap中分配的内存实际建立这个对象，而在Stack中分配的内存只是一个指向这个<strong>堆</strong>对象的指针（引用）而已。</p><p><strong>堆</strong>是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{<strong>堆</strong>是指程序运行是申请的动态内存，而栈只是指一种使用<strong>堆</strong>的<strong>方法</strong>(即<strong>先进后出</strong>)。}</p><p><strong>栈</strong>是先进后出的，但是于<strong>堆</strong>而言却没有这个特性，两者都是存放临时数据的地方。 对于<strong>堆</strong>，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。</p><p>###在同一个goroutine中：多个defer的调用栈原理是什么？</p><p>defer函数是如何调用的?</p><p>为了探究其中的奥秘我准备了如下代码：</p><pre class="line-numbers language-none"><code class="language-none">package mainimport "fmt"func main() {xx()}func xx() {defer aaa(100, "hello aaa")defer bbb("hello bbb")return}func aaa(x int, arg string) {fmt.Println(x, arg)}func bbb(arg string) {fmt.Println(arg)}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><p>bbb</p><p>100 hello aaa</p><p>从输出结果看很像栈的数据结构特性：后进先出(LIFO).</p><p>对于如下所示的 defer 语句</p><pre class="line-numbers language-none"><code class="language-none">func x() {.......defer y(......).......}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，编译器会把 defer 语句翻译成对 deferproc 函数的调用，deferproc 负责构造一个用来保存 y 函数的地址以及 y 函数需要用到的参数的 _defer 结构体对象，并把该对象加入当前 goroutine 对应的 g 结构体对象的 _defer 链表表头；</p><p>然后，编译器会在 x 函数的结尾处插入对 deferreturn 的调用，deferreturn 负责递归的调用 x 函数通过 defer 语句注册的函数。</p><p>总体说来，在不考虑 panic/recover 的情况下，go语言对 defer 的实现机制还是比较简单，但其具体实现细节还是有很多地方值得我们仔细思考和学习的。</p><p>最后，defer函数虽然方便，但是需要有额外的运行开销，在使用时需要进行取舍，尤其是具有多个参数的时候，会发生多次内存拷贝：</p><p>runtime.deferproc执行之前：移动到栈中<br>runtime.deferproc执行过程中，拷贝_defer之后<br>runtime.deferreturn执行时，移动到栈中</p><p>update：go1.13对defer进行了优化，如果_defer没有发生逃逸，则将其分配在栈上，可以提高30%的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go程序员开发效率神器汇总！</title>
      <link href="/hypo-Z.github.io/2022/02/09/go-cheng-xu-yuan-kai-fa-xiao-lu-shen-qi-hui-zong/"/>
      <url>/hypo-Z.github.io/2022/02/09/go-cheng-xu-yuan-kai-fa-xiao-lu-shen-qi-hui-zong/</url>
      
        <content type="html"><![CDATA[<p>neon 是鹅厂的一位资深后台开发工程师，多年工作下来他总结了很多效率神器，今天分享给大家。</p><h2 id="一-开发工具"><a href="#一-开发工具" class="headerlink" title="一. 开发工具"></a>一. 开发工具</h2><p>1)sql2go<br>用于将 sql 语句转换为 golang 的 struct. 使用 ddl 语句即可。<br>例如对于创建表的语句: show create table xxx. 将输出的语句，直接粘贴进去就行。<br><a href="http://stming.cn/tool/sql2go.html">http://stming.cn/tool/sql2go.html</a></p><p>2)toml2go<br>用于将编码后的 toml 文本转换问 golang 的 struct.<br><a href="https://xuri.me/toml-to-go/">https://xuri.me/toml-to-go/</a></p><p>3)curl2go<br>用来将 curl 命令转化为具体的 golang 代码.<br><a href="https://mholt.github.io/curl-to-go/">https://mholt.github.io/curl-to-go/</a></p><p>4)json2go<br>用于将 json 文本转换为 struct.<br><a href="https://mholt.github.io/json-to-go/">https://mholt.github.io/json-to-go/</a></p><p>5)mysql 转 ES 工具<br><a href="http://www.ischoolbar.com/EsParser/">http://www.ischoolbar.com/EsParser/</a></p><p>6)golang<br>模拟模板的工具，在支持泛型之前，可以考虑使用。<br><a href="https://github.com/cheekybits/genny">https://github.com/cheekybits/genny</a></p><p>7)查看某一个库的依赖情况，类似于 go list 功能<br><a href="https://github.com/KyleBanks/depth">https://github.com/KyleBanks/depth</a></p><p>8)一个好用的文件压缩和解压工具，集成了 zip，tar 等多种功能，主要还有跨平台。<br><a href="https://github.com/mholt/archiver">https://github.com/mholt/archiver</a></p><p>9)go 内置命令<br>go list 可以查看某一个包的依赖关系.<br>go vet 可以检查代码不符合 golang 规范的地方。</p><p>10)热编译工具<br><a href="https://github.com/silenceper/gowatch">https://github.com/silenceper/gowatch</a></p><p>11)revive<br>golang 代码质量检测工具<br><a href="https://github.com/mgechev/revive">https://github.com/mgechev/revive</a></p><p>12)Go Callvis<br>golang 的代码调用链图工具<br><a href="https://github.com/TrueFurby/go-callvis">https://github.com/TrueFurby/go-callvis</a></p><p>13)Realize<br>开发流程改进工具<br><a href="https://github.com/oxequa/realize">https://github.com/oxequa/realize</a></p><p>14)Gotests<br>自动生成测试用例工具<br><a href="https://github.com/cweill/gotests">https://github.com/cweill/gotests</a></p><h2 id="二-调试工具"><a href="#二-调试工具" class="headerlink" title="二.调试工具"></a>二.调试工具</h2><p>1)perf<br>代理工具，支持内存，cpu，堆栈查看，并支持火焰图.<br>perf 工具和 go-torch 工具，快捷定位程序问题.<br><a href="https://github.com/uber-archive/go-torch">https://github.com/uber-archive/go-torch</a><br><a href="https://github.com/google/gops">https://github.com/google/gops</a></p><p>2)dlv 远程调试<br>基于 goland+dlv 可以实现远程调式的能力.<br><a href="https://github.com/go-delve/delve">https://github.com/go-delve/delve</a><br>提供了对 golang 原生的支持，相比 gdb 调试，简单太多。</p><p>3)网络代理工具<br>goproxy 代理，支持多种协议，支持 ssh 穿透和 kcp 协议.<br><a href="https://github.com/snail007/goproxy">https://github.com/snail007/goproxy</a></p><p>4)抓包工具<br>go-sniffer 工具，可扩展的抓包工具，可以开发自定义协议的工具包. 现在只支持了 http，mysql，redis，mongodb.<br>基于这个工具，我们开发了 qapp 协议的抓包。<br><a href="https://github.com/40t/go-sniffer">https://github.com/40t/go-sniffer</a></p><p>5)反向代理工具，快捷开放内网端口供外部使用。<br>ngrok 可以让内网服务外部调用<br><a href="https://ngrok.com/">https://ngrok.com/</a><br><a href="https://github.com/inconshreveable/ngrok">https://github.com/inconshreveable/ngrok</a></p><p>6)配置化生成证书<br>从根证书，到业务侧证书一键生成.<br><a href="https://github.com/cloudflare/cfssl">https://github.com/cloudflare/cfssl</a></p><p>7)免费的证书获取工具<br>基于 acme 协议，从 letsencrypt 生成免费的证书，有效期 1 年，可自动续期。<br><a href="https://github.com/Neilpang/acme.sh">https://github.com/Neilpang/acme.sh</a></p><p>8)开发环境管理工具，单机搭建可移植工具的利器。支持多种虚拟机后端。<br>vagrant常被拿来同 docker 相比，值得拥有。<br><a href="https://github.com/hashicorp/vagrant">https://github.com/hashicorp/vagrant</a></p><p>9)轻量级容器调度工具<br>nomad 可以非常方便的管理容器和传统应用，相比 k8s 来说，简单不要太多.<br><a href="https://github.com/hashicorp/nomad">https://github.com/hashicorp/nomad</a></p><p>10)敏感信息和密钥管理工具<br><a href="https://github.com/hashicorp/vault">https://github.com/hashicorp/vault</a></p><p>11)高度可配置化的 http 转发工具，基于 etcd 配置。<br><a href="https://github.com/gojek/weaver">https://github.com/gojek/weaver</a></p><p>12)进程监控工具 supervisor<br><a href="https://www.jianshu.com/p/39b476e808d8">https://www.jianshu.com/p/39b476e808d8</a></p><p>13)基于procFile进程管理工具. 相比 supervisor 更加简单。<br><a href="https://github.com/ddollar/foreman">https://github.com/ddollar/foreman</a></p><p>14)基于 http，https，websocket 的调试代理工具，配置功能丰富。在线教育的 nohost web 调试工具，基于此开发.<br><a href="https://github.com/avwo/whistle">https://github.com/avwo/whistle</a></p><p>15)分布式调度工具<br><a href="https://github.com/shunfei/cronsun/blob/master/README_ZH.md">https://github.com/shunfei/cronsun/blob/master/README_ZH.md</a><br><a href="https://github.com/ouqiang/gocron">https://github.com/ouqiang/gocron</a></p><p>16)自动化运维平台 Gaia<br><a href="https://github.com/gaia-pipeline/gaia">https://github.com/gaia-pipeline/gaia</a></p><h2 id="三-网络工具"><a href="#三-网络工具" class="headerlink" title="三. 网络工具"></a>三. 网络工具</h2><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/640.webp"></p><h2 id="四-常用网站"><a href="#四-常用网站" class="headerlink" title="四. 常用网站"></a>四. 常用网站</h2><p>go 百科全书: <a href="https://awesome-go.com/">https://awesome-go.com/</a></p><p>json 解析: <a href="https://www.json.cn/">https://www.json.cn/</a></p><p>出口 IP: <a href="https://ipinfo.io/">https://ipinfo.io/</a></p><p>redis 命令: <a href="http://doc.redisfans.com/">http://doc.redisfans.com/</a></p><p>ES 命令首页:</p><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p>UrlEncode: <a href="http://tool.chinaz.com/Tools/urlencode.aspx">http://tool.chinaz.com/Tools/urlencode.aspx</a></p><p>Base64: <a href="https://tool.oschina.net/encrypt?type=3">https://tool.oschina.net/encrypt?type=3</a></p><p>Guid: <a href="https://www.guidgen.com/">https://www.guidgen.com/</a></p><p>常用工具: <a href="http://www.ofmonkey.com/">http://www.ofmonkey.com/</a></p><h2 id="五-golang-常用库"><a href="#五-golang-常用库" class="headerlink" title="五. golang 常用库"></a>五. golang 常用库</h2><p>日志<br><a href="https://github.com/Sirupsen/logrus">https://github.com/Sirupsen/logrus</a><br><a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a></p><p>配置<br>兼容 json，toml，yaml，hcl 等格式的日志库.<br><a href="https://github.com/spf13/viper">https://github.com/spf13/viper</a></p><p>存储<br>mysql: <a href="https://github.com/go-xorm/xorm">https://github.com/go-xorm/xorm</a><br>es: <a href="https://github.com/elastic/elasticsearch">https://github.com/elastic/elasticsearch</a><br>redis: <a href="https://github.com/gomodule/redigo">https://github.com/gomodule/redigo</a><br>mongo: <a href="https://github.com/mongodb/mongo-go-driver">https://github.com/mongodb/mongo-go-driver</a><br>kafka: <a href="https://github.com/Shopify/sarama">https://github.com/Shopify/sarama</a></p><p>数据结构<br><a href="https://github.com/emirpasic/gods">https://github.com/emirpasic/gods</a></p><p>命令行<br><a href="https://github.com/spf13/cobra">https://github.com/spf13/cobra</a></p><p>框架<br><a href="https://github.com/grpc/grpc-go">https://github.com/grpc/grpc-go</a><br><a href="https://github.com/gin-gonic/gin">https://github.com/gin-gonic/gin</a></p><p>并发<br><a href="https://github.com/Jeffail/tunny">https://github.com/Jeffail/tunny</a><br><a href="https://github.com/benmanns/goworker">https://github.com/benmanns/goworker</a><br>现在我们框架在用的，虽然 star 不多，但是确实好用，当然还可以更好用.<br><a href="https://github.com/rafaeldias/async">https://github.com/rafaeldias/async</a></p><p>工具<br>定义了实用的判定类，以及针对结构体的校验逻辑，避免业务侧写复杂的代码.<br><a href="https://github.com/asaskevich/govalidator">https://github.com/asaskevich/govalidator</a><br><a href="https://github.com/bytedance/go-tagexpr">https://github.com/bytedance/go-tagexpr</a></p><p>protobuf 文件动态解析的接口，可以实现反射相关的能力。<br><a href="https://github.com/jhump/protoreflect">https://github.com/jhump/protoreflect</a></p><p>表达式引擎工具<br><a href="https://github.com/Knetic/govaluate">https://github.com/Knetic/govaluate</a><br><a href="https://github.com/google/cel-go">https://github.com/google/cel-go</a></p><p>字符串处理<br><a href="https://github.com/huandu/xstrings">https://github.com/huandu/xstrings</a></p><p>ratelimit 工具<br><a href="https://github.com/uber-go/ratelimit">https://github.com/uber-go/ratelimit</a><br><a href="https://blog.csdn.net/chenchongg/article/details/85342086">https://blog.csdn.net/chenchongg/article/details/85342086</a><br><a href="https://github.com/juju/ratelimit">https://github.com/juju/ratelimit</a></p><p>golang 熔断的库<br>熔断除了考虑频率限制，还要考虑 qps，出错率等其他东西.<br><a href="https://github.com/afex/hystrix-go">https://github.com/afex/hystrix-go</a><br><a href="https://github.com/sony/gobreaker">https://github.com/sony/gobreaker</a></p><p>表格<br><a href="https://github.com/chenjiandongx/go-echarts">https://github.com/chenjiandongx/go-echarts</a></p><p>tail 工具库<br><a href="https://github.com/hpcloud/taglshi">https://github.com/hpcloud/taglshi</a></p><p>转自<br><a href="https://mp.weixin.qq.com/s/WjaHJHE7ZPbgo7QwIDwZzQ">https://mp.weixin.qq.com/s/WjaHJHE7ZPbgo7QwIDwZzQ</a><br>感谢大佬分享！！</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人与人之间的悲喜并不相通</title>
      <link href="/hypo-Z.github.io/2022/01/24/32-ren-yu-ren-zhi-jian-de-bei-xi-bing-bu-xiang-tong/"/>
      <url>/hypo-Z.github.io/2022/01/24/32-ren-yu-ren-zhi-jian-de-bei-xi-bing-bu-xiang-tong/</url>
      
        <content type="html"><![CDATA[<p>今天照常打开新闻，偶然间看到一篇热点新闻，标题是“寻亲男孩…自杀”，我就好奇点进去看了一下，男孩自杀前写了一封遗书，述说了自己普通但惨淡的一生，他述说自己在记事起，父母就因为事故去世了，从小和姥姥生活，并且遭受了旁人的欺负中成长。后来偶然间发现自己在婴儿时期就被自己真正的亲生父母卖了，所以他想寻找自己丢失的亲情，他的事迹就被发到网上发酵，一些不明事理就随意诽谤他加恶言相向。他才15岁，在他的惨淡的一生中，他将自己的悲伤藏在心地，希望给被人一点阳光的形象，希望别人能够善待他。但是，在这个人人自己的时代，大多数的人并不会对你的事情你的心理你的生活有同情，因为他们不是你，不要尝试改变其他人的想法，最终你只会自食其果。人与人之间的内心并不相通，但是可以通过其他的事物，表达出来，在看过他的遗书并了解到他的一生后，我对他表示同情。不仅仅是对他的人生，也是对像他这样在网上遭受网络暴力的人们，人间是不美好的，希望他在另一个世界不再痛苦，能和自己的父母快乐的生活。</p><p>在后面引用一句话送给网络施暴者：</p><p>如果我永远忘不掉，你们也别想忘掉，你们骂过我最难听的词，你们动手的没动手的都一样，你们比石头还冷漠，你们又恶毒又愚蠢，你们胆小怕事，别人做什么你就跟着做什么，你们巴不得世界上多死一个人，因为你们日子真的无聊，因为你们觉得自己不会承担任何后果，杀死顾森湘的凶手我不知道是谁，但杀死我的凶手，就都在这里了！———影视剧照进现实！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPFS-可快速索引的版本化的点对点文件系统</title>
      <link href="/hypo-Z.github.io/2022/01/21/31-ipfs-ke-kuai-su-suo-yin-de-ban-ben-hua-de-dian-dui-dian-wen-jian-xi-tong/"/>
      <url>/hypo-Z.github.io/2022/01/21/31-ipfs-ke-kuai-su-suo-yin-de-ban-ben-hua-de-dian-dui-dian-wen-jian-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="IPFS-可快速索引的版本化的点对点文件系统（草稿3）"><a href="#IPFS-可快速索引的版本化的点对点文件系统（草稿3）" class="headerlink" title="IPFS - 可快速索引的版本化的点对点文件系统（草稿3）"></a>IPFS - 可快速索引的版本化的点对点文件系统（草稿3）</h1><p>作者： Juan Benet (<a href="mailto:juan@benet.ai">juan@benet.ai</a>)<br>译者： 郭光华(<a href="mailto:gavin@8btc.com">gavin@8btc.com</a>)</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>星际文件系统是一种点对点的分布式文件系统， 旨在连接所有有相同的文件系统的计算机设备。在某些方面， IPFS类似于web, 但web 是中心化的，而IPFS是一个单一的Bittorrent 群集， 用git 仓库分布式存储。换句话说， IPFS 提供了高吞吐量的内容寻址块存储模型， 具有内容寻址的超链接。这形成了一个广义的Merkle DAG 数据结构，可以用这个数据结构构建版本文件系统，区块链，甚至是永久性网站。。IPFS 结合了分布式哈希表， 带有激励机制的块交换和自我认证命名空间。IPFS 没有单故障点， 节点不需要相互信任。</p><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>   在全球分布式文件系统这领域， 已经有许多人的尝试。一些系统已经取得了重大的成功， 而很多却完全失败了。在学术尝试中， AFS【6】就是成功的例子，如今已经得到广泛的应用， 然而，其他的【7， ？】却没有得到相同的结果。在学术界之外，应用最广泛的是面向音视频媒体的点对点文件共享系统。 最值得注意的是， Napster, KaZaA 和BitTorrent[2]部署的文件分发系统支持1亿用户的同时在线。即使在今天， BitTorrent 也维持着每天千万节点的活跃数。 基于这些学术文件系统理论而实现的应用程序有很多的用户量， 然而，这些系统理论是在应用层，而没有放在基础层。以致没有出现通用的文件系统基础框架， 给全球提供低延迟的分发。<br>   也许是因为HTTP这样“足够好“的系统已经存在。到目前为止，HTTP已经作为“分布式文件系统“的协议，并且已经大量部署，再与浏览器相结合，具有巨大的技术和社会影响力。在现在， 它已经成为互联网传输文件的事实标准。然而，他没有采用最近15年的发明的数十种先进的文件分发技术。 从一方面讲， 由于向后兼容的限制 和 当前新模式的投入， 不断发展http web 的基础设施几乎是不可能的。但从一个角度看， 从http 出现以来， 已经有许多新协议出现并被广泛使用。升级http协议虽然能引入新功能和加强当前http协议，但会降低用户的体验。<br>   有些行业已经摆脱使用HTTP 这么久， 因为移动小文件相对便宜，即使对拥有大流量的小组织也是如此。但是，随着新的挑战，我们正在进入数据分发的新纪元。</p><p>（a）托管和分发PB级数据集，<br>（b）跨组织的大数据计算，<br>（c）大批量的高清晰度按需或实时媒体流，<br>（d）大规模数据集的版本化和链接，<br>（e）防止意外丢失重要文件等。其中许多可以归结为“大量数据，无处不在”。由于关键功能和带宽问题，我们已经为不同的数据放弃了HTTP 分销协议。下一步是使它们成为web自己的一部分。<br>正交于有效的数据分发，版本控制系统，已经设法开发重要的数据协作工作流程。Git是分布式源代码版本控制系统，开发了许多有用的方法来建模和实现分布式数据操作。Git工具链提供了灵活的版本控制功能，这正是大量的文件分发系统所严重缺乏的。由Git启发的新解决方案正在出现，如Camlistore [？]，个人文件存储系统，Dat [？]数据协作工具链和数据集包管理器。Git已经影响了分布式文件系统设计[9]，因为其内容涉及到Merkle DAG数据模型，能够实现强大的文件分发策略。还有待探讨的是，这种数据结构如何影响面向高吞吐量的文件系统的设计，以及如何升级Web本身。<br>本文介绍了IPFS，一种新颖的对等版本控制的文件系统，旨在调和这些问题。 IPFS综合了许多以前成功的系统的优点。 IPFS产生了突出的效果， 甚至比参考的这些系统的总和还要好。IPFS的核心原则是将所有数据建模为同一Merkle DAG的一部分。</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><p>   本节回顾了IPFS所采用成功的点对点系统技术的重要属性。</p><h4 id="2-1-分布式哈希表-DHT"><a href="#2-1-分布式哈希表-DHT" class="headerlink" title="2.1 分布式哈希表(DHT)"></a>2.1 分布式哈希表(DHT)</h4><p>   分布式散列表（DHT）被广泛用于协调和维护关于对等系统的元数据。比如，MainlineDHT 是一个去中心化哈希表，他可追踪查找所有的对等节点。</p><h5 id="2-1-1-KADEMLIA-DHT"><a href="#2-1-1-KADEMLIA-DHT" class="headerlink" title="2.1.1 KADEMLIA DHT"></a>2.1.1 KADEMLIA DHT</h5><p>   Kademlia[10] 是受欢迎的DHT, 它提供：<br>   1.通过大量网络进行高效查询：查询平均联系人O(log2N)节点。 （例如，20跳10万个节点的网络）<br>   2.低协调开销：优化数量的控制消息发送到其他节点。<br>   3.抵抗各种攻击，喜欢长寿节点。<br>   4.在对等应用中广泛使用，包括Gnutella和BitTorrent，形成了超过2000万个节点的网络[16]。</p><h5 id="2-1-2-CORAL-DSHT"><a href="#2-1-2-CORAL-DSHT" class="headerlink" title="2.1.2 CORAL DSHT"></a>2.1.2 CORAL DSHT</h5><p>   虽然一些对等文件系统直接在DHT中存储数据块，这种“数据存储在不需要的节点会乱费存储和带宽”[5]。Coral DSHT扩展了Kademlia三个特别重要的方式：</p><p>1.Kademlia在ids为“最近”（使用XOR-distance）的关键节点中存储值。这不考 虑应用程序数据的局部性，忽略“远”可能已经拥有数据的节点，并强制“最近”节点存储它，无论它们是否需要。这浪费了大量的存储和带宽。相反，Coral 存储了地址， 该地址的对等节点可以提供相应的数据块。<br>2.Coral将DHT API从get_value(key)换成了get_any_values(key)（DSHT中的“sloppy”）中。这仍然是因为Coral用户只需要一个（工作）的对等体，而不是完整的列表。作为回报，Coral可以仅将子集分配到“最近”的节点，避免热点（当密钥变得流行时，重载所有最近的节点）。<br>3.另外，Coral根据区域和大小组织了一个称为群集的独立DSHT层次结构。这使得节点首先查询其区域中的对等体，“查找附近的数据而不查询远程节点”[5]并大大减少查找的延迟。</p><h5 id="2-1-3-S-KADEMLIA-DHT"><a href="#2-1-3-S-KADEMLIA-DHT" class="headerlink" title="2.1.3 S/KADEMLIA DHT"></a>2.1.3 S/KADEMLIA DHT</h5><p>S/Kademlia[1] 扩展了Kademlia, 用于防止恶意的攻击。有如下两方面的方法：<br>1.S/Kad 提供了方案来保证NodeId的生成已经防止Sybill攻击。它需要节点产生PKI公私钥对。从中导出他们的身份，并彼此间签名。一个方案使用POW工作量证明，使得生成Sybills成本高昂。<br>2.S/Kad 节点在不相交的路径上查找直， 即使网络中存在大量的不诚实节点，也能确保诚实节点可以互相链接。即使网络中存在一半的不诚实节点，S/Kad 也能达到85%的成功率。</p><h4 id="2-2-块交换-BitTorrent"><a href="#2-2-块交换-BitTorrent" class="headerlink" title="2.2 块交换 - BitTorrent"></a>2.2 块交换 - BitTorrent</h4><p>BitTorrent[3] 是一个广泛成功应用的点对点共享文件系统，它可以在存在不信任的对等节点（群集）的协作网络中分发各自的文件数据片。从BitTorrent和它的生态系统的关键特征， IPFS得到启示如下：<br>1.BitTorrent的数据交换协议使用了一种bit-for-tat的激励策略， 可以奖励对其他方面做贡献的节点，惩罚只榨取对方资源的节点。<br>2.BitTorrent对等体跟踪文件的可用性，优先发送稀有片段。这减轻了seeds节点的负担， 让non-seeds节点有能力互相交易。<br>3.对于一些剥削带宽共享策略， BitTorrent的标准tit-for-tat策略是非常脆弱的。 然而，PropShare[8]是一种不同的对等带宽分配策略， 可以更好的抵制剥削战略， 提高群集的表现。</p><h4 id="2-3-版本控制系统-Git"><a href="#2-3-版本控制系统-Git" class="headerlink" title="2.3. 版本控制系统- Git"></a>2.3. 版本控制系统- Git</h4><p>版本控制系统提供了对随时间变化的文件进行建模的设施，并有效地分发不同的版本。流行版本控制系统Git提供了强大的Merkle DAG对象模型，以分布式友好的方式捕获对文件系统树的更改。<br>1.不可更改的对象表示文件（blob），目录（树）和更改（提交）。<br>2.通过加密hash对象的内容，让对象可寻址。<br>3.链接到其他对象是嵌入的，形成一个Merkle DAG。这提供了很多有用的完整和work-flow属性。<br>4.很多版本元数据（分支，标示等等）都只是指针引用，因此创建和更新的代价都小。<br>5.版本改变只是更新引用或者添加对象。<br>6.分布式版本改变对其他用户而言只是转移对象和更新远程引用。</p><h4 id="2-4-自我认证认文件系统-SFS"><a href="#2-4-自我认证认文件系统-SFS" class="headerlink" title="2.4 自我认证认文件系统-SFS"></a>2.4 自我认证认文件系统-SFS</h4><p>SFS [ 12，11 ]提出了两个引人注目的实现（a）分布式信任链，和（b）平等共享的全局命名空间。SFS引入了一种自我建构技术—注册文件：寻址远程文件系统使用以下格式：</p><pre class="line-numbers language-none"><code class="language-none">/sfs/&lt;Location&gt;:&lt;HostID&gt;Location:代表的是服务网络地方HostID = hash(public_key || Location)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因此SFS文件系统的名字认证了它的服务，用户可以通过服务提供的公钥来验证，协商一个共享的私钥，保证所有的通信。所有的SFS实例都共享了一个全局的命名空间，这个命名空间的名称分配是加密的，不被任何中心化的body控制。</p><h3 id="3-IPFS设计"><a href="#3-IPFS设计" class="headerlink" title="3. IPFS设计"></a>3. IPFS设计</h3><p>   IPFS是一个分布式文件系统，它综合了以前的对等系统的成功想法，包括DHT，BitTorrent，Git和SFS。 IPFS的贡献是简化，发展和将成熟的技术连接成一个单一的内聚系统，大于其部分的总和。 IPFS提供了编写和部署应用程序的新平台，以及一个新的分发系统版本化大数据。 IPFS甚至可以演进网络本身。<br>   IPFS是点对点的;没有节点是特权的。 IPFS节点将IPFS对象存储在本地存储中。节点彼此连接并传输对象。这些对象表示文件和其他数据结构。 IPFS协议分为一组负责不同功能的子协议：</p><ol><li>身份 - 管理节点身份生成和验证。描述在3.1节。<br>2.网络 - 管理与其他对等体的连接，使用各种底层网络协议。可配置的。详见3.2节。<br>3.路由 - 维护信息以定位特定的对等体和对象。响应本地和远程查询。默认为DH​​T，但可更换。在3.3节描述。<br>4.交换 - 一种支持有效块分配的新型块交换协议（BitSwap）。模拟市场，弱化数据复制。贸易策略可替换。描述在3.4节。<br>5.对象 - 具有链接的内容寻址不可更改对象的Merkle DAG。用于表示任意数据结构，例如文件层次和通信系统。详见第3.5节。<br>6.文件 - 由Git启发的版本化文件系统层次结构。详见3.6节。<br>7.命名 - 自我认证的可变名称系统。详见3.7节。<br>这些子系统不是独立的;它们是集成在一起，互相利用各自的属性。但是，分开描述它们是有用的，从下到上构建协议栈。符号：Go语言中指定了以下数据结构和功能</li></ol><h4 id="3-1-身份"><a href="#3-1-身份" class="headerlink" title="3.1 身份"></a>3.1 身份</h4><p>节点由NodeId标识，这是使用S / Kademlia的静态加密难题[1]创建的公钥的密码散列。节点存储其公私钥（用密码加密）。用户可以在每次启动时自由地设置一个“新”节点身份，尽管这会损失积累的网络利益。激励节点保持不变。</p><pre class="line-numbers language-none"><code class="language-none">type NodeId Multihashtype Multihash []byte  // 自描述加密哈希摘要type PublicKey []bytetype PrivateKey []byte // 自描述的私钥type Node struct {NodeId NodeIDPubKey PublicKeyPriKey PrivateKey}基于S / Kademlia的IPFS身份生成：difficulty = &lt;integer parameter&gt;n = Node{}do {n.PubKey, n.PrivKey = PKI.genKeyPair()n.NodeId = hash(n.PubKey)p = count_preceding_zero_bits(hash(n.NodeId))} while (p &lt; difficulty)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首次连接时，对等体交换公钥，并检查：hash（other.PublicKey）等于other.NodeId。如果没有，则连接被终止<br>关于加密函数的注意事项：<br>IPFS不是将系统锁定到一组特定的功能选择，而是支持自我描述的值。哈希摘要值以多重哈希格式存储，其包括指定使用的哈希函数的头和以字节为单位的摘要长度。例如：</p><p>1<br><function code=""><digest length=""><digest bytes=""><br>这允许系统</digest></digest></function></p><p>（a）选择最佳功能用例（例如，更强的安全性与更快的性能），<br>（b）随着功能选择的变化而演变。自描述值允许兼容使用不同的参数选择。</p><h4 id="3-2-网络"><a href="#3-2-网络" class="headerlink" title="3.2 网络"></a>3.2 网络</h4><p>IPFS节点与数百个其他节点进行定期通信网络中的节点，可能跨越广域网络。IPFS网络堆栈功能：<br>传输层： IPFS可以使用任何传输协议，并且最适合WebRTC DataChannels [？]（用于浏览器连接）或uTP（LEDBAT [14]）。<br>可靠性： 如果底层网络不提供可靠性，IPFS可使用uTP（LEDBAT [14]）或SCTP [15]来提供​​可靠性。<br>可连接性：IPFS还可以使用ICE NAT穿墙打洞技术[13]。<br>完整性：可以使用哈希校验和来检查邮件的完整性。<br>可验证性：可以使用发送者的公钥使用HMAC来检查消息的真实性。<br>3.2.1对等节点寻址注意事项：<br>IPFS可以使用任何网络; 但它不承担对IP的获取以及不直接依赖于ip层。这允许在覆盖网络中使用IPFS。<br>IPFS将地址存储为多层地址，这个多层地址是由字节字符串组成的， 以便于给底层网络使用。多层地址提供了一种方式来表示地址及其协议，可以封装成好解析的格式。例如：</p><pre class="line-numbers language-none"><code class="language-none"># an SCTP/IPv4 connection/ip4/10.20.30.40/sctp/1234/# an SCTP/IPv4 connection proxied over TCP/IPv4/ip4/5.6.7.8/tcp/5678/ip4/1.2.3.4/sctp/1234/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-路由"><a href="#3-3-路由" class="headerlink" title="3.3 路由"></a>3.3 路由</h4><p>IPFS节点需要一个路由系统， 这个路由系统可用于查找：</p><p>（a）其他同伴的网络地址，<br>（b）专门用于服务特定对象的对等节点。<br>IPFS使用基于S / Kademlia和Coral的DSHT，在2.1节中具体介绍过。在对象大小和使用模式方面， IPFS 类似于Coral[5] 和Mainline[16], 因此，IPFS DHT根据其大小对存储的值进行区分。小的值（等于或小于1KB）直接存储在DHT上。对于更大的值，DHT只存储值索引，这个索引就是一个对等节点的NodeId, 该对等节点可以提供對该类型的值的具体服务。<br>DSHT的接口如下：</p><pre class="line-numbers language-none"><code class="language-none">type IPFSRouting interface {FindPeer(node NodeId) // 获取特定NodeId的网络地址。SetValue(key []bytes, value []bytes) // 往DHT存储一个小的元数据。GetValue(key []bytes) // 从DHT获取元数据。ProvideValue(key Multihash) // 声明这个节点可一个提供一个大的数据。FindValuePeers(key Multihash, min int) // 获取服务于该大数据的节点。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：不同的用例将要求基本不同的路由系统（例如广域网中使用DHT，局域网中使用静态HT）。因此，IPFS路由系统可以根据用户的需求替换的。只要使用上面的接口就可以了，系统都能继续正常运行。</p><h4 id="3-4块交换-BitSwap协议"><a href="#3-4块交换-BitSwap协议" class="headerlink" title="3.4块交换 - BitSwap协议"></a>3.4块交换 - BitSwap协议</h4><p>IPFS 中的BitSwap协议受到BitTorrent 的启发，通过对等节点间交换数据块来分发数据的。像BT一样， 每个对等节点在下载的同时不断向其他对等节点上传已下载的数据。和BT协议不同的是， BitSwap 不局限于一个torrent文件中的数据块。BitSwap 协议中存在一个永久的市场。 这个市场包括各个节点想要获取的所有块数据。而不管这些块是哪些如.torrent文件中的一部分。这些快数据可能来自文件系统中完全不相关的文件。 这个市场是由所有的节点组成的。<br>虽然易货系统的概念意味着可以创建虚拟货币，但这将需要一个全局分类账本来跟踪货币的所有权和转移。这可以实施为BitSwap策略，并将在未来的论文中探讨。<br>在基本情况下，BitSwap节点必须以块的形式彼此提供直接的值。只有当跨节点的块的分布是互补的时候，各取所需的时候，这才会工作的很好。 通常情况并非如此，在某些情况下，节点必须为自己的块而工作。 在节点没有其对等节点所需的（或根本没有的）情况下，它会更低的优先级去寻找对等节点想要的块。这会激励节点去缓存和传播稀有片段， 即使节点对这些片段不感兴趣。</p><h5 id="3-4-1-BITSWAP-信用"><a href="#3-4-1-BITSWAP-信用" class="headerlink" title="3.4.1 - BITSWAP 信用"></a>3.4.1 - BITSWAP 信用</h5><p>这个协议必须带有激励机制， 去激励节点去seed 其他节点所需要的块，而它们本身是不需要这些块的。 因此， BitSwap的节点很积极去给对端节点发送块，期待获得报酬。但必须防止水蛭攻击（空负载节点从不共享块），一个简单的类似信用的系统解决了这些问题：</p><p>1， 对等节点间会追踪他们的平衡（通过字节认证的方式）。<br>2， 随着债务增加而概率降低，对等者概率的向债务人发送块。<br>注意的是，如果节点决定不发送到对等体，节点随后忽略对等体的ignore_cooldown超时。 这样可以防止发送者尝试多次发送（洪水攻击） （BitSwap默认是10秒）。<br>3.4.2 BITSWAP的策略<br>BitSwap 对等节点采用很多不同的策略，这些策略对整个数据块的交换执行力产生了不同的巨大影响。在BT 中， 标准策略是明确规定的（tit-for-tat），其他不同的策略也已经被实施，从BitTyrant [8]（尽可能分享）到BitThief [8]（利用一个漏洞，从不共享），到PropShare [8]（按比例分享）。BitSwap 对等体可以类似地实现一系列的策略（良好和恶意）。对于功能的选择，应该瞄准：<br>1.为整个交易和节点最大化交易能力。<br>2.为了防止空负载节点利用和损害交易。<br>3.高效抵制未知策略。<br>4.对可信任的对等节点更宽容。<br>探索这些策略的空白是未来的事情。在实践中使用的一个选择性功能是sigmoid，根据负债比例进行缩放：<br>让负债比例在一个节点和它对等节点之间：</p><pre class="line-numbers language-none"><code class="language-none">r =  bytes_sent  / bytes_recv + 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>根据r，发送到负债节点的概率为：</p><pre class="line-numbers language-none"><code class="language-none">P(send | r ) = 1 − ( 1/  ( 1 + exp(6 − 3r) ) )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>正如你看到的图片1，当节点负债比例超过节点已建立信贷的两倍，发送到负债节点的概率就会急速下降。</p><p>图片1  当r增加时发送的概率<br>负债比是信任的衡量标准：对于之前成功的互换过很多数据的节点会宽容债务，而对不信任不了解的节点会严格很多。这个(a)给与那些创造很多节点的攻击者（sybill 攻击）一个障碍。(b)保护了之前成功交易节点之间的关系，即使这个节点暂时无法提供数据。(c)最终阻塞那些关系已经恶化的节点之间的通信，直到他们被再次证明。</p><h5 id="3-4-3-BITSWAP-账本"><a href="#3-4-3-BITSWAP-账本" class="headerlink" title="3.4.3 BITSWAP 账本"></a>3.4.3 BITSWAP 账本</h5><p>BitSwap节点保存了一个记录与所有其他节点之间交易的账本。这个可以让节点追踪历史记录以及避免被篡改。当激活了一个链接，BitSwap节点就会互换它们账本信息。如果这些账本信息并不完全相同，分类账本将会重新初始化， 那些应计信贷和债务会丢失。 恶意节点会有意去失去“这些“账本， 从而期望清除自己的债务。节点是不太可能在失去了应计信托的情况下还能累积足够的债务去授权认证。伙伴节点可以自由的将其视为不当行为， 拒绝交易。</p><pre class="line-numbers language-none"><code class="language-none">type Ledger struct {owner NodeIdpartner NodeIdbytes_sent intbytes_recv inttimestamp Timestamp}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>节点可以自由的保留分布式账本历史，这不需要正确的操作，因为只有当前的分类账本条目是有用的。节点也可以根据需要自由收集分布式帐本，从不太有用的分布式帐开始：老（其他对等节点可能不存在）和小。</p><h5 id="3-4-4-BITSWAP-详解"><a href="#3-4-4-BITSWAP-详解" class="headerlink" title="3.4.4 BITSWAP 详解"></a>3.4.4 BITSWAP 详解</h5><p>BitSwap 节点有以下简单的协议。</p><pre class="line-numbers language-none"><code class="language-none">// Additional state kepttype BitSwap struct {ledgers map[NodeId]Ledger // Ledgers known to this node, inc inactiveactive map[NodeId]Peer // currently open connections to other nodesneed_list []Multihash // checksums of blocks this node needshave_list []Multihash // checksums of blocks this node has}type Peer struct {nodeid NodeIdledger Ledger // Ledger between the node and this peerlast_seen Timestamp // timestamp of last received messagewant_list []Multihash // checksums of all blocks wanted by peer// includes blocks wanted by peer's peers}// Protocol interface:interface Peer {open (nodeid : NodeId, ledger : Ledger);send_want_list (want_list : WantList);send_block(block: Block) -&gt; (complete:Bool);close(final: Bool);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对等连接的生命周期草图：</p><p>1.Open: 对等节点间发送ledgers 直到他们同意。<br>2.Sending: 对等节点间交换want_lists 和blocks。<br>3.Close: 对等节点断开链接。<br>4.Ignored: （特殊）对等体被忽略（等待时间的超时）如果节点采用防止发送策略。<br>Peer.open(NodeId, Ledger).<br>当发生链接的时候，节点会初始化链接的账本，要么保存一个份链接过去的账本，要么创建一个新的被清零的账本。然后，发送一个携带账本的open信息给对等节点。<br>接收到一个open信息之后，对等节点可以选择是否接受此链接。如果，根据接收者的账本，发送者是一个不可信的代理（传输低于零或者有很大的未偿还的债务），接收者可能会选择忽略这个请求。忽略请求是ignore_cooldown超时来概率性实现的，为了让错误能够有时间改正和攻击者被挫败。<br>如果链接成功，接收者用本地账本来初始化一个Peer对象以及设置last_seen时间戳。然后，它会将接受到的账本与自己的账本进行比较。如果两个账本完全一样，那么这个链接就被Open，如果账本并不完全一致，那么此节点会创建一个新的被清零的账本并且会发送此账本。<br>Peer.send_want_list(WantList)<br>当链接已经Open的时候，节点会广发它们的want_list给所有已经链接的对等节点。这个是在(a)open链接后(b)随机间歇超时后(c)want_list改变后(d)接收到一个新的块之后完成的。<br>当接收到一个want_list之后，节点会存储它。然后，会检查自己是否拥有任何它想要的块。如果有，会根据上面提到的BitSwap策略来将want_list所需要的块发送出去。<br>Peer.send_block(Block)<br>发送一个块是直接了当的。节点只是传输数据块。当接收到了所有数据的时候，接收者会计算多重hash校验和来验证它是否是自己所需数据，然后发送确认信息。<br>在完成一个正确的块传输之后，接受者会将此块从need_list一到have_list,最后接收者和发送者都会更新它们的账本来反映出传输的额外数据字节数。<br>如果一个传输验证失败了，发送者要么会出故障要么会攻击接收者，接收者可以选择拒绝后面的交易。注意，BitSwap是期望能够在一个可靠的传输通道上进行操作的，所以传输错误（可能会引起一个对诚实发送者错误的惩罚）是期望在数据发送给BitSwap之前能够被捕捉到。<br>Peer.close(Bool)<br>传给close最后的一个参数，代表close链接是否是发送者的意愿。如果参数值为false,接收者可能会立即重新open链接，这避免链过早的close链接。<br>一个对等节点close链接发生在下面两种情况下：<br>silence_wait超时已经过期，并且没有接收到来自于对等节点的任何信息（BitSwap默认使用30秒），节点会发送Peer.close(false)。<br>在节点退出和BitSwap关闭的时候，节点会发送Peer.close(true).<br>接收到close消息之后，接收者和发送者会断开链接，清除所有被存储的状态。账本可能会被保存下来为了以后的便利，当然，只有在被认为账本以后会有用时才会被保存下来。<br>注意点：<br>非open信息在一个不活跃的连接上应该是被忽略的。在发送send_block信息时，接收者应该检查这个块，看它是否是自己所需的，并且是否是正确的，如果是，就使用此块。总之，所有不规则的信息都会让接收者触发一个close(false)信息并且强制性的重初始化此链接。</p><h4 id="3-5-Merkle-DAG对象"><a href="#3-5-Merkle-DAG对象" class="headerlink" title="3.5 Merkle DAG对象"></a>3.5 Merkle DAG对象</h4><p>DHT和BitSwap允许IPFS构造一个庞大的点对点系统用来快速稳定的分发和存储。最主要的是，IPFS建造了一个Merkle DAG,一个无回路有向图，对象之间的links都是hash加密嵌入在源目标中。这是Git数据结构的一种推广。Merkle DAGS给IPFS提供了很多有用的属性，包括：<br>1.内容可寻址：所有内容都是被多重hash校验和来唯一识别的，包括links。<br>2.防止篡改：所有的内容都用它的校验和来验证。如果数据被篡改或损坏，IPFS会检测到。<br>3.重复数据删除：所有的对象都拥有相同的内容并只存储一次。这对于索引对象非常有用，比如git的tree和commits，或者数据的公共部分。<br>IPFS对象的格式是：</p><pre class="line-numbers language-none"><code class="language-none">type IPFSLink struct {Name string      // 此link的别名Hash Multihash // 目标的加密hashSize int             // 目标总大小}type IPFSObject struct {links []IPFSLink   //links数组data []byte         //不透明内容数据}IPFS Merkle DAG是存储数据非常灵活的一种方式。只要求对象引用是(a）内容可寻址的，(b)用上面的格式编码。IPFS允许应用完全的掌控数据域；应用可以使用任何自定义格式的数据，即使数据IPFS都无法理解。单独的内部对象link表允许IPFS做：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用对象的形式列出所有对象引用，例如：</p><pre class="line-numbers language-none"><code class="language-none">&gt; ipfs ls /XLZ1625Jjn7SubMDgEyeaynFuR84ginqvzbXLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x 189458 lessXLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5 19441 scriptXLF4hwVHsVuZ78FZK6fozf8Jj9WEURMbCX4 5286 template&lt;object multihash&gt; &lt;object size&gt; &lt;link name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决字符串路经查找，例如foo/bar/baz。给出一个对象，IPFS会解析第一个路经成分进行hash放入到对象的link表中，再获取路径的第二个组成部分，一直如此重复下去。因此，任何数据格式的字符串路经都可以在Merkle DAG中使用。<br>*递归性的解决所有对象引用：</p><pre class="line-numbers language-none"><code class="language-none">&gt; ipfs refs --recursive \/XLZ1625Jjn7SubMDgEyeaynFuR84ginqvzbXLLxhdgJcXzLbtsLRL1twCHA2NrURp4H38sXLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16xXLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5XLWVQDqxo9Km9zLyquoC9gAP8CL1gWnHZ7z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原始数据结构公共link结构是IPFS构建任意数据结构的必要组成部分。可以很容易看出Git的对象模型是如何套用DAG的。一些其他潜在的数据结构：</p><p>(a)键值存储<br>(b)传统关系型数据<br>(c)数据三倍存储<br>(d) 文档发布系统<br>(e)通信平台<br>(f)加密货币区块。<br>这些系统都可以套用IPFS Merkle DAG，这使这些系统更复杂的应用可以使用IPFS作为传输协议。</p><h5 id="3-5-1-路经"><a href="#3-5-1-路经" class="headerlink" title="3.5.1 路经"></a>3.5.1 路经</h5><p>IPFS对象可以遍历一个字符串路经。路经格式与传统UNIX文件系统以及Web一致。Merkle DAG的links使遍历变得很容易。全称路经在IPFS中的格式是：</p><pre class="line-numbers language-none"><code class="language-none">*# 格式/ipfs/&lt;hash-of-object&gt;/&lt;name-path-to-object&gt;*# 例子/ipfs/XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x/foo.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>/ipfs前缀允许只要在挂载点不冲突(挂载点名称当然是可配置的)的情况下挂载到一个已存在的系统上。第二个路经组成部分(第一个是IPFS)是一个对象的hash。通常都是这种情况，因为没有全局的根。一个根对象可能会有一个不可能完成的任务，就是在分布式环境(可能还断开链接)中处理百万对象的一致性。因此，我们用地址可寻址来模拟根。通过的hash所有的对象都是可访问的。这意思是说，给一个路经对象/bar/baz，最后一个对象可以可以被所有的访问的：</p><pre class="line-numbers language-none"><code class="language-none">/ipfs/&lt;hash-of-foo&gt;/bar/baz/ipfs/&lt;hash-of-bar&gt;/baz/ipfs/&lt;hash-of-baz&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="3-5-2-本地对象"><a href="#3-5-2-本地对象" class="headerlink" title="3.5.2 本地对象"></a>3.5.2 本地对象</h5><p>IPFS客户端需要一个本地存储器，一个外部系统可以为IPFS管理的对象存储以及检索本地原始数据。存储器的类型根据节点使用案例不同而不同。在大多数情况下，这个存储器只是硬盘空间的一部分（不是被本地的文件系统使用键值存储如leveldb来管理，就是直接被IPFS客户端管理），在其他的情况下，例如非持久性缓存，存储器就是RAM的一部分。<br>最终，所有的块在IPFS中都是能够获取的到的，块都存储在了一些节点的本地存储器中。当用户请求一个对象时，这个对象会被查找到并下载下来存储到本地，至少也是暂时的存储在本地。这为一些可配置时间量提供了快速的查找。</p><h5 id="3-5-3对象锁定"><a href="#3-5-3对象锁定" class="headerlink" title="3.5.3对象锁定"></a>3.5.3对象锁定</h5><p>希望确保特定对象生存的节点可以锁定此对象。这保证此特定对象被保存在了节点的本地存储器上。也可以递归的进行锁定所有相关的派生对象。这使所有被指定的对象都保存在本地存储器上。这对长久保存文件特别有用，包括引用。这也同样让IPFS成为一个links是永久的Web，且对象可以确保其他被指定对象的生存。</p><h5 id="3-5-4-发布对象"><a href="#3-5-4-发布对象" class="headerlink" title="3.5.4 发布对象"></a>3.5.4 发布对象</h5><p>IPFS是全球分布的。它设计为允许成千上万的用户文件可以共同的存在的。DHT使用内容哈希寻址技术，使发布对象是公平的，安全的，完全分布式的。任何人都可以发布对象，只需要将对象的key加入到DHT中，并且以对象是对等节点的方式加入进去，然后把路径给其他的用户。要注意的是，对象本质上是不可改变的，就像在Git中一样。新版本的哈希值不同，因此是新对象。跟踪版本则是额外版本对象的工作。</p><h5 id="3-5-5-对象级别的加密"><a href="#3-5-5-对象级别的加密" class="headerlink" title="3.5.5 对象级别的加密"></a>3.5.5 对象级别的加密</h5><p>IPFS是具备可以处理对象级别加密操作的。一个已加密的或者已签名的对象包装在一个特殊的框架里，此框架允许加密和验证原始字节。</p><pre class="line-numbers language-none"><code class="language-none">type EncryptedObject struct {Object []bytes // 已加密的原始对象数据Tag []bytes    // 可选择的加密标识type SignedObject struct {Object []bytes  // 已签名的原始对象数据Signature []bytes // HMAC签名PublicKey []multihash // 多重哈希身份键值}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加密操作改变了对象的哈希值，定义一个不同的新的对象。IPFS自动的验证签名以及使用用户指定的钥匙链解密数据。加密数据的links也同样的被保护着，没有解密秘钥就无法遍历对象。也存在着一种现象，可能父对象使用了一个秘钥进行了加密，而子对象使用了另一个秘钥进行加密或者根本没有加密。这可以保证links共享对象安全。</p><h4 id="3-6-文件"><a href="#3-6-文件" class="headerlink" title="3.6 文件"></a>3.6 文件</h4><p>IPFS在Merkle DAG上还为模型化版本文件系统定义了一组对象。这个对象模型与Git比较相似：<br>Block：一个可变大小的数据块<br>List：块或者其他链表的集合<br>Tree：块，链表，或者其他树的集合<br>Commit：树在版本历史记录中的一个快照<br>我原本希望使用与Git对象格式一致的模型，但那就必须要分开来引进在分布式文件系统中有用的某些特征，如</p><p>(a)快速大小查找(总字节大小已经加入到对象中)<br>(b)大文件的重复删除(添加到list对象)<br>(c)commits嵌入到trees中。不过，IPFS文件对象与Git还是非常相近的，两者之间进行交流都是有可能的。而且，Git的一个系列的对象可以被引进过来转换都不会丢失任何的信息。（UNIX文件权限等等）。<br>标记：下面的文件对象格式使用JSON。注意，虽然IPFS包含了JSON的互相转换，但是文件对象的结构体还是使用protobufs的二进制编码。</p><h5 id="3-6-1-文件对象：BLOB"><a href="#3-6-1-文件对象：BLOB" class="headerlink" title="3.6.1 文件对象：BLOB"></a>3.6.1 文件对象：BLOB</h5><p>blob对象代表一个文件且包含一个可寻址的数据单元，IPFS的blobs就像Git的blobs或者文件系统数据块。它们存储用户的数据。需要留意的是IPFS文件可以使用lists或者blobs来表示。Blobs没有links。</p><pre class="line-numbers language-none"><code class="language-none">{"data": "some data here",  // blobs无links}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="3-6-2-文件对象-LIST"><a href="#3-6-2-文件对象-LIST" class="headerlink" title="3.6.2 文件对象: LIST"></a>3.6.2 文件对象: LIST</h5><p>List对象代表着由几个IPFS的blobs连接成的大文件或者重复数据删除文件。Lists包含着有序的blob序列或list对象。从某种程度上而言，IPFS的list函数就像一个间接块的文件系统。由于lists可以包含其他的lists，那么包含linked的链表和平衡树的拓扑结构是有可能的。有向图中相同的节点出现在多个不同地方允许在文件中重复数据删除。当然，循环是不可以能的，因为是被哈希寻址强制实行的。</p><pre class="line-numbers language-none"><code class="language-none">{"data": ["blob", "list", "blob"], //lists有一个对象类型的数组作为数据"links": [{ "hash": "XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x","size": 189458 },{ "hash": "XLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5","size": 19441 },{ "hash": "XLWVQDqxo9Km9zLyquoC9gAP8CL1gWnHZ7z","size": 5286 } //在links中lists是没有名字的]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-6-3-文件对象：TREE"><a href="#3-6-3-文件对象：TREE" class="headerlink" title="3.6.3 文件对象：TREE"></a>3.6.3 文件对象：TREE</h5><p>IPFS中的tree对象与Git中相似，它代表着一个目录，一个名字到哈希值的映射。哈希值则表示着blobs，lists，其他的trees，或者commits。注意，传统路径的命名早已经被Merkle DAG实现了。</p><pre class="line-numbers language-none"><code class="language-none">{"data": ["blob", "list", "blob"],//trees有一个对象类型的数组作为数据"links": [{ "hash": "XLYkgq61DYaQ8NhkcqyU7rLcnSa7dSHQ16x","name": "less", "size": 189458 },{ "hash": "XLHBNmRQ5sJJrdMPuu48pzeyTtRo39tNDR5","name": "script", "size": 19441 },{ "hash": "XLWVQDqxo9Km9zLyquoC9gAP8CL1gWnHZ7z","name": "template", "size": 5286 }//trees是有名字的]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-6-4-文件对象：COMMIT"><a href="#3-6-4-文件对象：COMMIT" class="headerlink" title="3.6.4 文件对象：COMMIT"></a>3.6.4 文件对象：COMMIT</h5><p>IPFS中的commit对象代表任何对象在版本历史记录中的一个快照。与Git中类似，但是它能够表示任何类型的对象。它同样link着发起对象。</p><h5 id="3-6-5-版本控制"><a href="#3-6-5-版本控制" class="headerlink" title="3.6.5 版本控制"></a>3.6.5 版本控制</h5><p>Commit对象代表着一个对象在历史版本中的一个特定快照。在两个不同的commit中比较对象（和子对象）可以揭露出两个不同版本文件系统的区别。只要commit和它所有子对象的引用是能够被访问的，所有前版本是可获取的，所有文件系统改变的全部历史是可访问的，这就与Merkle DAG对象模型脱离开来了。</p><p>Git版本控制工具的所有功能对于IPFS的用户是可用的。对象模型不完全一致，但也是可兼容的。这可能</p><p>(a)构建一个Git工具版本改造成使用IPFS对象图，<br>(b)构建一个挂载FUSE文件系统，挂载一个IPFS的tree作为Git的仓库，把Git文件系统的读/写转换为IPFS的格式。</p><h5 id="3-6-6-文件系统路径"><a href="#3-6-6-文件系统路径" class="headerlink" title="3.6.6 文件系统路径"></a>3.6.6 文件系统路径</h5><p>如我们在Merkle DAG中看到的一样，IPFS对象可以使用字符串路径API来遍历。IPFS文件对象是特意设计的，为了让挂载IPFS到UNIX文件系统更加简单。文件对象限制trees没有数据，为了使它们可以表示目录。Commits可以以代表目录的形式出现，也可以完全的隐藏在文件系统中。</p><h5 id="3-6-7-将文件分隔成LISTS和BLOBS"><a href="#3-6-7-将文件分隔成LISTS和BLOBS" class="headerlink" title="3.6.7 将文件分隔成LISTS和BLOBS"></a>3.6.7 将文件分隔成LISTS和BLOBS</h5><p>版本控制和分发大文件其中一个最主要的挑战是：找到一个正确的方法来将它们分隔成独立的块。与其认为IPFS可以为每个不同类型的文件提供正确的分隔方法，不如说IPFS提供了以下的几个可选选择：<br>就像在LIBFS[?]中一样使用Rabin Fingerprints [?]来选择一个比较合适的块边界。<br>使用rsync[?] rolling-checksum算法，来检测块在版本之间的改变。<br>允许用户指定专为特定文件而调整的’快分隔’函数。</p><h5 id="3-6-8路径查找性能"><a href="#3-6-8路径查找性能" class="headerlink" title="3.6.8路径查找性能"></a>3.6.8路径查找性能</h5><p>基于路径的访问需要遍历对象图。获取每个对象要求在DHT中查找它们的key，连接到对等节点，然后获取它的块。这造成相当大的开销，特别是查找的路径由很多子路径组成时。下面的方法可以减缓开销：</p><p>tree缓存：由于所有的对象都是哈希寻址的，它们可以被无限的缓存。另外，trees一般比较小，所以比起blobs，IPFS会优先缓存trees。<br>flattened trees：对于任何tree，一个特殊的 flattened tree可以构建一个链表，所有对象都可以从这个tree中访问得到。在flattened tree中名字就是一个从原始tree分离的路径，用斜线分隔。<br>例如，对于上面的ttt111的flattened tree如下：</p><pre class="line-numbers language-none"><code class="language-none">{"data":["tree", "blob", "tree", "list", "blob" "blob"],"links": [{ "hash": "&lt;ttt222-hash&gt;", "size": 1234"name": "ttt222-name" },{ "hash": "&lt;bbb111-hash&gt;", "size": 123,"name": "ttt222-name/bbb111-name" },{ "hash": "&lt;ttt333-hash&gt;", "size": 3456,"name": "ttt333-name" },{ "hash": "&lt;lll111-hash&gt;", "size": 587,"name": "ttt333-name/lll111-name"},{ "hash": "&lt;bbb222-hash&gt;", "size": 22,"name": "ttt333-name/lll111-name/bbb222-name" },{ "hash": "&lt;bbb222-hash&gt;", "size": 22"name": "bbb222-name" }] }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-7-IPNS：命名以及易变状态"><a href="#3-7-IPNS：命名以及易变状态" class="headerlink" title="3.7 IPNS：命名以及易变状态"></a>3.7 IPNS：命名以及易变状态</h4><p>目前为止，IPFS桟形成了一个对等块交换组成一个内容可寻址的DAG对象。这提供了发布和获取不可改变的对象。这甚至可以跟踪这些对象的版本历史记录。但是，这里有一个关键成分遗漏了：易变的命名。没有这个，发送IPFS的links，所有新内容的通信肯定都会有所偏差。现在所需就是能有某些方法可以获取相同路径的的易变状态。<br>这值得详述原因—如果最终易变数据是必须的—我们费了很大的力气构建了一个不可改变的Merkle DAG。就当做IPFS脱离了Merkle DAG的特征：对象可以</p><p>(a)通过哈希值可以获取<br>(b)完整性的检查<br>(c)link其他的对象<br>(d)无限缓存。从某种意义上说：<br>对象就是永恒的<br>这些就是一个高性能分布式系统的关键特征，在此系统上跨网络links之间移动文件是非常昂贵的。对象内容可寻址构建了一个具有以下特点的Web，(a)优秀的宽带优化(b)不受信任的内容服务(c)永恒的links(d)能够永久备任何对象以及它的引用。<br>不可变的内容可寻址对象和命名的Merkle DAG， 可变指针指向Merkle DAG，实例化了一个出现在很多成功分布式系统中的二分法。这些系统包括Git的版本控制系统，使用不可变的对象和可变的引用；还有UNIX分布式的继承者Plan9[?]文件系统，使用可变的Fossil和不可变的Venti[?]。LBFS[?]同样使用可变的索引以及不可变的块。</p><h5 id="3-7-1-自我认证名称"><a href="#3-7-1-自我认证名称" class="headerlink" title="3.7.1 自我认证名称"></a>3.7.1 自我认证名称</h5><p>使用SFS[12,11]中的命名方案，给我们提供了一个种可以构建自我认证名称的方法，<br>在一个加密指定的全局命名空间中，这是可变的。IPFS的方案如下：</p><p>1.回想一下在IPFS中：NodeId = hash(node.PubKey)<br>2.我们给每个用户分配一个可变的命名空间，在此路径下：/ipns/<br>3.一个用户可以在此路径下发布一个用自己私钥签名的对象，比如说：/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm/<br>4.当其他用户获取对象时，他们可以检测签名是否与公钥和NodeId匹配。这个验证了用户发布对象的真实性，达到了可变状态的获取。<br>注意下面的细节：</p><p>IPNS(InterPlanetary的命名空间)分开前缀是在可变和不可变的路径之间建立一个很容易辨认的区别，为了程序也为了人类阅读的便利。<br>因为这不是一个内容可寻址的对象，所以发布它就要依靠IPFS中的唯一的可变状态分配制度，路由系统。过程是(a)首先把此对象做一个常规的不可变IPFS的对象来发布(b)将此对象的哈希值作为元数据的值发布到路由系统上：</p><pre class="line-numbers language-none"><code class="language-none">routing.setValue(NodeId, &lt;ns-object-hash&gt;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发布的对象中任何links在命令空间中充当子名称：</p><pre class="line-numbers language-none"><code class="language-none">/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm//ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm/docs/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm/docs/ipfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一般建议发布一个commit对象或者其他对象的时候，要使用历史版本记录，因为这样就用户就可以找到之前使用过的名字。不过由于这并不总是需要的，所以留个用户自己选择。<br>注意当用户发布一个对象的时候，他不能使用相同的方式来发布对象。</p><h5 id="3-7-2人类友好名称"><a href="#3-7-2人类友好名称" class="headerlink" title="3.7.2人类友好名称"></a>3.7.2人类友好名称</h5><p>IPNS的确是一个分配和在分配名称的好方法，但是对用户却不是十分友好的，因为它使用很长的哈希值作为名称，众所周知这样的名称很难被记住。IPNS足够应付URLs，但对于很多线下的传输工作就没有这么好用了。因此，IPFS使用下面的技术来增加IPNS的用户友好度。<br>对等节点Links<br>被SFS所鼓舞，用户可以直接将其他用户的对象link到自己的对象上（命令空间，家目录等等）。这有一个好处就是创建了一个可信任的Web（也支持老的真实性认证模型）：</p><pre class="line-numbers language-none"><code class="language-none"># Alice links 到Bob上ipfs link /&lt;alice-pk-hash&gt;/friends/bob /&lt;bob-pk-hash&gt;# Eve links 到Alice上ipfs link /&lt;eve-pk-hash/friends/alice /&lt;alice-pk-hash&gt;# Eve 也可以访问Bob/&lt;eve-pk-hash/friends/alice/friends/bob# 访问Verisign 认证域/&lt;verisign-pk-hash&gt;/foo.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DNS TXT IPNS 记录<br>如果/ipns/是一个有效的域名称，IPFS会在DNS TXT记录中查找关键的ipns。IPFS会将查找到的值翻译为一个对象的哈希值或者另一个ipns的路径：</p><pre class="line-numbers language-none"><code class="language-none"># DNS TXT 记录ipfs.benet.ai. TXT "ipfs=XLF2ipQ4jD3U ..."# 表现为符号链接ln -s /ipns/XLF2ipQ4jD3U /ipns/fs.benet.ai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Proquint 可读的标识符<br>总是会有将二进制编码翻译成可读文件的方法。IPNS则支持Proquint[?].。如下：</p><pre class="line-numbers language-none"><code class="language-none"># proquint语句/ipns/dahih-dolij-sozuk-vosah-luvar-fuluh# 分解为相应的下面形式/ipns/KhAwNprxYVxKqpDZ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>缩短名称服务<br>会涌现出很多服务器提供缩短名称的服务，向用户提供他们的命名空间。就像我们现在看到的DNS和Web的URLs：</p><pre class="line-numbers language-none"><code class="language-none"># 用户可以从下面获取一个link/ipns/shorten.er/foobar# 然后放到自己的命名空间/ipns/XLF2ipQ4jD3UdeX5xp1KBgeHRhemUtaA8Vm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-8-使用IPFS"><a href="#3-8-使用IPFS" class="headerlink" title="3.8 使用IPFS"></a>3.8 使用IPFS</h4><p>IPFS设计为可以使用多种不同的方法来使用的，下面就是一些我将会继续追求的使用方式：</p><p>1.作为一个挂载的全局文件系统，挂载在/ipfs和/ipns下<br>2.作为一个挂载的个人同步文件夹，自动的进行版本管理，发布，以及备份任何的写入<br>3.作为一个加密的文件或者数据共享系统<br>4.作为所有软件的版本包管理者<br>5.作为虚拟机器的根文件系统<br>6.作为VM的启动文件系统 (在管理程序下)<br>7.作为一个数据库：应用可以直接将数据写入Merkle DAG数据模型中，获取所有的版本，缓冲，以及IPFS提供的分配<br>8.作为一个linked（和加密的）通信平台<br>9.作为一个为大文件的完整性检查CDN（不使用SSL的情况下）<br>10.作为一个加密的CDN<br>11.在网页上，作为一个web CDN<br>12.作为一个links永远存在新的永恒的Web<br>IPFS实现的目标：<br>(a)一个IPFS库可以导出到你自己应用中使用<br>(b)命令行工具可以直接操作对象<br>(c)使用FUSE[?]或者内核的模型挂载文件系统</p><h3 id="4-未来"><a href="#4-未来" class="headerlink" title="4. 未来"></a>4. 未来</h3><p>   IPFS的思想是几十年成功的分布式系统的探索和开源的产物。IPFS综合了很多迄今为止很成功的系统中优秀的思想。除了BitSwap新协议之外，IPFS最大的特色就是系统的耦合以及设计的综合性。<br>   IPFS是去中心化网络基础设施的一个野心设想，很多不同类型的应用都可以建立在IPFS上。最低限度，它可以用来作为一个全局的，挂载性，版本控制文件系统和命名空间，或者作为下一代的文件共享系统。而最好的情况是，IPFS可以让Web升级一个层次，当发布一个有价值的信息时，任何感兴趣的人都可以进行发布而不会强迫性的必须只允许发布机构进行发布，用户可以信任信息的内容，信不信任信息的发送者都是无关紧要的，还有一个特点就是，一些重要但很老的文件也不会丢失。IPFS期待着带我们进入到一个永恒Wdb的世界。</p><h3 id="5-感谢"><a href="#5-感谢" class="headerlink" title="5. 感谢"></a>5. 感谢</h3><p>   IPFS是一个很多很棒的主意以及系统的综合体。没有站在巨人的肩膀上，IPFS也不可能敢于有一个这么有野心的目标。个人感谢参与这些主意长期讨论的人：David Dalrymple, Joe Zimmerman, and Ali Yahya，特别是：揭开Merkle DAG的总体架构(David, Joe),滚动哈希阻塞(David), s/kademlia sybill 保护(David, Ali)，特别感谢David Mazieres,为他之前非常聪明的主意。<br>   6.引用备忘录<br>   7.引用<br>   [1].I. Baumgart and S. Mies. S/kademlia:一个安全的基于秘钥路由的可行方法。2007年国际会议，第2卷，1-8页，在《并发和分布式系统》中。IEEE，2007年。<br>   [2].I. BitTorrent.Bittorrent和Attorrent软件超过1亿5000万用户里程碑，Jan。2012<br>   [3].B. Cohen.激励机制在bittorrent中建立了健壮性。在《对等系统经济研讨会》中，第6卷，68-72页，2003年。<br>   [4].J. Dean and S. Ghemawat. Leveldb - 一个快速和轻量级键值存储数据库，谷歌提供，2011年。<br>   [5].M. J. Freedman, E. Freudenthal, and D. Mazieres. Coral民主内容发布。在NSDI中，第4卷，18-18页，2004年。<br>   [6].J. H. Howard, M. L. Kazar, S. G. Menees, D. A,Nichols, M. Satyanarayanan, R. N. Sidebotham, 以及M. J. West.分布式文件系统的规模和性能。“ACM 电脑系统上的交易 （TOCS）” 6(1):51-81, 1988年</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器间通信</title>
      <link href="/hypo-Z.github.io/2022/01/08/docker-rong-qi-jian-tong-xin/"/>
      <url>/hypo-Z.github.io/2022/01/08/docker-rong-qi-jian-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker容器间通信"><a href="#Docker容器间通信" class="headerlink" title="Docker容器间通信"></a>Docker容器间通信</h1><p>Bridge网桥双向通信</p><p><strong>浏览器&lt;==&gt;物理网卡&lt;=网桥=&gt;Docker环境下的容器</strong></p><p>将指定的容器都绑定到同一个网桥上，这些容器就会天然的互联互通</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --name server appdocker run -d --name database mysqldocker network create -d bridge my-bridge #创建一个新的网桥[root@VM-0-2-centos ~]# docker network ls #列出docker服务网络底层明细NETWORK ID          NAME                DRIVER              SCOPE0dfca8776e29        bridge              bridge              localdec8ce58f992        host                host                local522173622fe8        my-bridge           bridge              local36e1a4828e03        none                null                local<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="创建新的网桥"><a href="#创建新的网桥" class="headerlink" title="创建新的网桥"></a>创建新的网桥</h2><pre class="line-numbers language-none"><code class="language-none">docker network create my-bridge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="容器和网桥绑定"><a href="#容器和网桥绑定" class="headerlink" title="容器和网桥绑定"></a>容器和网桥绑定</h2><pre class="line-numbers language-none"><code class="language-none">docker network connect my-bridge webdocker network connect my-bridge database<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="网桥实现原理"><a href="#网桥实现原理" class="headerlink" title="网桥实现原理"></a>网桥实现原理</h2><pre class="line-numbers language-none"><code class="language-none">外网----&gt;物理网卡（192.168.0.117）-----&gt;docker里的虚拟网卡（172.17.0.1）|-----&gt;redis(172.17.0.2:6375)  |----&gt;server(172.17.0.3:8080)  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/%E7%BD%91%E6%A1%A5.png"></p><h2 id="容器和网桥解除绑定"><a href="#容器和网桥解除绑定" class="headerlink" title="容器和网桥解除绑定"></a>容器和网桥解除绑定</h2><pre class="line-numbers language-none"><code class="language-none">docker network disconnect my-bridge serverdocker network disconnect my-bridge database<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>团队协作中的Githubflow工作流程</title>
      <link href="/hypo-Z.github.io/2022/01/07/29-tuan-dui-xie-zuo-zhong-de-githubflow-gong-zuo-liu-cheng/"/>
      <url>/hypo-Z.github.io/2022/01/07/29-tuan-dui-xie-zuo-zhong-de-githubflow-gong-zuo-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="团队协作中的Github-flow-工作流程"><a href="#团队协作中的Github-flow-工作流程" class="headerlink" title="团队协作中的Github flow 工作流程"></a>团队协作中的Github flow 工作流程</h1><p>作者：知乎@<a href="https://www.zhihu.com/people/hui-xiao-48">回晓</a></p><p>文章引自：<a href="https://zhuanlan.zhihu.com/p/39148914">https://zhuanlan.zhihu.com/p/39148914</a></p><p>有删减</p><p>作为一名开发人员 Git 常用命令每天都在使用，大家肯定信手拈来，但是在团队协作中 Git 的使用姿势和个人开发还是有很多不一样的地方，对于技术团队，期望大家使用规范的 Git 操作流程，规范的 Commit Message，规范的代码风格。这样才能提高团队开发相率和项目的可维护性。</p><p>在本地仓库中有两个固定的分支，分别是master和develop</p><pre class="line-numbers language-none"><code class="language-none">git clone to local<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">git remote -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时可以在控制台输入 <code>git remote -v</code> 命令查看当前远端仓库的地址：</p><pre class="line-numbers language-none"><code class="language-none">origin git@local.git(fetch)origin  git@local.git(push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来我们可以设置一个名字为 upstream 的上游地址，也就是我们项目主仓库的地址<br>在命令行执行：</p><pre class="line-numbers language-none"><code class="language-none">git remote add upstream upstream git@upstream.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加一个别名为upstream(上游)的地址，指向之前 fork 的原项目仓库地址。<br>再次执行 <code>git remote -v</code> 控制台输出如下：</p><pre class="line-numbers language-none"><code class="language-none">origin git@local.git(fetch)origin  git@local.git(push)upstream upstream git@upstream.git(fetch)upstream upstream git@upstream.git(push)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>设置上游地址的目的是当我们通过 pull request 的形式提到主仓库之后，本地仓库需要同步主仓库的代码，并及时更新到 origin（远端）仓库，保证自己托管空间下本地和远端仓库的代码都是最新的。</p><p>之后运行下面几条命令，就可以保持本地仓库与上游（upstream）仓库同步了</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git fetch upstreamgit checkout mastergit merge upstream/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接下来就是本地仓库推送到远端（origin）仓库：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个时候我们可以在本地进行开发了，通常我们规定：</p><ul><li>开发新功能要从 develop 分支上新建一个 feat/[name-desc] 临时分支</li><li>bug 修复 从 master 分支新建一个 hotfix/[name-desc] 临时分支</li></ul><p>如果没有输出任何提交信息的话，即表示 feat/feedback 分支 相对于 develop 分支 是 最新（up-to-date）的。如果有输出的话去执行 <code>git merge --ff-only</code> ，提交路线图就会分叉，为了得到一个干净清爽的提交路线图，合并前最好先执行：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout feat/feedbackgit rebase develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这会将整个工作分支移到 develop 分支的前面（HEAD），可以使 feat/feedback 分支与上游（upstream） develop 分支同步，最后我们将代码推送到远端（origin）分支。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin feat/feedback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样 pull request 通过之后，feat/feedback 分支的代码执行合并操作之后，commit 历史拼接到更新到最新的develop 分支之后，最终得到一个干净舒服的提交线图。</p><h2 id="提交-pull-request"><a href="#提交-pull-request" class="headerlink" title="提交 pull request"></a><strong>提交 pull request</strong></h2><p>从自己远端（origin）仓库的 feat/feedback 分支想要提交到上游（upstream）主仓库的 develop 分支，需要去在主仓库上Open a pull request ：</p><p>在点击Merge pull request 的时候，我们看到有三个选项，简单介绍一下使用场景：</p><h2 id="Create-a-merge-commit"><a href="#Create-a-merge-commit" class="headerlink" title="Create a merge commit"></a><strong>Create a merge commit</strong></h2><p>当点击的是 Create a merge commit 时，feature 分支上所有的 commit 都会被加到develop 分支后面，并且会生成一个 merge commit 新节点。这个 pull request 的合并使用的就是 <code>git merge --ff-only</code>操作，<code>--ff-only</code>解释为仅使用–fast forward(快进)，尽可能将合并解析为快进；不可能时，拒绝合并并以非零状态退出。使用该操作合并之后的commit 路线图看到，使用 <code>git merge --ff-only</code> 没有提交线路分叉的效果。</p><h2 id="Squash-and-merge"><a href="#Squash-and-merge" class="headerlink" title="Squash and merge"></a><strong>Squash and merge</strong></h2><p>当选择 Squash and merge 选项时，实际的git 操作为 <code>git merge --squash</code> 。这个命令会使 该pull request 上的所有 commit 都会合并成一个 commit 放在 develop 分支上，原来的 commit 历史并不会带过来。</p><p>判断是否要用 squash and merge 的标准是待合并的分支的历史是否有意义，如果在开发分支上提交的非常随意，并没有做一个很好的规范性提交，那么可以使用 squash and merge 选项。但是对于大型项目的多人开发过程中，保证每个 commit 必须有意义是开发人员的基本素养及要求，因此不建议在团队开发中使用 squash and merge 选项。</p><h2 id="Rebase-and-merge"><a href="#Rebase-and-merge" class="headerlink" title="Rebase and merge"></a><strong>Rebase and merge</strong></h2><p>当选择 rebase and merge 时，实际上做的操作是<code>git rebase</code>。使用 git rebase 会将 pull request 上的所有提交历史按照原有顺序依次拼接到 develop 分支的头部（HEAD），看起来像是在 develop 分支做了这些提交，但是每个 commit 的SHA1值会发生改变，因此合并到develop 分支的提交的SHA1 值会更新。</p><p>使用 rebase and merge 之后，develop 分支的 commit 路线图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-d27e4e2e19930721d0178255ddf1257d_720w.jpg" alt="img"></p><p>上面两图可以明显看出 commit 的SHA1 发生了变化，因此在使用 git rebase 的时候千万要注意：不要对除了你以外的公共仓库分支执行git rebase，git rebase 的实质放弃现有的提交而去新建内容一样的提交，实际上是不同的提交。</p><p>当然使用 git rebase 会有一定风险，在不完全熟悉 Git 工作流时，不建议去做该操作。比如在结对编程的过程中你将你的提交推送到了你远端仓库的 feature 分支，并且你的伙伴从该分支拉去代码进行后续开发，如果此时你用 git rebase 命令重新提交并再次 pull，那么你的小伙伴要在他提交代码之前将你的提交进行整合，并且你还要拉取他提交的整合过的代码，整个过程就很混乱。</p><p>git rebase 都说是危险的，但是只在从未推送至共用仓库的提交上执行变基命令，就不会有事。因此我们采用 fork 到自己仓库的方式去做 pull request 操作，并没有在主仓库进行操作，在这里，git rebase 是安全的。</p><p>最后总结一下 git rebase 要遵守的法则是：只对尚未推送或分享给别人的本地修改执行 git rebase 操作清理历史，而不对已推送至别处的提交执行 git rebase 操作。比如在 push 所有代码并发起合并请求之前去使用，保证本地进行的提交引用于所有历史提交的最顶端，这种需求非常适合用 git rebase。但是不要对自己仓库以外的副本分支执行 git rebase。</p><p>上面介绍了 pull request merge 的三种方式。对于团队合作的项目中，个人比较推荐使用Create a merge commit 方式，能够清楚的保留每个人提交的上下文，能够记录实际发生过什么，并保留下来，供以后有需求的查阅。</p><h2 id="删除-feature-分支"><a href="#删除-feature-分支" class="headerlink" title="删除 feature 分支"></a><strong>删除 feature 分支</strong></h2><p>使用 pull request merge 之后，对于已经合到 upstream/develop 的远端 feature 分支，可以将其进行删除了：</p><p>本地分支删除：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git branch -D feat/feedback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>远端分支删除：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git push origin :feat/feedback<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里使用 <code>git push [远程名] :[分支名]</code> 的语法去做删除，这是从 <code>git push [远程名] [本地分支]:[远程分支]</code> 而来的，这里省略掉本地分支，相当于将空白推送到要 feature 分支，从而实现删除该分支。</p><h2 id="分支同步"><a href="#分支同步" class="headerlink" title="分支同步"></a><strong>分支同步</strong></h2><p>一段时间内，有多个小伙伴通过 pull request merge 的方式将代码合并到 upstream 上游 develop 分支了，此时我们要将 upstream 上游 develop 分支的代码同步到本地和远端，以保证自己仓库下的代码是最新的。</p><p>此时先要将 upstream 上游的改动同步到本地，再 push 到远端 origin 分支：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout developgit pull upstream developgit push origin develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="新建bugfix-分支"><a href="#新建bugfix-分支" class="headerlink" title="新建bugfix 分支"></a><strong>新建bugfix 分支</strong></h2><p>对于修复紧急 bug 的时候，此时要基于 master 分支新建 bugfix 分支，来实现快速修复：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git checkout mastergit pull upstream mastergit checkout -b hotfix/fixbug master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>修改完 bug， push之后，先提交 pull request 至 upstream/master， 自动化测试和 code review 通过后合并到 upstream/master 分支，将代码部署到生产修复该 bug。此时再从 hotfix/fixbug 分支向 upstream/develop 分支发送 pull request 再合到 develop 分支，最后删除本地和远程的 hotfix/fixbug 分支。下次进行开发功能时再次将上游代码同步到本地和 origin 远程。</p><h2 id="出现冲突的情况"><a href="#出现冲突的情况" class="headerlink" title="出现冲突的情况"></a><strong>出现冲突的情况</strong></h2><p>如果两个 pull request 的操作修改同一个文件，并且都是从同一个分支拉出的新的 feature 分支。其中一个pull request先被合到了develop 分支，另一个 pull request 合并的时候会出现冲突。</p><p><img src="https://pic3.zhimg.com/80/v2-8602d2b3e98efa175de164a0f63addb2_720w.jpg" alt="img"></p><p>假设本地有冲突的分支为 feat/delete，已经合到 upstream/develop 分支为 feat/update，<br>在 feat/delete 分支上进行解决冲突操作：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git pull upstream develop --rebase<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://pic3.zhimg.com/80/v2-16f5d0a604f5d6a925e426265ce1e2e2_720w.jpg" alt="img"></p><p>可以根据控制台输出的提示继续操作</p><p>先手动修改完代码，解决冲突保存之后执行：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git add .git rebase --continuegit push origin feat/delete -f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后 feat/delete 的改动出现在了 feat/update 的时间线后面，可以正常 pull request merge 了，下图是 merge 之后的 commit 路线图：</p><p><img src="https://pic3.zhimg.com/80/v2-30f4aed547b61418d4c80a752c9a089a_720w.jpg" alt="img"></p><h2 id="针对编程的情况"><a href="#针对编程的情况" class="headerlink" title="针对编程的情况"></a><strong>针对编程的情况</strong></h2><p><strong>主动情况</strong></p><p>甲从 develop 新起一个分支为 feat/jia， 甲、乙做的功能有通用的地方，此时甲、乙的代码都不能同时提交 pull request，因为功能缺乏，发到线上可能会挂掉。因此此时需要结对编程，甲开发完公共的部分，推到他的远端仓库，此时先不要提交 pull request。乙来拉取甲的代码继续进行开发，待乙开发完，提交 pull request 到 upstream 上游仓库，举例如下：</p><p>例如甲fork 到自己托管空间的远端仓库为：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git@github.com:jia/github-flow.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时甲将他的代码推送到 他的origin 远端 feat/jia 分支，然后甲告诉乙，你可以继续进行开发了，</p><p>此时乙本地准备开发的分支为 feat/yi，在该分支上进行如下操作：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git remote add pair git@github.com:jia/github-flow.gitgit pull pair feat/jia --rebase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面命令的意思是新建一个名字叫 pair 的远程仓库，地址为甲的仓库地址。 然后拉去该仓库下的 feat/jia 分支同步到当前分支。</p><p>乙在该分支上修改完代码提交后，提 pull request 到甲仓库的 feat/jia 分支，若没有问题，使用 rebase and merge 合进去。code review 通过后，由甲再次提交 pull request 到上游仓库 develop 分支，合并到上游 develop 分支。此时甲乙的 feat/jia、feat/yi 功能分支都可以删掉了。</p><p><strong>被动情况</strong></p><p>如果甲提交 pull request 之后，在 code review 时发现问题，但是自己又不能马上修掉，可能需要他人帮忙，那么这个时候，乙出现来救火，首先乙先从 develop 拉出个 feature 分支，pull 甲的 feature 分支，例如：</p><pre class="line-numbers language-abap" data-language="abap"><code class="language-abap">git <span class="token keyword">remote</span> <span class="token keyword">add</span> pair  git@github<span class="token punctuation">.</span>com<span class="token punctuation">:</span>jia/github<span class="token token-operator punctuation">-</span>flow<span class="token punctuation">.</span>gitgit pull pair feat/jia --rebase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>乙修改完代码后，将改动的之后的内容提 pull request 到甲有问题的当前 feature 分支。甲需要 rebase and merge 合掉乙向甲分支提交的 pull request。再按照标准流程将最后的没有问题的 pull request 合到develop。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><p>开发中需要的注意事项以及建议：</p><ol><li>规范化Commit Message：</li></ol><p>为了保证每个commit 是必须有意义的的同时，开发人员的commit 格式要统一，便于阅读。<br>对于commit 的规范推荐使用 <a href="https://link.zhihu.com/?target=https://github.com/commitizen/cz-cli">cz-cli</a>， 其安装步骤如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">npm install commitizen <span class="token operator">-</span>g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在项目中 命令行运行：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">commitizen init cz-conventional-changelog --save-dev --save-exact<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每次 commit 执行 命令 <code>git cz</code></p><p><img src="https://pic1.zhimg.com/80/v2-c5c85c1727f8e0696eace2374f1808d4_720w.jpg" alt="img"></p><p>\2. 对于上游仓库，要保护develop 和 master 分支，不允许团队成员随意（直接）推送代码到 develop 或 master 分支。<br>\3. 设置 develop 分支为 default 分支，便于提交 pull request 时 base 分支自动默认为 develop分支。<br>\4. Github flow 开发流程中，可以配置 webhook 去自动触发测试环境的发布和自动化测试，只有自动化测试和code review 都通过，才可以被允许合并到 develop 分支。<br>\5. 将某些关键字加入到 pull request 的描述文本中，例如输入close issue #4 ，当 pull request merge 通过并合并到 develop 后，该 issue 会被自动关闭。</p><p>\6. <a href="https://link.zhihu.com/?target=https://help.github.com/articles/creating-a-pull-request-template-for-your-repository/">设置 pull_request 模板</a> 能规范化团队 pull request 的内容，示例模板如下：</p><p><img src="https://pic3.zhimg.com/80/v2-805268f989b03d7e3a831e6f3eef131a_720w.jpg" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>上面简单介绍了在工作中使用的 github flow 工作流。但是最早由于不熟悉整个 Git 流程，一度非常依赖 sourcetree，只敢在 sourcetree 上进行可视化操作，导致对于 git 的工作流程一直不是很理解。因此对于初学者如果一开始就使用Sourcetree 的各种操作但是不知道是什么原理，会很麻烦。因此建议脱离 sourcetree 自己动手命令行多去练习 Git 的一整套工作流程。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Githubflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我作为软件工程师的财务独立之路</title>
      <link href="/hypo-Z.github.io/2022/01/07/28-wo-zuo-wei-ruan-jian-gong-cheng-shi-de-cai-wu-du-li-zhi-lu/"/>
      <url>/hypo-Z.github.io/2022/01/07/28-wo-zuo-wei-ruan-jian-gong-cheng-shi-de-cai-wu-du-li-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="我作为软件工程师的财务独立之路"><a href="#我作为软件工程师的财务独立之路" class="headerlink" title="我作为软件工程师的财务独立之路"></a>我作为软件工程师的财务独立之路</h1><p>文章来源：<a href="https://software.rajivprab.com/2021/12/26/my-path-to-financial-independence-as-a-software-engineer/">https://software.rajivprab.com/2021/12/26/my-path-to-financial-independence-as-a-software-engineer/</a></p><p><a href="https://www.forbes.com/sites/financialfinesse/2019/08/06/3-ways-to-invest-for-financial-independence"><img src="https://softwarerajivprab.files.wordpress.com/2021/11/finances.png" alt="img"></a></p><p>我生命中的一个分水岭时刻是作为一名 20 岁的实习生参加关于个人理财的工作场所演示。在一小时内，我了解了买入并持有投资和复合增长的力量。我了解到，通过财务纪律和投资规划，即使是年薪五位数的普通工程师也可以在 30 多岁时成为百万富翁。这既鼓舞人心又充满活力。我一直认为我需要工作到 60 岁，才能支付账单和维持生计。成为“千万富翁”是梦想，而不是计划。这次演讲改变了我对财务命运的看法。</p><p>从那时起，财务独立是我优先考虑和追求的事情。今年，在企业界工作了 12 年后，我欣喜若狂，我终于实现了自己的目标。这篇文章是关于我旅程的具体细节，以防其他人发现它有助于制定自己的路线。</p><p><em>免责声明：我承认我很荣幸，尤其是在我所拥有的教育机会方面。在我的旅程中，有许多其他人难以或不可能复制的步骤。但也许还有其他一些你会发现在你自己的生活中更有用和适用的方法。</em></p><p><em>第二个免责声明。不幸的是，谈论金钱在社会上有很多污名。那些赚得不多的人会感到尴尬。而那些赚得更多的人往往被告知要隐瞒这一事实，以免被视为傲慢和自负。我认为这是一种耻辱。金钱应该像对待健康一样对待。这是生活的必需品，也是我们应该优先考虑的事情。但不是定义你或你作为一个人的价值的东西。我们越公开谈论金钱，我们就越能互相学习，我们也能更好地管理自己的财务。</em></p><hr><p>不用多说，这里总结了我在职业生涯中每年赚了多少钱，我存了多少，以及我的储蓄如何随着时间的推移而增长。</p><table><thead><tr><th><strong>年</strong></th><th><strong>雇主</strong></th><th><strong>年收入</strong></th><th><strong>花费金额（不含税）</strong></th><th><strong>净值</strong></th><th><strong>笔记</strong></th></tr></thead><tbody><tr><td>2009年</td><td>英特尔</td><td>100,000</td><td>38,000</td><td>35,000</td><td>获得工程硕士学位的新大学毕业生</td></tr><tr><td>2010年</td><td>英特尔</td><td>100,000</td><td>38,000</td><td>75,000</td><td></td></tr><tr><td>2011年</td><td>英特尔</td><td>105,000</td><td>38,000</td><td>122,000</td><td></td></tr><tr><td>2012年</td><td>英特尔/太阳</td><td>115,000</td><td>38,000</td><td>175,000</td><td></td></tr><tr><td>2013年</td><td>太阳</td><td>125,000</td><td>39,000</td><td>236,000</td><td></td></tr><tr><td>2014年</td><td>太阳</td><td>125,000</td><td>39,000</td><td>320,000</td><td></td></tr><tr><td>2015年</td><td>对冲基金</td><td>230,000</td><td>56,000</td><td>450,000</td><td>从硬件 -&gt; 软件的职业转向</td></tr><tr><td>2016年</td><td>对冲基金/谷歌</td><td>230,000</td><td>56,000</td><td>505,000</td><td></td></tr><tr><td>2017年</td><td>谷歌</td><td>300,000</td><td>64,000</td><td>850,000</td><td></td></tr><tr><td>2018年</td><td>谷歌</td><td>330,000</td><td>68,000</td><td>990,000</td><td>谷歌股价上涨导致收入增加</td></tr><tr><td>2019年</td><td>亚马逊</td><td>475,000</td><td>94,000</td><td>1,130,000</td><td></td></tr><tr><td>2020年</td><td>亚马逊</td><td>475,000</td><td>78,000</td><td>1,470,000</td><td></td></tr><tr><td>2021年</td><td>亚马逊</td><td>625,000</td><td>78,000</td><td>2,400,000</td><td>亚马逊股价上涨导致收入增加</td></tr></tbody></table><p>我在此过程中学到的一些教训：</p><ul><li><p>当你得到大幅加薪时，很容易把钱花在奢侈品上，比如更漂亮的公寓或豪华的汽车。在某种程度上，这当然也是我所做的。但尽可能避免加速你的享乐跑步机，而是省下这笔钱</p><p>在可能的情况下，把钱花在体验上，而不是事情上——我已经进行了无数次洲际旅行，每周出去吃很多次，同时仍然节俭租金和汽车付款。和我花钱买的所有东西相比，经济独立是最大的奢侈</p></li><li><p>我看到一个常见的模因，旧金山和纽约等城市的房价贵得离谱。在上述几乎整个时间段内，我都住在旧金山、纽约或距离很短的通勤地点。我无法谈论抚养孩子所涉及的费用，但作为一个没有孩子的人，我能够找到与我的收入相关的价格合理的选择（这在大多数地方是不可能的）。和室友住在一起时，我支付了约 1000 美元的租金，独居时支付了约 2000 美元的租金</p><p>人们喜欢讨厌与室友住在一起的想法（我听说它被讽刺地描述为贫困）。但它造就了极其有趣的社交生活，以及有趣的生活体验的源泉。更不用说显着的租金节省</p></li><li><p>投资你的钱。不要让它在银行闲置。作为一个职业生涯很长的年轻人，你有能力承担风险。大部分投资于<a href="https://investor.vanguard.com/etf/profile/VT">全球股市</a>。您将定期遭受损失，尤其是在经济衰退期间。但平均而言，你会领先。复合增长非常强大，让我的净资产增加了近 100 万美元。</p><p>我自己的投资组合完全由美国股票 ( <a href="https://investor.vanguard.com/etf/profile/VTI">VTI</a> )、发达国家 ( <a href="https://investor.vanguard.com/etf/profile/VEA">VEA</a> ) 和新兴市场 ( <a href="https://investor.vanguard.com/etf/profile/VWO">VWO</a> ) 组成。近年来，我还加入了房地产（<a href="https://money.usnews.com/funds/etfs/real-estate/ishares-global-reit-etf/reet">REET</a>）。我的确切分配有所不同，但我通常在上述每一项中投入了相同的金额。如果您更厌恶风险，请添加债券基金（<a href="https://investor.vanguard.com/etf/profile/BND">BND</a> ) 到您的投资组合</p><p>不要试图为市场计时或挑选赢家和输家。平均而言，这些都是失败的策略。如果您确信自己拥有非凡的才能并想把握市场时机或投资特定股票，请每周至少花 20 小时进行投资研究</p></li><li><p>拥有房屋是您将要做出的最大的财务决定 - 清楚地了解利弊。使用<a href="https://www.nytimes.com/interactive/2014/upshot/buy-rent-calculator.html">专家计算器</a>来评估购买特定房屋后您能赚或亏的金额。在很多情况下，租房在经济上比买房更好。</p><p>毫无疑问 - 住房是基本需求，而拥有房屋则是可有可无的。说你<em>“需要”</em>买房，就像说你<em>“需要”</em>拥有价值一百万美元的谷歌股票</p></li><li><p>如果您仍然是学生或准备进入研究生院，请尽一切努力获得进入前 5 名的硕士课程。毕业只需一年左右，为你的职业生涯打开大门</p><p>如果你的学生时代结束了，你没有引人注目的简历，你可以在FANG工作得到同样的结果（或类似）公司几年。好消息是，与律师事务所或投资银行不同，FANG 公司会为大多数本地软件开发人员提供面试机会（虽然招聘门槛确实很高）</p></li><li><p>当我从计算机硬件工程师转变为软件工程师时，我职业收入的最大提升是。领先公司的软件工程师可以赚到与医生和投资银行家不相上下的巨额收入。还有许多其他职业，即使是工程师，尽管我同样才华横溢，但我的收入会少得多。您选择的职业道路将对您的薪酬产生巨大影响</p><p>转换职业是我必须做的最困难的事情，需要大量投入我几个月的空闲时间，而且我不得不将多年来的自我融入我的新职业。但它得到了很好的回报。当谈到利润丰厚的职业机会时，始终保持开放的心态，不要害怕改变你的职业生涯。如果我今天 20 岁，我会认真考虑专攻机器学习</p></li><li><p>与上述类似，我听说有才华的软件开发人员几乎不可能在美国以外的任何国家获得类似的收入。如果您优先考虑早期财务独立，请强烈考虑搬到这里。要做到这一点，最简单的方法可能是暂停工作 1 年，然后在美国攻读硕士学位。虽然我也遇到了其他持工作签证搬到这里的人</p></li><li><p>不要让短期的恐惧妨碍您的长期成功。我在硬件行业的前 5 年阻碍了我的职业发展，从那时起，我一直在追赶直接进入软件行业的同学。讽刺的是，当我在大学一年级时，有人问我为什么不想主修计算机科学，我回答说：<em>“从高中开始编程的人很多，相比之下，我会处于劣势。他们。”</em> 有趣的是，我最终还是转行了……7 年后……处于更大的劣势</p></li><li><p>如果您擅长面试，那么您需要做出的最大决定是初创公司与 FANG。在任何时候，你都会在 FANG 公司赚更多的钱，同时工作的时间更少。刚毕业时差异较小，但作为高级开发人员时差异尤其明显，当你可以在 FANGs 赚 250-500k 时，同时每周工作 40 小时。</p><p>另一方面，你可以在初创公司更快地发展你的职业生涯，并更快地获得领导经验。您还将获得更多机会从事绿地项目，在短时间内建造更多东西，并减少官僚主义的阻碍。</p><p>如果你的目标是在朝九晚五的时候赚 30 万/年，你应该坚持 FANG 公司。<br>如果你的目标是创造很多很酷的东西或者有一天成为一名 VP/SVP/C 级执行官，你应该做早期创业公司。<br>如果可以重来一次，我会用我职业生涯的前 6 年做初创公司。如果我的创业公司都没有成功，后来加入 FANG 公司担任高级工程师</p></li><li><p>你应该强烈考虑每 3 年到别处面试。这需要在面试准备和处理拒绝方面付出努力，但您可以获得显着的加薪和晋升。练习你的面试技巧是你能做出的最好的财务投资。</p></li><li><p>这并不是说你目前的工作不重要——它确实重要。始终追求卓越，并将自己置于可以学习和成长的环境中。在我接受谷歌面试之前的一年里，我利用晚上和周末的时间来引导一家初创公司。又是在我加入亚马逊的前一年。我这样做并不是为了给任何人留下深刻印象，但我怀疑它帮助我获得了异常丰厚的工作机会。无论您走到哪里，您的声誉、人脉、您掌握的技能以及您学到的课程都会与您同在。</p></li><li><p>我听说很多人说你应该忽略公平，只看工作机会中的基本工资。这是一个糟糕的建议——总是看总薪酬，而不是其中的任何一部分。如果有的话，股权给了你选择权。如果股价大幅下跌，可以通过换公司来重置。如果它显着上升，您将获得显着的补偿增加。这对我在谷歌和亚马逊都有很大帮助。</p><p>许多州规定，准雇主询问您目前的工资是非法的。即使你不是生活在这样的状态，这也是一个很好的指导方针。告诉招聘人员你期望的薪酬，而不是你目前的薪酬。根据经验，每当我换工作时，我预计薪酬会增加 30%。任何低于 20% 的情况，我建议您等待更好的结果出现。</p><p>你的薪酬期望越高，你就越需要在面试和工作中给他们留下深刻印象。所以这是一把双刃剑。准备好实现您的要求</p></li></ul><hr><p>您可能想知道这一切的意义何在。金钱买不到幸福。此外，如果你只是打算在 30 多岁时退休，那么优化你的职业生涯有什么意义呢？</p><p>确实，金钱或事业上的成功并不能买到幸福。但真正能买到幸福的是独立和自主。因此，我的目标是优化我的职业和财务状况，以便我能够在 30 多岁时“退休”。</p><p>现在我已经“退休”了，理论上我可以在海滩上度过余生。但这不是我想要的，也不是我追求经济独立的原因。我的真正目标一直是按照我自己的方式追求我的人生目标，而不必担心金钱。</p><p>作为在我工作过的每家公司中都发现令人沮丧的问题的人，我目前的目标是从头开始建立一家初创公司。我可以独立工作并快速做出决定，而无需参加无休止的会议或等待数天/数周的批准。一个我可以尝试解决我在其他公司中反复出现的问题的地方。一个我可以尝试领导力的地方，而不仅仅是中层管理人员。</p><p>除了我的创业目标之外，我还有其他目标，我很高兴在未来几年追求这些目标。您可能已经从这篇博客中猜到了，写作是我的爱好之一，我希望有朝一日成为一名出版作家。辅导和指导他人也是我过去喜欢的事情——我正在考虑担任兼职导师/导师的想法。最后，我打算将我的大部分积蓄用于慈善事业。如果我的任何一家初创公司取得成功，我还计划成立一个慈善基金会并积极参与慈善事业。</p><hr><p>这些都是我过去在某种程度上做过的事情，但我从来没有能够在兼顾全职工作的同时给他们应得的时间和精力。此外，我知道一个事实，如果我在 20 多岁的时候尝试成为一名全职作家，我一生中的大部分时间都会为财务稳定性而感到压力。赚钱的诱惑会威胁到我创造性努力的完整性。但现在我在经济上独立了，我有能力全心全意地追求我的人生目标。没有任何货币预期，或担心支付账单。</p><p>最终对我来说，这就是财务独立的全部意义所在，以及为什么这一切都是值得的。这不是关于坐在海滩上喝掉你的生命。这是关于拥有追求人生目标的自由，无论它是什么，无论它可能多么不切实际。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在新年伊始写给自己的一封信</title>
      <link href="/hypo-Z.github.io/2022/01/01/27-zai-xin-nian-yi-shi-xie-gei-zi-ji-de-yi-feng-xin/"/>
      <url>/hypo-Z.github.io/2022/01/01/27-zai-xin-nian-yi-shi-xie-gei-zi-ji-de-yi-feng-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="致2022年的新我"><a href="#致2022年的新我" class="headerlink" title="致2022年的新我"></a>致2022年的新我</h1><p>2021年刚刚过去，我想写下这篇文章作为我在2022年迷茫的时候能看到，给我一些<br>力量；<br>在年初时，我就给我自己许下了两个愿望，1.换一个工作，并且工资期望不错；2.减肥<br>到60公斤。<br>这两个愿望在2021年快结束时，我都实现了，我深深的知道我在这其中付出了多少<br>努力，也是因为这两个愿望使得我的2021变得充实且没有遗憾，在这一年，我为了换<br>工作自学了go语言，并且靠着我的努力寻找到了一份超出我自己期望的工作，我很满意<br>我的薪资，但是我知道不能因满意而使自己堕怠的原因，我还需要在这条路上不停的<br>前进。二是减肥，我第一次是靠着我的努力真实的感受到付出汗水的快乐，因为变瘦<br>能使我变得自信，使我能认识到自己的潜力，并不是我做不到，而是我愿不愿意去做<br>，并且坚持下去。对于我的2021我很满意，一、我认识到做自己认为正确的事情并且<br>坚持下去。二、学会和自己独处，第一次在一个异地一个人生活，难免会不习惯，虽然<br>都来了四个月了，我还是不是很释然，一个人的独处能力还需加强。三、认识的身体是<br>奋斗的本钱，假如我不爱惜自己的身体，那么身体的病痛和难受就会接踵而至，健身<br>很重要。四、读书和学习不能停下，你不进步，时代就会抛弃你；<br>2022的新目标：1、最重要的是健身，能在21年的基础上锻炼出6块腹肌；2、找到一个<br>伴侣，在这一方面我不强求，这是希望能遇上一段缘分；3、在工作基础上不断加强<br>，做到自如应对项目的相关事宜，并不断学习；4、再学习一下一个游戏引擎编程，不<br>要求达到工作需求，只是当作自己的一项投资，一个自己探索的方向，也是自己的下一个<br>新目标。<br>新的一年已经开始了，我希望在自己迷茫时能想起自己写的这边文章，想想自己的目标，<br>和自己想走的自己的路。</p><p>加油！hypo！加油！2022！</p><p><img src="https://hypo-pictrue-1308430808.cos.ap-shanghai.myqcloud.com/hypo.ltd-%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8/IMG_2827.jpg" alt="2021"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
            <tag> 2022目标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的B计划是什么？</title>
      <link href="/hypo-Z.github.io/2021/12/23/26-ni-de-b-ji-hua-shi-shi-me/"/>
      <url>/hypo-Z.github.io/2021/12/23/26-ni-de-b-ji-hua-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="你的B计划是什么？"><a href="#你的B计划是什么？" class="headerlink" title="你的B计划是什么？"></a>你的B计划是什么？</h1><p>最近看新闻总是看到各大互联网公司裁员的消息，自己作为刚入互联网的新人，不禁就感叹到IT行业的残酷，意识到自己正处在一个正在风云变化的时代。<br>一是国家倡导共同富裕，希望能减小国家间的贫富差距，打击互联网巨头的无序扩张；<br>二是互联网巨头们也感受到了压力，需要减轻财务负担，大量裁掉底层技术人员，导致许多技术人员失去工作岗位。<br>三是大量的高龄技术人员越来越受到企业的弃用，从而希望招入年轻并薪资待遇较低的大学生入行；</p><p>这样就导致技术人员的焦虑感越来越强，毕竟互联网就是吃年轻饭的，淘汰年纪大的给年轻人让位，也可以使年轻人得到更多的机会，之前看到一遍新闻：说是互联网HR有一个潜规则就是28岁以后的简历一律不看，经人验证，情况属实！我看到这就很惊讶！28岁正是一个青壮年的时候，人的黄金年纪，之后互联网都看不上了，就说明整个行业的平均年纪就在28岁左右，很年轻。我计算了一下给我在互联网的红利时期也就6年左右，时间很短！</p><p>恐惧的感觉油然而生，又刚阅读的阮一峰的著作《未来的幸存者》一书，就感觉对远期互联网的未来感到悲观，虽然远不及他书中对人类的未来着想，我只能顾及我自己。就像他书中所说：<br>对于人生来说，你现在的职业就是A计划，应该努力追求职业成功。但是，也要做好两手准备，万一A计划失败，还需要一个B计划，对自己的退路有所安排。一旦有了B计划，我建议，最好立刻动手做一些准备。不一定为了真的实施，但至少让它从一个很模糊的设想，变得稍微具体一点。千万不要只是想想而已，人生缺少的就是行动，只有迈出第一步，才有后面的旅程。</p><p>我是应该想想我的B计划是什么了，虽然不是立即就要做出改变，但是是应该做一些准备了，并在这几年的时间里面做到能够在生活发生重大变化的时候能够从容一些，其实想想普通人并没有什么能够做终身的职业，那些能做终身的职业的人都是伟人，我不是，所以需要为自己找到一条后路，以备不时之需。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一个Dockerfile书写笔记</title>
      <link href="/hypo-Z.github.io/2021/12/23/dockerfile-shu-xie-bi-ji/"/>
      <url>/hypo-Z.github.io/2021/12/23/dockerfile-shu-xie-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-制作镜像"><a href="#docker-制作镜像" class="headerlink" title="docker 制作镜像"></a>docker 制作镜像</h2><p>在<code>Dockerfile</code>所在的目录下执行<code>docker build</code>构建镜像</p><pre class="line-numbers language-none"><code class="language-none">➜  docker build -t 镜像名 .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>docker</code>会依据<code>Dockerfile</code>里的指令构建镜像，整个构建的过程类似下面：</p><h3 id="验证镜像"><a href="#验证镜像" class="headerlink" title="验证镜像"></a>验证镜像</h3><p>这一步其实可以省略，不过为了确保制作的镜像是没有问题，我们通过<code>docker run</code>命令用这个镜像运行容器验证一下。</p><pre class="line-numbers language-none"><code class="language-none">➜ docker run -d -p 本机端口:容器端口 --rm --name container名 镜像名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这里，我们指示<code>docker</code>从源镜像<code>运行容器，将主机端口</code>绑定到容器的内部端口``，以后台模式（-d）运行容器，给此容器命名为<code>容器名</code>，并在容器结束运行后自动删除容器（–rm）。</p><h3 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h3><p>下面就来介绍一下怎么使用<code>Docker</code>的多阶段构建制作<code>Go</code>应用的镜像。</p><p>镜像的<code>Dockerfile</code>长这样：</p><pre class="line-numbers language-none"><code class="language-none">FROM golang:1.14-alpineRUN mkdir /appCOPY . /appWORKDIR /appRUN go build -o main . CMD ["/app/main"]复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们使用用多阶段构建的方式构建镜像后，<code>Dockerfile</code>会变成类似下面这样：</p><pre class="line-numbers language-none"><code class="language-none">FROM golang:alpine AS buildRUN mkdir /appCOPY . /appWORKDIR /appRUN CGO_ENABLED=0 GOOS=linux go build -o myapp### FROM scratch as finalCOPY --from=build /app/myapp .CMD ["/myapp"]复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="记录一个有sqlite3数据库和golang的Dockerfile书写笔记"><a href="#记录一个有sqlite3数据库和golang的Dockerfile书写笔记" class="headerlink" title="记录一个有sqlite3数据库和golang的Dockerfile书写笔记"></a>记录一个有sqlite3数据库和golang的Dockerfile书写笔记</h2><h3 id="以ubuntu为基础镜像"><a href="#以ubuntu为基础镜像" class="headerlink" title="以ubuntu为基础镜像"></a>以ubuntu为基础镜像</h3><pre class="line-numbers language-dockerfile" data-language="dockerfile"><code class="language-dockerfile">FROM ubuntu:latest As build# 配置环境变量ENV GOROOT=/usr/lib/goENV PATH=$PATH:/usr/lib/go/binENV GOPATH=/root/goENV PATH=$GOPATH/bin/:$PATHENV DEBIAN_FRONTEND=noninteractive# 执行命令RUN set -x; buildDeps='gcc libc6-dev make wget' \    &amp;&amp; apt-get update\    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget https://go.dev/dl/go1.17.5.linux-amd64.tar.gz\    &amp;&amp; tar -xzvf go1.17.5.linux-amd64.tar.gz -C /usr/lib\    &amp;&amp; export GOROOT=/usr/lib/go \    &amp;&amp; ln -s /usr/local/go/bin/* /usr/bin/ \    &amp;&amp; export PATH=$PATH:/usr/lib/go/bin \    &amp;&amp; export GOPATH=/root/go\    &amp;&amp; export PATH=$GOPATH/bin/:$PATH\    &amp;&amp; rm go1.17.5.linux-amd64.tar.gz\    &amp;&amp; wget https://www.sqlite.org/2021/sqlite-autoconf-3370000.tar.gz\    &amp;&amp; tar -xzvf sqlite-autoconf-3370000.tar.gz -C /usr/lib\    &amp;&amp; rm sqlite-autoconf-3370000.tar.gz\    &amp;&amp; cd /usr/lib/sqlite-autoconf-3370000\    &amp;&amp; ./configure --prefix=/usr/local \    &amp;&amp; make \    &amp;&amp; make install \    &amp;&amp; cd .. \    &amp;&amp; mkdir /authCOPY . /auth/WORKDIR /authEXPOSE 8000#安装库依赖项RUN go mod tidy\    &amp;&amp; go build -o server\    &amp;&amp; apt-get purge -y --auto-remove $buildDeps####FROM ubuntu:latest as final#镜像构建参数COPY --from=build /auth/server .CMD ["/server"]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Go</code>项目应用的<code>Dockerfile</code>通常大概类似这样，但是每个项目的细节可能有所不同。<code>FROM ubuntu:latest</code>指定了开始阶段的基础映像（其中包含ubuntu的操作系统，无工具和库，用于构建程序），<code>AS build</code>是给这个阶段取名为<code>build</code>。</p><p>ubuntu是专门为容器设计的小型<code>Linux</code>发行版。这个<code>Dockerfile</code>中使用了两次<code>FROM</code>指令，第二条<code>FROM ubuntu</code>行，它告诉<code>Docker</code>从一个全新的，完全空的容器镜像重新开始，然后将上个阶段编译好的程序复制到其中。这个才是我们随后将用于运行的<code>Go</code>应用程序的容器镜像。</p><p><code>Docker</code>用于<code>Go</code>程序的多阶段构建很常见，使用<code>新的</code>镜像可以节省大量空间，因为我们实际上不需要<code>Go</code>工具或其他任何东西来运行我们的编译好的程序，这可能也是<code>Go</code>在容器时代的一个优势吧。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Golang </tag>
            
            <tag> Docker </tag>
            
            <tag> Dockerfile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是消息队列</title>
      <link href="/hypo-Z.github.io/2021/12/20/24-shi-me-shi-xiao-xi-dui-lie/"/>
      <url>/hypo-Z.github.io/2021/12/20/24-shi-me-shi-xiao-xi-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h1><h2 id="一、消息模型"><a href="#一、消息模型" class="headerlink" title="一、消息模型"></a>一、消息模型</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011250613.png" alt="img"></p><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011410374.png" alt="img"></p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191212011747967.png" alt="img"></p><h2 id="二、使用场景"><a href="#二、使用场景" class="headerlink" title="二、使用场景"></a>二、使用场景</h2><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p><p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p><p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p><h3 id="流量削锋"><a href="#流量削锋" class="headerlink" title="流量削锋"></a>流量削锋</h3><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p><p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p><p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p><h2 id="三、可靠性"><a href="#三、可靠性" class="headerlink" title="三、可靠性"></a>三、可靠性</h2><h3 id="发送端的可靠性"><a href="#发送端的可靠性" class="headerlink" title="发送端的可靠性"></a>发送端的可靠性</h3><p>发送端完成操作后一定能将消息成功发送到消息队列中。</p><p>实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</p><h3 id="接收端的可靠性"><a href="#接收端的可靠性" class="headerlink" title="接收端的可靠性"></a>接收端的可靠性</h3><p>接收端能够从消息队列成功消费一次消息。</p><p>两种实现方法：</p><ul><li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li><li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://developers-club.com/posts/270339/">Observer vs Pub-Sub(opens new window)</a></li><li><a href="https://blog.csdn.net/lizhitao/article/details/47723105">消息队列中点对点与发布订阅区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是分布式？</title>
      <link href="/hypo-Z.github.io/2021/12/17/23-shi-me-shi-fen-bu-shi/"/>
      <url>/hypo-Z.github.io/2021/12/17/23-shi-me-shi-fen-bu-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h1><h2 id="一、分布式锁"><a href="#一、分布式锁" class="headerlink" title="一、分布式锁"></a>一、分布式锁</h2><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p><p>阻塞锁通常使用互斥量来实现：</p><ul><li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li><li>互斥量为 1 表示未锁定状态。</li></ul><p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p><h3 id="数据库的唯一索引"><a href="#数据库的唯一索引" class="headerlink" title="数据库的唯一索引"></a>数据库的唯一索引</h3><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。</p><p>存在以下几个问题：</p><ul><li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁；</li><li>只能是非阻塞锁，插入失败直接就报错了，无法重试；</li><li>不可重入，已经获得锁的进程也必须重新获取锁。</li></ul><h3 id="Redis-的-SETNX-指令"><a href="#Redis-的-SETNX-指令" class="headerlink" title="Redis 的 SETNX 指令"></a>Redis 的 SETNX 指令</h3><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p><h3 id="Redis-的-RedLock-算法"><a href="#Redis-的-RedLock-算法" class="headerlink" title="Redis 的 RedLock 算法"></a>Redis 的 RedLock 算法</h3><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p><ul><li>尝试从 N 个互相独立 Redis 实例获取锁；</li><li>计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；</li><li>如果获取锁失败，就到每个实例上释放锁。</li></ul><h3 id="Zookeeper-的有序节点"><a href="#Zookeeper-的有序节点" class="headerlink" title="Zookeeper 的有序节点"></a>Zookeeper 的有序节点</h3><h4 id="抽象模型"><a href="#抽象模型" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/aefa8042-15fa-4e8b-9f50-20b282a2c624.png"></p><h4 id="2-节点类型"><a href="#2-节点类型" class="headerlink" title="2. 节点类型"></a>2. 节点类型</h4><ul><li>永久节点：不会因为会话结束或者超时而消失；</li><li>临时节点：如果会话结束或者超时就会消失；</li><li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li></ul><h4 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3. 监听器"></a>3. 监听器</h4><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p><h4 id="4-分布式锁实现"><a href="#4-分布式锁实现" class="headerlink" title="4. 分布式锁实现"></a>4. 分布式锁实现</h4><ul><li>创建一个锁目录 /lock；</li><li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li><li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li><li>执行业务代码，完成后，删除对应的子节点。</li></ul><h4 id="5-会话超时"><a href="#5-会话超时" class="headerlink" title="5. 会话超时"></a>5. 会话超时</h4><p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，这种实现方式不会出现数据库的唯一索引实现方式释放锁失败的问题。</p><h4 id="6-羊群效应"><a href="#6-羊群效应" class="headerlink" title="6. 羊群效应"></a>6. 羊群效应</h4><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应，一只羊动起来，其它羊也会一哄而上），而我们只希望它的后一个子节点收到通知。</p><h2 id="二、分布式事务"><a href="#二、分布式事务" class="headerlink" title="二、分布式事务"></a>二、分布式事务</h2><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><p>分布式锁和分布式事务区别：</p><ul><li>锁问题的关键在于进程操作的互斥关系，例如多个进程同时修改账户的余额，如果没有互斥关系则会导致该账户的余额不正确。</li><li>而事务问题的关键则在于事务涉及的一系列操作需要满足 ACID 特性，例如要满足原子性操作则需要这些操作要么都执行，要么都不执行。</li></ul><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><h4 id="1-运行过程"><a href="#1-运行过程" class="headerlink" title="1. 运行过程"></a>1. 运行过程</h4><h5 id="1-1-准备阶段"><a href="#1-1-准备阶段" class="headerlink" title="1.1 准备阶段"></a>1.1 准备阶段</h5><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/44d33643-1004-43a3-b99a-4d688a08d0a1.png"></p><h5 id="1-2-提交阶段"><a href="#1-2-提交阶段" class="headerlink" title="1.2 提交阶段"></a>1.2 提交阶段</h5><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/d2ae9932-e2b1-4191-8ee9-e573f36d3895.png"></p><h4 id="2-存在的问题"><a href="#2-存在的问题" class="headerlink" title="2. 存在的问题"></a>2. 存在的问题</h4><h5 id="2-1-同步阻塞"><a href="#2-1-同步阻塞" class="headerlink" title="2.1 同步阻塞"></a>2.1 同步阻塞</h5><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞等待状态，无法进行其它操作。</p><h5 id="2-2-单点问题"><a href="#2-2-单点问题" class="headerlink" title="2.2 单点问题"></a>2.2 单点问题</h5><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在提交阶段发生故障，所有参与者会一直同步阻塞等待，无法完成其它操作。</p><h5 id="2-3-数据不一致"><a href="#2-3-数据不一致" class="headerlink" title="2.3 数据不一致"></a>2.3 数据不一致</h5><p>在提交阶段，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><h5 id="2-4-太过保守"><a href="#2-4-太过保守" class="headerlink" title="2.4 太过保守"></a>2.4 太过保守</h5><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/476329d4-e2ef-4f7b-8ac9-a52a6f784600.png"></p><h2 id="三、CAP"><a href="#三、CAP" class="headerlink" title="三、CAP"></a>三、CAP</h2><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a14268b3-b937-4ffa-a34a-4cc53071686b.jpg"></p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p><p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><h3 id="分区容忍性"><a href="#分区容忍性" class="headerlink" title="分区容忍性"></a>分区容忍性</h3><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><h3 id="权衡"><a href="#权衡" class="headerlink" title="权衡"></a>权衡</h3><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p><p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p><ul><li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li><li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li></ul><h2 id="四、BASE"><a href="#四、BASE" class="headerlink" title="四、BASE"></a>四、BASE</h2><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p><h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><h2 id="五、Paxos"><a href="#五、Paxos" class="headerlink" title="五、Paxos"></a>五、Paxos</h2><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p><p>主要有三类节点：</p><ul><li>提议者（Proposer）：提议一个值；</li><li>接受者（Acceptor）：对每个提议进行投票；</li><li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/b988877c-0f0a-4593-916d-de2081320628.jpg"></p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p><h4 id="1-Prepare-阶段"><a href="#1-Prepare-阶段" class="headerlink" title="1. Prepare 阶段"></a>1. Prepare 阶段</h4><p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1a9977e4-2f5c-49a6-aec9-f3027c9f46a7.png"></p><p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p><p>如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb44307f-8e98-4ff7-a918-31dacfa564b4.jpg"></p><p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p><p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bcc58ad-bf7f-485c-89b5-e7cafc211ce2.jpg"></p><h4 id="2-Accept-阶段"><a href="#2-Accept-阶段" class="headerlink" title="2. Accept 阶段"></a>2. Accept 阶段</h4><p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p><p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p><p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9b838aee-0996-44a5-9b0f-3d1e3e2f5100.png"></p><h4 id="3-Learn-阶段"><a href="#3-Learn-阶段" class="headerlink" title="3. Learn 阶段"></a>3. Learn 阶段</h4><p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/bf667594-bb4b-4634-bf9b-0596a45415ba.jpg"></p><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><h4 id="1-正确性"><a href="#1-正确性" class="headerlink" title="1. 正确性"></a>1. 正确性</h4><p>指只有一个提议值会生效。</p><p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p><h4 id="2-可终止性"><a href="#2-可终止性" class="headerlink" title="2. 可终止性"></a>2. 可终止性</h4><p>指最后总会有一个提议生效。</p><p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p><h2 id="六、Raft"><a href="#六、Raft" class="headerlink" title="六、Raft"></a>六、Raft</h2><p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p><ul><li><a href="http://thesecretlivesofdata.com/raft">Raft: Understandable Distributed Consensus(opens new window)</a></li></ul><h3 id="单个-Candidate-的竞选"><a href="#单个-Candidate-的竞选" class="headerlink" title="单个 Candidate 的竞选"></a>单个 Candidate 的竞选</h3><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><ul><li>下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118015898.gif"></p><ul><li>此时 Node A 发送投票请求给其它所有节点。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118445538.gif"></p><ul><li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118483039.gif"></p><ul><li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521118640738.gif"></p><h3 id="多个-Candidate-竞选"><a href="#多个-Candidate-竞选" class="headerlink" title="多个 Candidate 竞选"></a>多个 Candidate 竞选</h3><ul><li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119203347.gif"></p><ul><li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111521119368714.gif"></p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><ul><li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/71550414107576.gif"></p><ul><li>Leader 会把修改复制到所有 Follower。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/91550414131331.gif"></p><ul><li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/101550414151983.gif"></p><ul><li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/111550414182638.gif"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li><li><a href="https://redis.io/topics/distlock">Distributed locks with Redis(opens new window)</a></li><li><a href="http://www.linkedkeeper.com/detail/blog.action?bid=1023">浅谈分布式锁(opens new window)</a></li><li><a href="http://www.dengshenyu.com/java/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2017/10/23/zookeeper-distributed-lock.html">基于 Zookeeper 的分布式锁(opens new window)</a></li><li><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">聊聊分布式事务，再说说解决方案(opens new window)</a></li><li><a href="https://coolshell.cn/articles/10910.html">分布式系统的事务处理(opens new window)</a></li><li><a href="https://juejin.im/entry/577c6f220a2b5800573492be">深入理解分布式事务(opens new window)</a></li><li><a href="http://www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/">What is CAP theorem in distributed database system?(opens new window)</a></li><li><a href="http://harry.me/blog/2014/12/27/neat-algorithms-paxos/">NEAT ALGORITHMS - PAXOS(opens new window)</a></li><li>[Paxos By Example](</li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是缓存？</title>
      <link href="/hypo-Z.github.io/2021/12/16/22-shi-me-shi-huan-cun/"/>
      <url>/hypo-Z.github.io/2021/12/16/22-shi-me-shi-huan-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h1><h2 id="一、缓存特征"><a href="#一、缓存特征" class="headerlink" title="一、缓存特征"></a>一、缓存特征</h2><h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h3 id="最大空间"><a href="#最大空间" class="headerlink" title="最大空间"></a>最大空间</h3><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ul><li>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</li><li>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</li><li>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</li></ul><h2 id="二、缓存位置"><a href="#二、缓存位置" class="headerlink" title="二、缓存位置"></a>二、缓存位置</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><p>###Java 内部的缓存</p><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p><h3 id="CPU-多级缓存"><a href="#CPU-多级缓存" class="headerlink" title="CPU 多级缓存"></a>CPU 多级缓存</h3><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h2 id="三、CDN"><a href="#三、CDN" class="headerlink" title="三、CDN"></a>三、CDN</h2><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>CDN 主要有以下优点：</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15313ed8-a520-4799-a300-2b6b36be314f.jpg" alt="img"></p><h2 id="四、缓存问题"><a href="#四、缓存问题" class="headerlink" title="四、缓存问题"></a>四、缓存问题</h2><p>###缓存穿透</p><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h3 id="缓存-“无底洞”-现象"><a href="#缓存-“无底洞”-现象" class="headerlink" title="缓存 “无底洞” 现象"></a>缓存 “无底洞” 现象</h3><p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p><p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p><p>解决方案：</p><ul><li>优化批量数据操作命令；</li><li>减少网络通信次数；</li><li>降低接入成本，使用长连接 / 连接池，NIO 等。</li></ul><h2 id="五、数据分布"><a href="#五、数据分布" class="headerlink" title="五、数据分布"></a>五、数据分布</h2><h3 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h3><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><h3 id="顺序分布"><a href="#顺序分布" class="headerlink" title="顺序分布"></a>顺序分布</h3><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h2 id="六、一致性哈希"><a href="#六、一致性哈希" class="headerlink" title="六、一致性哈希"></a>六、一致性哈希</h2><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg" alt="img"></p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66402828-fb2b-418f-83f6-82153491bcfe.jpg" alt="img"></p><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p><h2 id="七、LRU"><a href="#七、LRU" class="headerlink" title="七、LRU"></a>七、LRU</h2><p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p><ul><li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li><li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>大规模分布式存储系统</li><li><a href="https://tech.meituan.com/cache_about.html">缓存那些事(opens new window)</a></li><li><a href="https://my.oschina.net/jayhu/blog/732849">一致性哈希算法(opens new window)</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">内容分发网络(opens new window)</a></li><li><a href="https://www.aspirationhosting.com/aspiration-cdn/">How Aspiration CDN helps to improve your website loading speed?</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言使用阿里云实现短信发送/验证服务（gin框架）</title>
      <link href="/hypo-Z.github.io/2021/12/16/go-yu-yan-shi-yong-a-li-yun-shi-xian-duan-xin-fa-song-yan-zheng-fu-wu-gin-kuang-jia/"/>
      <url>/hypo-Z.github.io/2021/12/16/go-yu-yan-shi-yong-a-li-yun-shi-xian-duan-xin-fa-song-yan-zheng-fu-wu-gin-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="go语言使用阿里云实现短信发送-验证服务（gin框架）"><a href="#go语言使用阿里云实现短信发送-验证服务（gin框架）" class="headerlink" title="go语言使用阿里云实现短信发送/验证服务（gin框架）"></a>go语言使用阿里云实现短信发送/验证服务（gin框架）</h1><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><h2 id="短信批量发送结果查询-CodeSample"><a href="#短信批量发送结果查询-CodeSample" class="headerlink" title="短信批量发送结果查询 CodeSample"></a>短信批量发送结果查询 CodeSample</h2><p>该项目为通过 SendSms 发送短信并查询发送的结 CodeSample，生成的代码可以通过安装<a href="https://darabonba.api.aliyun.com/module/alibabacloud/CS20151215">各语言的包</a>来进行测试。</p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><ul><li>在您开始之前，您需要注册阿里云帐户并获取您的 <a href="https://usercenter.console.aliyun.com/#/manage/ak">凭证</a></li></ul><h3 id="使用的-API"><a href="#使用的-API" class="headerlink" title="使用的 API"></a>使用的 API</h3><ul><li>SendBatchSms 批量发送短信，可以参考：<a href="https://help.aliyun.com/document_detail/101414.html">文档</a></li><li>QuerySendDetails 查询短信的发送情况，可以参考：<a href="https://help.aliyun.com/document_detail/102352.html">文档</a></li></ul><h3 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">&lt;phoneNumbers&gt;: 接收短信的手机号码，多个用英文逗号隔开&lt;signNameJson&gt;: 短信签名名称，eg: "阿里云"&lt;templateCode&gt;: 短信模板CODE&lt;templateParamJson&gt;: 短信模板变量对应的实际值，eg：{"code":"1234"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="返回示例"><a href="#返回示例" class="headerlink" title="返回示例"></a>返回示例</h3><p>QuerySendDetails：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">{"TotalCount":1,"Message":"OK","RequestId":"819BE656-D2E0-4858-8B21-B2E477085AAF","SmsSendDetailDTOs":{"SmsSendDetailDTO":{"SendDate":"2019-01-08 16:44:10","OutId":123,"SendStatus":3,"ReceiveDate":"2019-01-08 16:44:13","ErrCode":"DELIVERED","TemplateCode":"SMS_122310183","Content":"【阿里云】验证码为：123，您正在登录，若非本人操作，请勿泄露","PhoneNum":15298356881}},"Code":"OK"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="本人测试代码如下："><a href="#本人测试代码如下：" class="headerlink" title="本人测试代码如下："></a>本人测试代码如下：</h3><h5 id="用户信息结构体："><a href="#用户信息结构体：" class="headerlink" title="用户信息结构体："></a>用户信息结构体：</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> UserInfo <span class="token keyword">struct</span> <span class="token punctuation">{</span>Uid              <span class="token builtin">int64</span>Account          <span class="token builtin">string</span>Password         <span class="token builtin">string</span>Phone            <span class="token builtin">string</span>Email            <span class="token builtin">string</span>VerificationCode <span class="token builtin">string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="短信发送部分代码："><a href="#短信发送部分代码：" class="headerlink" title="短信发送部分代码："></a>短信发送部分代码：</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// GetSMSverification 通过短信发送验证码</span><span class="token keyword">func</span> <span class="token function">GetSMSVerification</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>data <span class="token operator">:=</span> Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span><span class="token punctuation">}</span>err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">BindJSON</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>Utils<span class="token punctuation">.</span><span class="token function">HandleErr</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">"获取数据失败"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>user <span class="token operator">:=</span> <span class="token operator">&amp;</span>Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span>Phone<span class="token punctuation">:</span> data<span class="token punctuation">.</span>Phone<span class="token punctuation">}</span>isExist <span class="token operator">:=</span> <span class="token operator">&amp;</span>dataisExist<span class="token punctuation">.</span><span class="token function">QueryPhone</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>Phone<span class="token punctuation">)</span><span class="token comment">//发送验证码</span>request <span class="token operator">:=</span> Models<span class="token punctuation">.</span>ALiYunCommunicationRequest<span class="token punctuation">{</span><span class="token punctuation">}</span>randcode <span class="token operator">:=</span> Utils<span class="token punctuation">.</span><span class="token function">GenerateRandNum</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment">//需获取AliYun的短信服务签名和短信模板</span>req <span class="token operator">:=</span> request<span class="token punctuation">.</span><span class="token function">SetParamsValue</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>Phone<span class="token punctuation">,</span> signName<span class="token punctuation">,</span> randcode<span class="token punctuation">,</span> TemplateParam<span class="token punctuation">)</span>err <span class="token operator">=</span> req<span class="token punctuation">.</span><span class="token function">SendReq</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Utils<span class="token punctuation">.</span><span class="token function">HandleErr</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">"发送失败"</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> randcode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"发送成功"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//记录本地验证码</span>user<span class="token punctuation">.</span>VerificationCode <span class="token operator">=</span> randcode<span class="token comment">//给定过期时间</span>timer <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTimer</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>timer<span class="token punctuation">.</span>C<span class="token punctuation">:</span>user<span class="token punctuation">.</span>VerificationCode <span class="token operator">=</span> <span class="token string">"expired"</span><span class="token punctuation">}</span>timer<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="短信验证部分代码："><a href="#短信验证部分代码：" class="headerlink" title="短信验证部分代码："></a>短信验证部分代码：</h5><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// LoginbySMS  通过SMS用户登录</span><span class="token keyword">func</span> <span class="token function">LoginbySMS</span><span class="token punctuation">(</span>c <span class="token operator">*</span>gin<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>data <span class="token operator">:=</span> Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span><span class="token punctuation">}</span>err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">BindJSON</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>Utils<span class="token punctuation">.</span><span class="token function">HandleErr</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> err<span class="token punctuation">,</span> <span class="token string">"获取数据失败"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> <span class="token boolean">nil</span><span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"获取数据失败"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>user <span class="token operator">:=</span> <span class="token operator">&amp;</span>Models<span class="token punctuation">.</span>UserInfo<span class="token punctuation">{</span>VerificationCode<span class="token punctuation">:</span> data<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">}</span> <span class="token comment">//填入的验证码</span>isExist <span class="token operator">:=</span> <span class="token operator">&amp;</span>dataisExist<span class="token punctuation">.</span><span class="token function">QueryPhone</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>Phone<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> user<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"验证码输入错误"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">if</span> user<span class="token punctuation">.</span>VerificationCode <span class="token operator">==</span> <span class="token string">"expired"</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> user<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"验证码过期"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">//填入的验证码与数据库的验证码进行比较</span><span class="token keyword">if</span> user<span class="token punctuation">.</span>VerificationCode <span class="token operator">==</span> data<span class="token punctuation">.</span>VerificationCode <span class="token punctuation">{</span><span class="token function">SetCookie</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> data<span class="token punctuation">.</span>Uid<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verificationCode"</span><span class="token punctuation">:</span> user<span class="token punctuation">.</span>VerificationCode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>           <span class="token string">"验证码错误"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><p>因为短信签名需要完整的网站和App才能申请成功，不能看到实际短信情况，但在postman测试是成功返回，待网站建设完好后，再展示短信结果。。。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Gin框架 </tag>
            
            <tag> AliYun </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实现邮箱验证/邮件发送</title>
      <link href="/hypo-Z.github.io/2021/12/15/go-yu-yan-shi-xian-you-xiang-yan-zheng-you-jian-fa-song/"/>
      <url>/hypo-Z.github.io/2021/12/15/go-yu-yan-shi-xian-you-xiang-yan-zheng-you-jian-fa-song/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言实现邮箱验证-邮件发送"><a href="#Go语言实现邮箱验证-邮件发送" class="headerlink" title="Go语言实现邮箱验证/邮件发送"></a>Go语言实现邮箱验证/邮件发送</h1><h3 id="1-首先设置邮箱的smtp"><a href="#1-首先设置邮箱的smtp" class="headerlink" title="1.首先设置邮箱的smtp"></a>1.首先设置邮箱的smtp</h3><p>SMTP服务器就是邮件代收发服务器，由邮件服务商提供，常见的SMTP服务器端口号：<br>QQ邮箱：SMTP服务器地址：smtp.qq.com（端口：587）<br>雅虎邮箱: SMTP服务器地址：smtp.yahoo.com（端口：587）<br>163邮箱：SMTP服务器地址：smtp.163.com（端口：25）<br>126邮箱: SMTP服务器地址：smtp.126.com（端口：25）<br>新浪邮箱: SMTP服务器地址：smtp.sina.com（端口：25）</p><p>登录邮箱账户 设置开启SMTP 并获取授权码</p><p>我使用的是QQ邮箱进行测试</p><p><img src="http://rfxlwr9xo.hn-bkt.clouddn.com/hypo.ltd/qqmail_test.jpg" alt="qqmail"></p><p>QQ邮箱默认关闭SMTP服务，将IMAP/SMTP服务打开，跟着流程做后你会得到令牌密码。</p><h3 id="代码实现如下："><a href="#代码实现如下：" class="headerlink" title="代码实现如下："></a>代码实现如下：</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">SendToMail</span><span class="token punctuation">(</span>rand<span class="token punctuation">,</span> to <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>subject <span class="token operator">:=</span> <span class="token string">"动态验证码"</span>user <span class="token operator">:=</span> <span class="token string">"user@qq.com"</span>password <span class="token operator">:=</span> <span class="token string">"**********"</span> <span class="token comment">//输入刚得到的令牌</span>host <span class="token operator">:=</span> <span class="token string">"smtp.qq.com:587"</span>body <span class="token operator">:=</span> <span class="token string">"您的动态验证码为："</span> <span class="token operator">+</span> rand <span class="token operator">+</span> <span class="token string">"，您正在进行密码重置操作，如非本人操作，请忽略本邮件！"</span>sendUserName <span class="token operator">:=</span> <span class="token string">"senderName"</span> <span class="token comment">//发送邮件的人名称</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"send email"</span><span class="token punctuation">)</span>hp <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">)</span>auth <span class="token operator">:=</span> smtp<span class="token punctuation">.</span><span class="token function">PlainAuth</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">,</span> hp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">var</span> content_type <span class="token builtin">string</span>mailtype <span class="token operator">:=</span> <span class="token string">""</span><span class="token keyword">if</span> mailtype <span class="token operator">==</span> <span class="token string">"html"</span> <span class="token punctuation">{</span>content_type <span class="token operator">=</span> <span class="token string">"Content-Type: text/"</span> <span class="token operator">+</span> mailtype <span class="token operator">+</span> <span class="token string">"; charset=UTF-8"</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>content_type <span class="token operator">=</span> <span class="token string">"Content-Type: text/plain"</span> <span class="token operator">+</span> <span class="token string">"; charset=UTF-8"</span><span class="token punctuation">}</span>msg <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"To: "</span> <span class="token operator">+</span> to <span class="token operator">+</span> <span class="token string">"\r\nFrom: "</span> <span class="token operator">+</span> sendUserName <span class="token operator">+</span> <span class="token string">"&lt;"</span> <span class="token operator">+</span> user <span class="token operator">+</span> <span class="token string">"&gt;"</span> <span class="token operator">+</span> <span class="token string">"\r\nSubject: "</span> <span class="token operator">+</span> subject <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> content_type <span class="token operator">+</span> <span class="token string">"\r\n\r\n"</span> <span class="token operator">+</span> body<span class="token punctuation">)</span>send_to <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Split</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token string">";"</span><span class="token punctuation">)</span>err <span class="token operator">:=</span> smtp<span class="token punctuation">.</span><span class="token function">SendMail</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> auth<span class="token punctuation">,</span> user<span class="token punctuation">,</span> send_to<span class="token punctuation">,</span> msg<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"send email"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Send mail error!"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Send mail success!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> err<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//发送验证码</span>randcode <span class="token operator">:=</span> Utils<span class="token punctuation">.</span><span class="token function">GenerateRandNum</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token comment">//随机6位数</span>err <span class="token operator">=</span> Models<span class="token punctuation">.</span><span class="token function">SendToMail</span><span class="token punctuation">(</span>randcode<span class="token punctuation">,</span>user<span class="token punctuation">.</span>Email<span class="token punctuation">)</span>    log<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"验证码发送失败,err:%s"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span>c<span class="token punctuation">.</span><span class="token function">JSON</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> gin<span class="token punctuation">.</span>H<span class="token punctuation">{</span><span class="token string">"verification"</span><span class="token punctuation">:</span> randcode<span class="token punctuation">,</span><span class="token string">"result"</span><span class="token punctuation">:</span>       <span class="token string">"发送成功"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>成功发送：</p><p><img src="http://rfxlwr9xo.hn-bkt.clouddn.com/hypo.ltd/qqmail_test_success.jpg" alt="success"></p><h3 id="遇到的几个坑"><a href="#遇到的几个坑" class="headerlink" title="遇到的几个坑"></a>遇到的几个坑</h3><ul><li>smtp.SendMail 后出现 EOF 失败</li></ul><p><strong>解决方法：</strong> QQmail 的 465 端口用于通过 TLS 连接，但 SendMail 需要普通的旧 TCP。尝试连接到端口 587。SendMail 将在可用时自动升级到 TLS（在本例中就是这种情况）。</p><p>还需要解决的问题：</p><ul><li>这个只能单人进行验证，如果多个人同时验证会造成验证码记录覆盖，导致用户输入验证码错误。</li></ul><p>代解决。。。</p><p><strong>解决方法：</strong> 将验证码记录在本地数据库个人用户的字段中，并设置过期时间，时间一到就会被覆盖掉；<br>验证时，在过期时间之前，通过邮箱号查找验证码比较是否相同，即可解决多个用户验证问题。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Gin框架 </tag>
            
            <tag> SMTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin框架中使用JWT进行接口认证</title>
      <link href="/hypo-Z.github.io/2021/12/07/gin-kuang-jia-zhong-shi-yong-jwt-jin-xing-jie-kou-ren-zheng/"/>
      <url>/hypo-Z.github.io/2021/12/07/gin-kuang-jia-zhong-shi-yong-jwt-jin-xing-jie-kou-ren-zheng/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/user/1556564193589431"><img src="https://p26-passport.byteacctimg.com/img/user-avatar/3e505a96513d6dcbb77fbea3b4d936db~300x300.image" alt="img"></a></p><p><a href="https://juejin.cn/user/1556564193589431">CloudNativeOps <img src="https://lf3-cdn-tos.bytescm.com/obj/static/xitu_juejin_web/f597b88d22ce5370bd94495780459040.svg" alt="lv-2"></a></p><p>2020年03月15日 阅读 5401</p><p>关注</p><h1 id="Gin框架中使用JWT进行接口认证"><a href="#Gin框架中使用JWT进行接口认证" class="headerlink" title="Gin框架中使用JWT进行接口认证"></a>Gin框架中使用JWT进行接口认证</h1><blockquote><p>背景: 在如今前后端分离开发的大环境中，我们需要解决一些登陆，后期身份认证以及鉴权相关的事情，通常的方案就是采用请求头携带token的方式进行实现。本篇文章主要分享下在Golang语言下使用<a href="https://link.juejin.cn/?target=https://github.com/dgrijalva/jwt-go">jwt-go</a>来实现后端的token认证逻辑。</p></blockquote><p><code>JSON Web Token(JWT)</code>是一个常用语HTTP的客户端和服务端间进行身份认证和鉴权的标准规范，使用JWT可以允许我们在用户和服务器之间传递安全可靠的信息。</p><p>在开始学习<a href="https://link.juejin.cn/?target=https://jwt.io/">JWT</a>之前，我们可以先了解下早期的几种方案。</p><h3 id="token、cookie、session的区别"><a href="#token、cookie、session的区别" class="headerlink" title="token、cookie、session的区别"></a>token、cookie、session的区别</h3><p><strong>Cookie</strong></p><p>Cookie总是保存在客户端中，按在客户端中的存储位置，可分为<code>内存Cookie</code>和<code>硬盘Cookie</code>。</p><p>内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为<code>非持久Cookie和持久Cookie</code>。</p><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p><p><code>cookie由服务器生成，发送给浏览器</code>，浏览器把cookie以key-value形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p><p><strong>Session</strong></p><p>Session字面意思是会话，主要用来标识自己的身份。比如在无状态的api服务在多次请求数据库时，如何知道是同一个用户，这个就可以通过session的机制，服务器要知道当前发请求给自己的是谁</p><p>为了区分客户端请求，<code>服务端会给具体的客户端生成身份标识session</code>，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。</p><p>至于客户端如何保存该标识，可以有很多方式，对于浏览器而言，一般都是使用<code>cookie</code>的方式</p><p>服务器使用session把用户信息临时保存了服务器上，用户离开网站就会销毁，这种凭证存储方式相对于cookie来说更加安全，但是session会有一个缺陷: 如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p><p>因此，通常企业里会使用<code>redis,memcached</code>缓存中间件来实现session的共享，此时web服务器就是一个完全无状态的存在，所有的用户凭证可以通过共享session的方式存取，当前session的过期和销毁机制需要用户做控制。</p><p><strong>Token</strong></p><p>token的意思是“令牌”，是用户身份的验证方式，最简单的token组成: <code>uid(用户唯一标识)</code>+<code>time(当前时间戳)</code>+<code>sign(签名,由token的前几位+盐以哈希算法压缩成一定长度的十六进制字符串)</code>，同时还可以将不变的参数也放进token</p><p>这里我们主要想讲的就是<code>Json Web Token</code>，也就是本篇的主题:JWT</p><h3 id="Json-Web-Token-JWT-介绍"><a href="#Json-Web-Token-JWT-介绍" class="headerlink" title="Json-Web-Token(JWT)介绍"></a>Json-Web-Token(JWT)介绍</h3><p>一般而言，用户注册登陆后会生成一个jwt token返回给浏览器，浏览器向服务端请求数据时携带<code>token</code>，服务器端使用<code>signature</code>中定义的方式进行解码，进而对token进行解析和验证。</p><h4 id="JWT-Token组成部分"><a href="#JWT-Token组成部分" class="headerlink" title="JWT Token组成部分"></a>JWT Token组成部分</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b098f391d~tplv-t2oaga2asx-watermark.awebp" alt="JWT-Token组成部分">JWT-Token组成部分</p><ul><li>header: 用来指定使用的算法(HMAC SHA256 RSA)和token类型(如JWT)</li><li>payload: 包含声明(要求)，声明通常是用户信息或其他数据的声明，比如用户id，名称，邮箱等. 声明可分为三种: registered,public,private</li><li>signature: 用来保证JWT的真实性，可以使用不同的算法</li></ul><p><strong>header</strong></p><pre class="line-numbers language-none"><code class="language-none">{    "alg": "HS256",    "typ": "JWT"}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对上面的json进行base64编码即可得到JWT的第一个部分</p><p><strong>payload</strong></p><ul><li>registered claims: 预定义的声明，通常会放置一些预定义字段，比如过期时间，主题等(iss:issuer,exp:expiration time,sub:subject,aud:audience)</li><li>public claims: 可以设置公开定义的字段</li><li>private claims: 用于统一使用他们的各方之间的共享信息</li></ul><pre class="line-numbers language-none"><code class="language-none">{    "sub": "xxx-api",    "name": "bgbiao.top",    "admin": true}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对payload部分的json进行base64编码后即可得到JWT的第二个部分</p><p><code>注意:</code> 不要在header和payload中放置敏感信息，除非信息本身已经做过脱敏处理</p><p><strong>signature</strong></p><p>为了得到签名部分，必须有编码过的header和payload，以及一个秘钥，签名算法使用header中指定的那个，然后对其进行签名即可</p><pre class="line-numbers language-none"><code class="language-none">HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>签名是<code>用于验证消息在传递过程中有没有被更改</code>，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p><p>在<a href="https://link.juejin.cn/?target=https://jwt.io">jwt.io</a>网站中，提供了一些JWT token的编码，验证以及生成jwt的工具。</p><p>下图就是一个典型的jwt-token的组成部分。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b072d445e~tplv-t2oaga2asx-watermark.awebp" alt="jwt官方签名结构">jwt官方签名结构</p><h4 id="什么时候用JWT"><a href="#什么时候用JWT" class="headerlink" title="什么时候用JWT"></a>什么时候用JWT</h4><ul><li>Authorization(授权): 典型场景，用户请求的token中包含了该令牌允许的路由，服务和资源。单点登录其实就是现在广泛使用JWT的一个特性</li><li>Information Exchange(信息交换): 对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式.因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改</li></ul><h4 id="JWT-Json-Web-Tokens-是如何工作的"><a href="#JWT-Json-Web-Tokens-是如何工作的" class="headerlink" title="JWT(Json Web Tokens)是如何工作的"></a>JWT(Json Web Tokens)是如何工作的</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b09686448~tplv-t2oaga2asx-watermark.awebp" alt="JWT认证过程">JWT认证过程</p><p>所以，基本上整个过程分为两个阶段，第一个阶段，客户端向服务端获取token，第二阶段，客户端带着该token去请求相关的资源.</p><p>通常比较重要的是，服务端如何根据指定的规则进行token的生成。</p><p>在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。</p><p>此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。</p><p>一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p><p>无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema: <code>Authorization: Bearer &lt;token&gt;</code></p><p>服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。</p><p>如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie.</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b0a3068a5~tplv-t2oaga2asx-watermark.awebp" alt="获取JWT以及访问APIs以及资源">获取JWT以及访问APIs以及资源</p><ul><li>客户端向授权接口请求授权</li><li>服务端授权后返回一个access token给客户端</li><li>客户端使用access token访问受保护的资源</li></ul><h4 id="基于Token的身份认证和基于服务器的身份认证"><a href="#基于Token的身份认证和基于服务器的身份认证" class="headerlink" title="基于Token的身份认证和基于服务器的身份认证"></a>基于Token的身份认证和基于服务器的身份认证</h4><p><strong>1.基于服务器的认证</strong></p><p>前面说到过session，cookie以及token的区别，在之前传统的做法就是基于存储在服务器上的session来做用户的身份认证，但是通常会有如下问题:</p><ul><li>Sessions: 认证通过后需要将用户的session数据保存在内存中，随着认证用户的增加，内存开销会大</li><li>扩展性: 由于session存储在内存中，扩展性会受限，虽然后期可以使用redis,memcached来缓存数据</li><li>CORS: 当多个终端访问同一份数据时，可能会遇到禁止请求的问题</li><li>CSRF: 用户容易受到CSRF攻击</li></ul><p><strong>2.Session和JWT Token的异同</strong></p><p>都可以存储用户相关信息，但是session存储在服务端，JWT存储在客户端</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170ddb5b0a56f132~tplv-t2oaga2asx-watermark.awebp" alt="session和jwt数据存储位置">session和jwt数据存储位置</p><p><strong>3.基于Token的身份认证如何工作</strong></p><p>基于Token的身份认证是无状态的，服务器或者session中不会存储任何用户信息.(很好的解决了共享session的问题)</p><ul><li>用户携带用户名和密码请求获取token(接口数据中可使用appId,appKey)</li><li>服务端校验用户凭证，并返回用户或客户端一个Token</li><li>客户端存储token,并在请求头中携带Token</li><li>服务端校验token并返回数据</li></ul><pre class="line-numbers language-none"><code class="language-none">注意:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>随后客户端的每次请求都需要使用token</li><li>token应该放在header中</li><li>需要将服务器设置为接收所有域的请求: <code>Access-Control-Allow-Origin: *</code></li></ul><p><strong>4.用Token的好处</strong></p><ul><li>无状态和可扩展性</li><li>安全: 防止CSRF攻击;token过期重新认证</li></ul><p><strong>5.JWT和OAuth的区别</strong></p><ul><li>1.OAuth2是一种授权框架 ，JWT是一种认证协议</li><li>2.无论使用哪种方式切记用HTTPS来保证数据的安全性</li><li>3.OAuth2用在<code>使用第三方账号登录的情况</code>(比如使用weibo, qq, github登录某个app)，而<code>JWT是用在前后端分离</code>, 需要简单的对后台API进行保护时使用</li></ul><h3 id="使用Gin框架集成JWT"><a href="#使用Gin框架集成JWT" class="headerlink" title="使用Gin框架集成JWT"></a>使用Gin框架集成JWT</h3><p>在Golang语言中，<a href="https://link.juejin.cn/?target=https://github.com/dgrijalva/jwt-go">jwt-go</a>库提供了一些jwt编码和验证的工具，因此我们很容易使用该库来实现token认证。</p><p>另外，我们也知道<a href="https://link.juejin.cn/?target=https://github.com/gin-gonic/gin">gin</a>框架中支持用户自定义middleware，我们可以很好的将jwt相关的逻辑封装在middleware中，然后对具体的接口进行认证。</p><h4 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h4><p>在gin框架中，自定义中间件比较容易，只要返回一个<code>gin.HandlerFunc</code>即完成一个中间件定义。</p><p>接下来，我们先定义一个用于jwt认证的中间件.</p><pre class="line-numbers language-none"><code class="language-none">// 定义一个JWTAuth的中间件func JWTAuth() gin.HandlerFunc {return func(c *gin.Context) {// 通过http header中的token解析来认证token := c.Request.Header.Get("token")if token == "" {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "请求未携带token，无权限访问","data":   nil,})c.Abort()return}log.Print("get token: ", token)// 初始化一个JWT对象实例，并根据结构体方法来解析tokenj := NewJWT()// 解析token中包含的相关信息(有效载荷)claims, err := j.ParserToken(token)if err != nil {// token过期if err == TokenExpired {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "token授权已过期，请重新申请授权","data":   nil,})c.Abort()return}// 其他错误c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    err.Error(),"data":   nil,})c.Abort()return}// 将解析后的有效载荷claims重新写入gin.Context引用对象中c.Set("claims", claims)}}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义jwt编码和解码逻辑"><a href="#定义jwt编码和解码逻辑" class="headerlink" title="定义jwt编码和解码逻辑"></a>定义jwt编码和解码逻辑</h4><p>根据前面提到的jwt-token的组成部分，以及<code>jwt-go</code>中相关的定义，我们可以使用如下方法进行生成token.</p><pre class="line-numbers language-none"><code class="language-none">// 定义一个jwt对象type JWT struct {// 声明签名信息SigningKey []byte}// 初始化jwt对象func NewJWT() *JWT {return &amp;JWT{[]byte("bgbiao.top"),}}// 自定义有效载荷(这里采用自定义的Name和Email作为有效载荷的一部分)type CustomClaims struct {Name  string `json:"name"`Email string `json:"email"`// StandardClaims结构体实现了Claims接口(Valid()函数)jwt.StandardClaims}// 调用jwt-go库生成token// 指定编码的算法为jwt.SigningMethodHS256func (j *JWT) CreateToken(claims CustomClaims) (string, error) {// https://gowalker.org/github.com/dgrijalva/jwt-go#Token// 返回一个token的结构体指针token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)return token.SignedString(j.SigningKey)}// token解码func (j *JWT) ParserToken(tokenString string) (*CustomClaims, error) {// https://gowalker.org/github.com/dgrijalva/jwt-go#ParseWithClaims// 输入用户自定义的Claims结构体对象,token,以及自定义函数来解析token字符串为jwt的Token结构体指针// Keyfunc是匿名函数类型: type Keyfunc func(*Token) (interface{}, error)// func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {}token, err := jwt.ParseWithClaims(tokenString, &amp;CustomClaims{}, func(token *jwt.Token) (interface{}, error) {return j.SigningKey, nil})if err != nil {// https://gowalker.org/github.com/dgrijalva/jwt-go#ValidationError// jwt.ValidationError 是一个无效token的错误结构if ve, ok := err.(*jwt.ValidationError); ok {// ValidationErrorMalformed是一个uint常量，表示token不可用if ve.Errors&amp;jwt.ValidationErrorMalformed != 0 {return nil, fmt.Errorf("token不可用")// ValidationErrorExpired表示Token过期} else if ve.Errors&amp;jwt.ValidationErrorExpired != 0 {return nil, fmt.Errorf("token过期")// ValidationErrorNotValidYet表示无效token} else if ve.Errors&amp;jwt.ValidationErrorNotValidYet != 0 {return nil, fmt.Errorf("无效的token")} else {return nil, fmt.Errorf("token不可用")}}}// 将token中的claims信息解析出来并断言成用户自定义的有效载荷结构if claims, ok := token.Claims.(*CustomClaims); ok &amp;&amp; token.Valid {return claims, nil}return nil, fmt.Errorf("token无效")}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义登陆验证逻辑"><a href="#定义登陆验证逻辑" class="headerlink" title="定义登陆验证逻辑"></a>定义登陆验证逻辑</h4><p>接下来的部分就是普通api的具体逻辑了，比如可以在登陆时进行用户校验，成功后未该次认证请求生成token。</p><pre class="line-numbers language-none"><code class="language-none">// 定义登陆逻辑// model.LoginReq中定义了登陆的请求体(name,passwd)func Login(c *gin.Context) {var loginReq model.LoginReqif c.BindJSON(&amp;loginReq) == nil {// 登陆逻辑校验(查库，验证用户是否存在以及登陆信息是否正确)isPass, user, err := model.LoginCheck(loginReq)// 验证通过后为该次请求生成tokenif isPass {generateToken(c, user)} else {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "验证失败" + err.Error(),"data":   nil,})}} else {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    "用户数据解析失败","data":   nil,})}}// token生成器// md 为上面定义好的middleware中间件func generateToken(c *gin.Context, user model.User) {// 构造SignKey: 签名和解签名需要使用一个值j := md.NewJWT()// 构造用户claims信息(负荷)claims := md.CustomClaims{user.Name,user.Email,jwtgo.StandardClaims{NotBefore: int64(time.Now().Unix() - 1000), // 签名生效时间ExpiresAt: int64(time.Now().Unix() + 3600), // 签名过期时间Issuer:    "bgbiao.top",                    // 签名颁发者},}// 根据claims生成token对象token, err := j.CreateToken(claims)if err != nil {c.JSON(http.StatusOK, gin.H{"status": -1,"msg":    err.Error(),"data":   nil,})}log.Println(token)// 封装一个响应数据,返回用户名和tokendata := LoginResult{Name:  user.Name,Token: token,}c.JSON(http.StatusOK, gin.H{"status": 0,"msg":    "登陆成功","data":   data,})return}复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="定义普通待验证接口"><a href="#定义普通待验证接口" class="headerlink" title="定义普通待验证接口"></a>定义普通待验证接口</h4><pre class="line-numbers language-none"><code class="language-none">// 定义一个普通controller函数，作为一个验证接口逻辑func GetDataByTime(c *gin.Context) {// 上面我们在JWTAuth()中间中将'claims'写入到gin.Context的指针对象中，因此在这里可以将之解析出来claims := c.MustGet("claims").(*md.CustomClaims)if claims != nil {c.JSON(http.StatusOK, gin.H{"status": 0,"msg":    "token有效","data":   claims,})}}// 在主函数中定义路由规则router := gin.Default()v1 := router.Group("/apis/v1/"){v1.POST("/register", controller.RegisterUser)v1.POST("/login", controller.Login)}// secure v1sv1 := router.Group("/apis/v1/auth/")// 加载自定义的JWTAuth()中间件,在整个sv1的路由组中都生效sv1.Use(md.JWTAuth()){sv1.GET("/time", controller.GetDataByTime)}router.Run(":8081")复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="验证使用JWT后的接口"><a href="#验证使用JWT后的接口" class="headerlink" title="验证使用JWT后的接口"></a>验证使用JWT后的接口</h4><pre class="line-numbers language-none"><code class="language-none"># 运行项目$ go run main.go127.0.0.113306root:bgbiao.top@tcp(127.0.0.1:13306)/test_api?charset=utf8mb4&amp;parseTime=True&amp;loc=Local[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production. - using env:export GIN_MODE=release - using code:gin.SetMode(gin.ReleaseMode)[GIN-debug] POST   /apis/v1/register         --&gt; warnning-trigger/controller.RegisterUser (3 handlers)[GIN-debug] POST   /apis/v1/login            --&gt; warnning-trigger/controller.Login (3 handlers)[GIN-debug] GET    /apis/v1/auth/time        --&gt; warnning-trigger/controller.GetDataByTime (4 handlers)[GIN-debug] Listening and serving HTTP on :8081# 注册用户$ curl -i -X POST \   -H "Content-Type:application/json" \   -d \'{  "name": "hahaha1",  "password": "hahaha1",  "email": "hahaha1@bgbiao.top",  "phone": 10000000000}' \ 'http://localhost:8081/apis/v1/register'HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Sun, 15 Mar 2020 07:09:28 GMTContent-Length: 41{"data":null,"msg":"success ","status":0}%# 登陆用户以获取token$ curl -i -X POST \   -H "Content-Type:application/json" \   -d \'{  "name":"hahaha1",  "password":"hahaha1"}' \ 'http://localhost:8081/apis/v1/login'HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Date: Sun, 15 Mar 2020 07:10:41 GMTContent-Length: 290{"data":{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6ImhhaGFoYTEiLCJlbWFpbCI6ImhhaGFoYTFAYmdiaWFvLnRvcCIsImV4cCI6MTU4NDI1OTg0MSwiaXNzIjoiYmdiaWFvLnRvcCIsIm5iZiI6MTU4NDI1NTI0MX0.HNXSKISZTqzjKd705BOSARmgI8FGGe4Sv-Ma3_iK1Xw","name":"hahaha1"},"msg":"登陆成功","status":0}# 访问需要认证的接口# 因为我们对/apis/v1/auth/的分组路由中加载了jwt的middleware，因此该分组下的api都需要使用jwt-token认证$ curl http://localhost:8081/apis/v1/auth/time{"data":null,"msg":"请求未携带token，无权限访问","status":-1}%# 使用token认证$ curl http://localhost:8081/apis/v1/auth/time -H 'token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6ImhhaGFoYTEiLCJlbWFpbCI6ImhhaGFoYTFAYmdiaWFvLnRvcCIsImV4cCI6MTU4NDI1OTg0MSwiaXNzIjoiYmdiaWFvLnRvcCIsIm5iZiI6MTU4NDI1NTI0MX0.HNXSKISZTqzjKd705BOSARmgI8FGGe4Sv-Ma3_iK1Xw'{"data":{"userName":"hahaha1","email":"hahaha1@bgbiao.top","exp":1584259841,"iss":"bgbiao.top","nbf":1584255241},"msg":"token有效","status":0}%复制代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://link.juejin.cn/?target=https://github.com/BGBiao/gin-jwt-token">gin-jwt-go源码</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> JWT </tag>
            
            <tag> Golang </tag>
            
            <tag> Gin框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热情假设</title>
      <link href="/hypo-Z.github.io/2021/12/07/21-re-qing-jia-she/"/>
      <url>/hypo-Z.github.io/2021/12/07/21-re-qing-jia-she/</url>
      
        <content type="html"><![CDATA[<h1 id="热情假设"><a href="#热情假设" class="headerlink" title="热情假设"></a>热情假设</h1><p>2005年，斯坦福大学邀请乔布斯在毕业典礼演讲。这个演讲后来成为经典，《乔布斯传》说”或许有些演讲对后世影响更大，但是你找不到（比这篇）更好的演讲。”</p><p>演讲中，乔布斯说了一段有名的话。</p><blockquote><p>“你们的时间有限，所以不要把它浪费在过其他人的生活。最重要的是，你要有勇气跟随你的内心和直觉。某种程度上，它们已经知道你真正想要成为什么样子。其他所有事情都是次要的。”</p></blockquote><p>这段话后来被称为”热情假设”，很多人都引用它鼓励年轻人：寻找职业方向的时候，要跟随内心的热情（passion），去做那些你有强烈意愿从事的工作。</p><p>但是，美国最近出版了一本新书《优秀到无法忽略》（<a href="https://commoncog.com/blog/so-good-they-cant-ignore-you/">《So Good They Can’t Ignore You》</a>），声称乔布斯的这个建议是完全错误的，误导年轻人。别的不说，乔布斯本人也不遵守”热情假设”。年轻时，他对禅宗思想最感兴趣，去印度学习佛教。如果他真的追随自己的内心，他就应该去当一个禅宗老师，而不是跑回美国创办苹果公司。</p><p>这本书认为，以下几个原因导致”热情假设”不是一个好的建议。</p><ul><li><p>第一，热情真的很罕见。大部分人都对自己的工作没兴趣，而是对某种爱好（比如打球、钓鱼）有兴趣。如果大部分人都找不到自己的职业热情，你怎么能叫他们去追随热情呢？</p></li><li><p>第二，热情需要时间来建立。许多人刚开始工作的时候，对自己的职业并没有兴趣，随着时间积累，他们的经验越来越多，能够掌控的东西越来越多，这才慢慢开始热爱自己的工作。找工作阶段，你可能根本不会意识到这个职业就是你的热情所在。</p></li><li><p>第三，过度强调热情，容易对现状产生不满。2010年的一项调查发现，只有45％的美国人对自己的工作满意。由于很多人相信，无法产生热情的工作不是好工作，导致对职业生涯抱有不切实际的期望，对现有的工作不满意，不断跳槽。</p></li></ul><p>这本书提出，热情不是凭空产生的，它跟自主权有关。如果你在某个职位上的自主权越大，能够掌控的东西越多，就越容易对当前的职业产生热情。<strong>与其强调跟随内心的热情，不如强调如何在某种职业里面获得自主权。你必须使自己变得优秀，让别人无法忽视你，同意让你掌控更多的资源</strong> ，这就是书名的含义。</p><p>——引自阮一峰的网络日志27期</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑天鹅》读后感</title>
      <link href="/hypo-Z.github.io/2021/12/06/20-hei-tian-e-du-hou-gan/"/>
      <url>/hypo-Z.github.io/2021/12/06/20-hei-tian-e-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="《黑天鹅》读后感"><a href="#《黑天鹅》读后感" class="headerlink" title="《黑天鹅》读后感"></a><strong>《黑天鹅》读后感</strong></h1><p>上周终于将《黑天鹅》看完了，利用在地铁上的闲暇时间看的，我知道读书需要一个安静的环境，所以我不知道我有没有看漏一些地方，以下是我读完后的一点浅显的理解：</p><ol><li>黑天鹅事件是不可预测的，对于人们财富的影响是巨大的；</li><li>黑天鹅事件对于财富越大的人越具有影响力，对于贫困的人影响不大；</li><li>黑天鹅事件的影响具有两面性</li><li>黑天鹅事件是可减弱的但不可消除。</li></ol><h3 id="广义解释："><a href="#广义解释：" class="headerlink" title="广义解释："></a>广义解释：</h3><p>黑天鹅事件（英文：”Black swan” incidents)指非常难以预测，且不寻常的事件，通常会引起市场连锁负面反应甚至颠覆。</p><p>一般来说，“黑天鹅”事件是指满足以下三个特点的事件：它具有意外性；它产生重大影响；虽然它具有意外性，但人的本性促使我们在事后为它的发生编造理由，并且或多或少认为它是可解释和可预测的。</p><p>黑天鹅存在于各个领域，无论金融市场、商业、经济还是个人生活，都逃不过它的控制。“<a href="https://baike.baidu.com/item/%E7%81%B0%E7%8A%80%E7%89%9B/22030944">灰犀牛</a></p><p>”是与“黑天鹅”相互补足的概念，“<a href="https://baike.baidu.com/item/%E7%81%B0%E7%8A%80%E7%89%9B%E4%BA%8B%E4%BB%B6/22044335">灰犀牛事件</a>”是太过于常见以至于人们习以为常的风险，“黑天鹅事件”则是极其罕见的、出乎人们意料的风险。</p><h3 id="“黑天鹅”的逻辑是："><a href="#“黑天鹅”的逻辑是：" class="headerlink" title="“黑天鹅”的逻辑是："></a>“黑天鹅”的逻辑是：</h3><p><a href="https://baike.baidu.com/item/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B">你不知道的事</a>比你知道的事更有意义。在人类社会发展的进程中，对我们的历史和社会产生重大影响的，通常都不是我们已知或可以预见的东西。</p><h3 id="对我自己现阶段的解读："><a href="#对我自己现阶段的解读：" class="headerlink" title="对我自己现阶段的解读："></a>对我自己现阶段的解读：</h3><p>就像是这去年刚出的疫情一样，对于我这样的普通人，给我的影响就是出门不方便，人们交流减少，娱乐方式减少。对于个人的财富没有多少影响。但对于一些工厂来说影响确实巨大的，实体产业遭受打击。另一方面线上产业确越发蓬勃。给我的启发就是：看待一个事物时，更应该关注它背后的运行机制，因为在表面上出现的仅仅的它的结果，要从过程去分析结果；它也提醒我需要加强自身的风险意识，去预防不可预测的风险。</p><p>一本好书是值得反复阅读的，之后一定会再阅读一遍，相信会有更多的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
            <tag> 好书推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hypo-Z.github.io/2021/12/06/0-hello-world/"/>
      <url>/hypo-Z.github.io/2021/12/06/0-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go使用S3搭建Lambda无状态服务</title>
      <link href="/hypo-Z.github.io/2021/12/04/go-shi-yong-s3-da-jian-lambda-wu-zhuang-tai-fu-wu/"/>
      <url>/hypo-Z.github.io/2021/12/04/go-shi-yong-s3-da-jian-lambda-wu-zhuang-tai-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="golang使用S3搭建Lambda无状态服务"><a href="#golang使用S3搭建Lambda无状态服务" class="headerlink" title="golang使用S3搭建Lambda无状态服务"></a>golang使用S3搭建Lambda无状态服务</h1><p>由于项目需求我需要使用aws的Lambda服务来自动处理存入图片的缩略图的生成和存入功能。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>根据尺寸需求生成对应的缩略图</li><li>自动保存入S3对应位置</li><li>将位置信息告诉后端存入数据库</li><li>日志记录报错和运行信息</li></ul><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h4 id="1-一个aws账号"><a href="#1-一个aws账号" class="headerlink" title="1.一个aws账号"></a>1.一个aws账号</h4><h4 id="2-编辑好需求的程序-需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。"><a href="#2-编辑好需求的程序-需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。" class="headerlink" title="2.编辑好需求的程序,需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。"></a>2.编辑好需求的程序,需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。</h4><p>官方的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>        <span class="token string">"fmt"</span>        <span class="token string">"context"</span>        <span class="token string">"github.com/aws/aws-lambda-go/lambda"</span><span class="token punctuation">)</span><span class="token keyword">type</span> MyEvent <span class="token keyword">struct</span> <span class="token punctuation">{</span>        Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">HandleRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> name MyEvent<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Hello %s!"</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span>Name <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lambda<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>HandleRequest<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面列出了有效的处理程序签名。TIn 和 TOut 表示类型与 encoding/json 标准库兼容。有关更多信息，请参阅 func Unmarshal，以了解如何反序列化这些类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>TIn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-部署-zip文件存档"><a href="#3-部署-zip文件存档" class="headerlink" title="3.部署.zip文件存档"></a>3.部署.zip文件存档</h4><h5 id="在-macOS-和-Linux-上创建-zip-文件"><a href="#在-macOS-和-Linux-上创建-zip-文件" class="headerlink" title="在 macOS 和 Linux 上创建 .zip 文件"></a>在 macOS 和 Linux 上创建 .zip 文件</h5><p>编译您的可执行文件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux <span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 GOOS 设置为 linux 可确保编译的可执行文件与 Go 运行时兼容（即使您在非 Linux 环境中编译它也是如此）。</p><p>（可选）如果您的 main 程序包包含多个文件，请使用以下 go build 命令来编译此程序包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux <span class="token keyword">go</span> build main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（可选）您可能需要使用 Linux 上的 CGO_ENABLED=0 编译程序包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux CGO_ENABLED<span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令为标准 C 库 (libc) 版本创建稳定的二进制程序包，这在 Lambda 和其他设备上可能有所不同。</p><p>Lambda 使用 POSIX 文件权限，因此在创建 .zip 文件存档之前，您可能需要为部署程序包文件夹设置权限。</p><p>通过将可执行文件打包为 .zip 文件来创建部署程序包。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">zip function<span class="token punctuation">.</span>zip main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有个坑需要踩一下：<br>main包下，最好是将全部程序放在main.go里面，防止在编译时报错，这样打好zip包后到控制台测试运行，一定要做测试，这样才能确保你的程序能够成功运行，最好是查看图片与需求结果是否相同。</p><p>…补充…</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> AWS </tag>
            
            <tag> S3 </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON Web Token 入门教程</title>
      <link href="/hypo-Z.github.io/2021/12/03/19-json-web-token-ru-men-jiao-cheng/"/>
      <url>/hypo-Z.github.io/2021/12/03/19-json-web-token-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>JSON Web Token 入门教程<br>作者： 阮一峰</p><p>日期： 2018年7月23日</p><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p><p>一、跨域认证的问题<br>互联网服务离不开用户认证。一般流程是下面这样。</p><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><p>二、JWT 的原理<br>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><pre class="line-numbers language-none"><code class="language-none">{  "姓名": "张三",  "角色": "管理员",  "到期时间": "2018年7月1日0点0分"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><p>三、JWT 的数据结构<br>实际的 JWT 大概就像下面这样。</p><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><p>Header（头部）<br>Payload（负载）<br>Signature（签名）<br>写成一行，就是下面的样子。</p><pre class="line-numbers language-none"><code class="language-none">Header.Payload.Signature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面依次介绍这三个部分。</p><p>3.1 Header<br>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><pre class="line-numbers language-none"><code class="language-none">{  "alg": "HS256",  "typ": "JWT"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><p>3.2 Payload<br>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><p>iss (issuer)：签发人<br>exp (expiration time)：过期时间<br>sub (subject)：主题<br>aud (audience)：受众<br>nbf (Not Before)：生效时间<br>iat (Issued At)：签发时间<br>jti (JWT ID)：编号<br>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><pre class="line-numbers language-none"><code class="language-none">{  "sub": "1234567890",  "name": "John Doe",  "admin": true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><p>3.3 Signature<br>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><pre class="line-numbers language-none"><code class="language-none">HMACSHA256(  base64UrlEncode(header) + "." +  base64UrlEncode(payload),  secret)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><p>3.4 Base64URL<br>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p><p>四、JWT 的使用方式<br>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p><p><code>Authorization: Bearer &lt;token&gt;</code></p><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><p>五、JWT 的几个特点<br>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><p>六、参考链接<br><a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a>，by Auth0<br><a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c">Sessionless Authentication using JWTs (with Node + Express + Passport JS)</a>, by Bryan Manuele<br><a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md">Learn how to use JSON Web Tokens</a>, by dwyl</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是微服务架构？</title>
      <link href="/hypo-Z.github.io/2021/12/03/18-shi-me-shi-wei-fu-wu-jia-gou/"/>
      <url>/hypo-Z.github.io/2021/12/03/18-shi-me-shi-wei-fu-wu-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>什么是软件架构？<br>软件架构的重要性<br>什么是微服务架构？<br>微服务架构的优缺点<br>其他突出的软件架构模式<br>构建微服务架构的最佳实践<br>计划构建微服务架构？</p><h2 id="什么是软件架构？"><a href="#什么是软件架构？" class="headerlink" title="什么是软件架构？"></a>什么是软件架构？</h2><p><img src="https://www.devteam.space/wp-content/uploads/2019/01/What-is-software-architecture.jpg"><br>软件架构模式的模式</p><p>软件架构本质上是任何给定软件系统的结构。它用于提供整个系统的图形表示，有助于开发人员。</p><p>通常有多个组件，每个组件都解决一个或多个功能。</p><p>上面的软件架构图示例显示了这些组件如何相互交互。在“软件架构”中阅读更多相关信息。请记住，上图只是一个基本示例。</p><p>我们称之为软件架构的示意图只是一种视觉表示。每个系统图都显示了软件架构师决定的一系列设计原则，以确保最佳的整体系统功能。做出架构决策是为了确保最佳的安全性、性能、可管理性等。</p><p>这些设计原则、架构决策和示意图都是软件架构的组成部分。它们共同使系统能够满足其业务、运营和技术目标。在此 Techopedia 软件架构定义中阅读更多内容。</p><h2 id="软件架构的重要性"><a href="#软件架构的重要性" class="headerlink" title="软件架构的重要性"></a>软件架构的重要性</h2><p>软件架构对于产品的成功极其重要。有几个原因。</p><h3 id="第一组决定"><a href="#第一组决定" class="headerlink" title="第一组决定"></a>第一组决定</h3><p>在“软件开发生命周期”（SDLC）期间，开发团队在软件架构的创建过程中做出与系统相关的关键决策。在此过程之前，将仅概述业务需求。</p><p>如您所知，确保第一组决策正确无误，将使您的项目处于最佳状态以顺利运行。另一方面，如果这些决定不正确，您的项目几乎肯定会遇到严重的问题。在“良好软件架构的重要性”中阅读更多相关信息。</p><h3 id="视觉呈现的交流工具"><a href="#视觉呈现的交流工具" class="headerlink" title="视觉呈现的交流工具"></a>视觉呈现的交流工具</h3><p>软件架构是一种工具，通过提供示意性表示来帮助沟通，这些表示显示与改进核心功能相关的底层决策。做对了，您的所有项目利益相关者以及您的开发团队将准确了解您的产品将如何运作。</p><h3 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h3><p>软件架构有助于持续开发，特别是对于未来的项目。由于您已经制定和实施了一次架构决策，并拥有示意图，因此可以在未来的项目中重复使用或扩展这些决策。</p><p>这意味着您可以为新产品重用大部分核心结构，因为只有开发工具、编程语言等会有所不同。没有良好的软件架构，项目或产品可能会失败。在此 Quora 问答主题中阅读更多相关信息。</p><h2 id="什么是微服务架构？"><a href="#什么是微服务架构？" class="headerlink" title="什么是微服务架构？"></a>什么是微服务架构？</h2><p><img src="https://www.devteam.space/wp-content/uploads/2019/01/What-is-the-microservices-architecture.jpg"><br>单体架构和微服务架构差异的示意图</p><p>微服务架构模式帮助开发人员创建多个较小的程序，而不是一个大程序。一个大程序通常很难维护，此外，添加新功能也很困难。使用微服务架构，程序员为每个功能创建一个小程序。添加新功能只需要创建另一个小程序。</p><p>视频点播平台 Netflix 是这种架构模式的一个很好的例子。正如您所料，Netflix“用户界面”(UI) 中的每个部分都是不同的服务。实际上，UI 就像是不同网站的集合，尽管它看起来只是一个。阅读“微服务架构（示例和图表） ”了解更多详情。</p><h2 id="微服务架构的优缺点"><a href="#微服务架构的优缺点" class="headerlink" title="微服务架构的优缺点"></a>微服务架构的优缺点</h2><h4 id="这种模式有很多优点："><a href="#这种模式有很多优点：" class="headerlink" title="这种模式有很多优点："></a>这种模式有很多优点：</h4><p>当企业提供彼此明显分离的功能时，这种架构模式可以使他们的应用程序具有高度可扩展性。<br>个别服务可能有不同的需求概况，因此，企业将为这些个别服务实施扩展策略。这有助于优化和确定资源的优先级。<br>如果您使用这种架构模式，您会发现阅读和理解您的代码库会容易得多。<br>维护应用程序更容易。<br>单个微服务可以单独部署。您只部署已更改的微服务，而不是整个应用程序。这减少了在部署过程中花费的时间和精力。<br>您发现调试应用程序更容易，因为您无需查看大型应用程序的多个层。<br>微服务架构模式可以更轻松地隔离故障。<br>如果您使用微服务架构模式，您可以构建更具弹性的服务，这会提高您的应用程序的容错能力。<br>如果您使用微服务架构，则可以提高可重用性。在此模式中，您可以围绕业务功能构建和组织微服务。当与其他业务功能存在共性时，您可以以最少的更改重用您之前开发的微服务。这种重用有助于降低您的开发成本。<br>在“什么是微服务？”。</p><h4 id="也有缺点："><a href="#也有缺点：" class="headerlink" title="也有缺点："></a>也有缺点：</h4><p>如果我们不能清楚地将服务彼此分开，这种模式会增加复杂性。<br>如果多个服务使用相同的任务，则此模式会对性能产生不利影响。<br>如果由于网站不同部分的页面速度不同，微服务过多，用户可能会发现 UI 混乱。如果您使用太多不同的编程语言来开发不同的微服务，那么您的应用程序将更加难以维护。<br>如果您使用微服务架构，集成测试可能会很困难。如果您的组件位于其他系统/环境中，那么您会发现很难设置端到端的集成测试环境。<br>您需要仔细定义微服务与其他服务交互的接口。如果您有太多由不同团队开发的微服务，那么定义此类接口可能会很困难。不同的微服务将相互依赖输入。不同的开发团队需要清楚地了解其他微服务可能使用的接口，因此，沟通是关键。<br>微服务架构实现的一个突出例子<br>想看看微服务架构在起作用吗？好吧，Netflix 就是您的最佳选择！这家流行的流媒体服务提供商充分利用了这种架构模式。</p><p>Netflix 仍在经历高速增长，然而，该公司最初难以跟上它的步伐。它有一个单体架构，它的数据中心与此保持一致。Netflix 无法以足够快的速度建立足够数量的数据中心来跟上其令人印象深刻的增长。</p><p>同年，一个模块代码中缺少一个分号导致 Netflix 网站瘫痪。该网站关闭了几个小时，需要一个大型工程团队的共同努力才能恢复。当 Netflix 不得不进行故障排除时，它总是不得不聘请一个由多个领域组成的大型工程团队。嗯，这就是使用单体架构的巨大应用程序的缺点！</p><p>Netflix 于 2009 年开始转向 AWS 云微服务架构，当时微服务架构模式并不流行，甚至连“微服务”这个词都没有使用。</p><p>该公司于 2009 年首次迁移了一款非面向客户的应用程序，并且进展顺利。随后，Netflix 将其网站的几个面向客户的功能转移到了 AWS 云微服务架构中。到 2011 年 12 月，Netflix 完成了搬迁。</p><p>就本月的情况而言，Netflix 微服务架构中的 API 网关每天处理 20 亿次 API 调用！您可以阅读“为什么不提及 Netflix 就不能谈论微服务”以了解有关此转变的更多信息。</p><p>其他突出的软件架构模式<br>当我们回顾其他软件架构模式的特征时，微服务架构的重要性变得更加清晰。</p><p>微服务架构还有其他四种关键模式：</p><h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>这是最常见的软件架构模式。大多数业务应用程序将信息存储在数据库表中。这种模式在层中有代码。最顶层接受数据。然后数据导航到最底部的层，即数据库。</p><p>大多数关键框架（如 Java EE）都使用这种模式。分层架构提供了一些优势，例如，应用程序易于维护，测试更容易。在“大型企业 Java 项目架构”中阅读更多相关信息。</p><p>缺点是代码量大且无组织，其中大部分只在层之间传递数据，不执行任何业务逻辑。这会影响产品的性能。</p><h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><p>许多用例涉及仅在有数据要处理时才执行的程序。在事件驱动架构的情况下，中央单元接收所有数据输入。特定的数据输入是事件。然后中央单元委托适当的组件处理特定类型的数据。</p><p>并非所有模块都处理所有数据。这使得应用程序具有可扩展性，此外，开发人员可以轻松扩展系统以应对新事件。在“前 5 种软件架构模式：如何做出正确选择”中阅读更多相关信息。</p><p>有一些缺点。当模块相互影响时，测试变得更加困难。如果多个模块处理同一个事件，它会使错误处理复杂化。由于消息传递开销，系统可能会变慢。</p><h4 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h4><p>常用工具有一组用户重复执行的任务。著名的“集成开发环境”(IDE) Eclipse 就是一个这样的例子，它具有可重复的任务，如打开文件、编辑文件等。</p><p>微内核架构使用微内核来包含这些基本功能。我们可以将其上的所有其他内容视为“插件”。这种模式非常适合流行的工具，因为它可以提高性能。但是，很难定义常见的任务。在“软件架构：您需要了解的 5 种模式”中阅读更多相关信息。</p><h4 id="天基建筑"><a href="#天基建筑" class="headerlink" title="天基建筑"></a>天基建筑</h4><p>基于空间的架构的目标 是在高负载时为 Web 应用程序提供健壮性和稳定性。大多数网站都是围绕数据库构建的，因此，它们依赖于数据库来处理负载。</p><p>使用基于空间的架构，软件架构师将处理和存储拆分到多个服务器中。数据和服务调用分布在节点之间。这有助于避免数据库在高负载情况下崩溃。请注意，测试整个系统可能很困难，因为模拟负载条件可能很棘手。</p><h3 id="构建微服务架构的最佳实践"><a href="#构建微服务架构的最佳实践" class="headerlink" title="构建微服务架构的最佳实践"></a>构建微服务架构的最佳实践</h3><p>微服务架构实现的最佳实践<br>寻找最佳微服务架构<br>概述您的微服务<br>领域驱动设计<br>让每个人都加入<br>使用 RESTful API<br>为特定的微服务建立团队<br>设置服务器和数据存储环境<br>文档 API<br>使用最好的 DevOps 工具包<br>监控是关键</p><h4 id="最佳实践-1：确定微服务架构是否符合您的要求"><a href="#最佳实践-1：确定微服务架构是否符合您的要求" class="headerlink" title="最佳实践 #1：确定微服务架构是否符合您的要求"></a>最佳实践 #1：确定微服务架构是否符合您的要求</h4><p>Amazon、Twitter、eBay 和 PayPal 是成功实施微服务架构设计的组织的例子。这是一种流行的模式，然而，这并不意味着它对你有用。</p><p>如果您不能将您的 Web 应用程序分解为提供价值的功能，那么微服务架构对您来说就没有意义了。阅读“模式：按业务能力分解”以获得更多见解。</p><h4 id="最佳实践-2：定义您的微服务"><a href="#最佳实践-2：定义您的微服务" class="headerlink" title="最佳实践#2：定义您的微服务"></a>最佳实践#2：定义您的微服务</h4><p>您需要明确区分业务功能、服务和微服务。如果没有这个，您可能会构建过大的微服务。这是一种不完整的形式，您将看不到使用微服务方法的任何好处。</p><p>另一方面是创建过多微服务的可能性。这将导致您的架构过度碎片化。请记住，要管理微服务架构，您需要一个成熟的运营团队。在“微服务权衡”中了解它。</p><p>如果微服务太多，运营管理成本会很高。您将看到运营成本的激增掩盖了您从微服务中获得的收益。</p><h4 id="最佳实践-3：使用“领域驱动设计”（DDD）来设计微服务"><a href="#最佳实践-3：使用“领域驱动设计”（DDD）来设计微服务" class="headerlink" title="最佳实践#3：使用“领域驱动设计”（DDD）来设计微服务"></a>最佳实践#3：使用“领域驱动设计”（DDD）来设计微服务</h4><p>虽然这一步与定义微服务的练习密切相关，但它更进了一步。在这里，您可以围绕您的业务领域设计微服务。让我们再次回顾 Netflix 示例。他们从不同的服务器运行他们的内容交付和不同的跟踪服务。</p><p>“领域驱动设计”(DDD) 是一种设计原则，它使用实用的规则和思想来表达面向对象的模型。它帮助软件架构师了解不同的业务领域，因此，他们可以专注于构建业务可以很好理解的微服务架构。在“ DDD 101 — 5 分钟之旅”中阅读更多相关信息。</p><h4 id="最佳实践-4：尽早获得组织领导和团队的支持"><a href="#最佳实践-4：尽早获得组织领导和团队的支持" class="headerlink" title="最佳实践#4：尽早获得组织领导和团队的支持"></a>最佳实践#4：尽早获得组织领导和团队的支持</h4><p>实现微服务架构设计不仅仅是一个技术决策。这种转型代价高昂，而且影响不仅限于内部开发团队。从单体架构过渡是一个漫长的项目。组织中的高级管理人员必须为此投入资金。</p><p>对您的开发团队的影响将是巨大的。到目前为止，您的团队一直在使用端到端测试过程来测试整个系统，以防出现增强。您现在需要围绕微服务对系统进行模块化。这需要文化转型。</p><p>转型将有助于您的业务敏捷性，因为它将促进持续交付。但是，团队必须完全接受转型。阅读我们的指南“敏捷帮助变革管理的 5 种方式”，了解如何有效地帮助这种转变。</p><h4 id="最佳实践-5：最佳地使用-RESTful-API"><a href="#最佳实践-5：最佳地使用-RESTful-API" class="headerlink" title="最佳实践 #5：最佳地使用 RESTful API"></a>最佳实践 #5：最佳地使用 RESTful API</h4><p>如果您优化使用 RESTful API，微服务架构模式可以提供重要的价值。RESTful API 提供了许多优点，例如，您不需要在客户端安装任何东西。您不需要 SDK 或框架，因为使用 API 服务的 HTTP 请求就足够了。在此 Quora 问答主题中阅读有关 RESTful API 优势的更多信息。</p><p>RESTful API 领域的专家 Leonard Richardson 提出了 REST API 使用的成熟度模型。为了从您的微服务架构中实现最佳价值，您应该尝试达到此成熟度模型的最高水平。阅读“微服务架构的 10 个最佳实践”以获得更多见解。</p><h4 id="最佳实践-6：围绕微服务组织团队"><a href="#最佳实践-6：围绕微服务组织团队" class="headerlink" title="最佳实践 #6：围绕微服务组织团队"></a>最佳实践 #6：围绕微服务组织团队</h4><p>您需要建立不同的团队来处理不同的微服务。这些团队应该被赋予足够的权力来处理他们的微服务。但是，所有团队都应该跨职能并了解整个项目计划。</p><p>每个团队都应该具备构建云原生应用程序的必要技能。每个团队都需要业务分析师、开发人员、测试人员和 DevOps 工程师。每个团队都应该有自己的项目经理 (PM)。我们的指南“如何建立Scrum开发团队？”可以帮助您组织这些团队。</p><h4 id="最佳实践-7：为每个微服务提供单独的数据存储"><a href="#最佳实践-7：为每个微服务提供单独的数据存储" class="headerlink" title="最佳实践 #7：为每个微服务提供单独的数据存储"></a>最佳实践 #7：为每个微服务提供单独的数据存储</h4><p>每个微服务都应该为其数据存储做好准备。每个微服务都应该完全拥有自己的数据。当然，数据可以在微服务之间共享，但是，这应该通过 API 进行。</p><p>如果多个微服务共享同一个数据存储，这会导致服务之间的耦合。这将大大违背微服务架构的目的。在“ Top 5+ 微服务架构和设计最佳实践”中阅读更多相关信息。</p><h4 id="最佳实践-8：基于领域设计-API-并很好地记录它们"><a href="#最佳实践-8：基于领域设计-API-并很好地记录它们" class="headerlink" title="最佳实践 #8：基于领域设计 API 并很好地记录它们"></a>最佳实践 #8：基于领域设计 API 并很好地记录它们</h4><p>充分注意基于业务领域设计 API。很好地记录 API。考虑使用Swagger 之类的工具。我们有一个指南“如何为您的移动应用程序构建 RESTful API？”您可以咨询。</p><h4 id="最佳实践-9：使用好的-DevOps-工具集"><a href="#最佳实践-9：使用好的-DevOps-工具集" class="headerlink" title="最佳实践 #9：使用好的 DevOps 工具集"></a>最佳实践 #9：使用好的 DevOps 工具集</h4><p>到目前为止，您应该已经将微服务设计得足够好，可以独立部署它们。为了从这些微服务中实现最佳价值，您需要自动化构建和部署管理。因此，您将需要一套良好的 DevOps 工具。</p><p>用于部署自动化的 Jenkins 和用于容器化的 Docker 是一个很好的组合。但是，如果您需要更多示例，请阅读“ 2019 年的 10 个最佳 DevOps 工具”。</p><h4 id="最佳实践-10：投资于监控"><a href="#最佳实践-10：投资于监控" class="headerlink" title="最佳实践 #10：投资于监控"></a>最佳实践 #10：投资于监控</h4><p>如果您使用的是单体架构并正在过渡到微服务架构，则必须解决日益增加的复杂性。对性能和动态环境的需求增加需要更高级的监控。</p><p>一个好的监控解决方案应该解决资源分配的持续变化。这样的解决方案应该将从监控中收集的数据存储在中央数据库中。它产生的洞察力应该揭示应用程序的动态特性。</p><p>每个微服务都应该使用监控代理。监控系统应支持根本原因分析。阅读更多关于它在“成功微服务设计的 5 个基础”中的重要性。</p><h3 id="部署微服务架构时的关键考虑因素"><a href="#部署微服务架构时的关键考虑因素" class="headerlink" title="部署微服务架构时的关键考虑因素"></a>部署微服务架构时的关键考虑因素</h3><p>可以看到，部署微服务架构是一个涉及到的项目。在进行此类项目时，请牢记以下注意事项：</p><ol><li><p>管理依赖<br>您需要在微服务架构中以不同于单体应用程序中的方式管理依赖项。微服务架构涉及每个独立运行的服务。但是，一个微服务可能需要访问系统的其他部分。这就是复杂性出现的地方。仔细考虑依赖关系。</p></li><li><p>寻找具有所需知识的建筑师<br>架构师将在实施微服务架构中发挥关键作用。你需要一个称职的建筑师。架构师可能需要使用事件驱动的聚合来实现此架构，这需要适当的后端相关专业知识。</p></li></ol><p>请记住，微服务架构中的微服务是分布式系统。因此，架构师需要具备这方面的良好知识。</p><p>此外，架构师需要实现从多个数据存储中检索数据的查询。在微服务架构中，这将比单体应用更复杂。该项目可能会使用“事件溯源”模式，这会增加复杂性。架构师可能需要在此处使用“通用查询职责分离”(CQRS) 模式。</p><p>在某些情况下，架构师可能需要使用“断路器”模式。这可以帮助多个服务在为请求提供服务时进行协作。一个服务可能会同步调用另一个服务。此其他服务可能会停机，或者，它可能会遇到高延迟。“断路器”模式可防止此类问题影响其他服务。</p><p>负载平衡恰好是架构师需要足够经验的另一个领域。它有助于微服务在管理系统负载的同时保持安全性和可用性。</p><p>开发人员可能会在创建微服务时对要实现的端点数量感到困惑。知识渊博的软件架构师可以在这里发挥很大的作用，因为他/她知道端点的数量取决于服务的类型。</p><ol start="3"><li>使用正确的工具和框架，如“Spring Boot”<br>使用正确的开源工具可以极大地帮助实现微服务架构。幸运的是，您可以利用丰富的开源工具生态系统。</li></ol><p>例如，您可以使用流行的开源框架“Spring Boot”轻松创建微服务。以下是此类工具的更多示例：</p><p>API开发的邮递员；<br>用于消息传递的 Amazon Simple Queue Service (SQS)；<br>用于监控的 Logstash；<br>用于部署的 Kubernetes。<br>GitHub 在这里值得一提，尽管它不是完全开源的。这有助于您进行版本控制和源代码管理。</p><ol start="4"><li>为可扩展性设计微服务<br>在设计微服务时，可扩展性是一个关键因素。无论是创建新服务还是增强现有服务，都需要注意这一点。为此，您需要考虑各种方法和技术。</li></ol><p>一个很好的例子是缓存。请记住遵循正确的教程在微服务架构中实现它。异步消息传递使您能够在构建微服务时提供更好的可扩展性。</p><ol start="5"><li>处理认证和授权<br>处理用户身份验证和授权在微服务和单体应用程序之间差异很大。您需要非常了解这些差异的架构师和开发人员。</li></ol><p>例如，他们需要准确地定义有界上下文。这将帮助他们定义具有大量粒度的用户授权。</p><p>再举一个例子。您的团队将需要使用令牌进行用户身份验证。存在各种类型的令牌，例如“JSON Web 令牌”(JWT)。近年来，这种开放标准的代币越来越受欢迎。您需要了解此类现代标准的架构师和开发人员。</p><ol start="6"><li>恰当地使用服务网格<br>有时您需要实现外部配置，如凭据以及微服务架构模式。您可能需要监控指标以了解应用程序的执行情况。考虑使用服务网格来管理服务之间的通信。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习惯的养成</title>
      <link href="/hypo-Z.github.io/2021/12/02/17-xi-guan-de-yang-cheng/"/>
      <url>/hypo-Z.github.io/2021/12/02/17-xi-guan-de-yang-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="习惯的养成"><a href="#习惯的养成" class="headerlink" title="习惯的养成"></a>习惯的养成</h1><p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p><p>看一本书 → 看一页书<br>写一篇文章 → 写一句话<br>跑10公里 → 穿上跑鞋<br>做100次俯卧撑 → 做1次俯卧撑<br>多吃蔬菜水果 → 吃一个水果<br>编写一个程序 → 编写一个函数 → 编写一行代码<br>这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。</p><p>阅读一页 → 阅读10页 → 读完第一章<br>写一个句子 → 写文章的开头 → 写出正文<br>穿上跑鞋 → 步行5分钟 → 跑步5分钟<br>一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。</p><p><img src="https://www.wangbase.com/blogimg/asset/202007/bg2020072418.jpg" alt="image"></p><p>一个人应该能够换尿布，策划战争，杀猪，开船，设计房子，写十四行诗，结算账户，砌墙，接脱臼的骨头，安慰濒死的人，服从命令，发布命令，携手合作，独立行动，解数学方程，分析新问题，铲粪，电脑编程，做出可口的饭，善打架，勇敢地死去。只有昆虫才专业化。<br>—— 罗伯特・安森・海因莱因</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二八定律</title>
      <link href="/hypo-Z.github.io/2021/11/30/16-er-ba-ding-lu/"/>
      <url>/hypo-Z.github.io/2021/11/30/16-er-ba-ding-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h1><ul><li>二八定律又叫帕累托定律,是19世纪末20世纪初意大利经济学家<br>帕累托发现的一种奇怪的社会现象。他认为,在任何一组东西中最重要的</li><li>只占其中一小部分,约20%,其余80%尽管是多数却是次要的,因此又称 二八定律,<br>最著名的是”社会上20%的人掌握了80%的财富!”外汇市场二八定律实际就是二<br>八定律在外汇市场上的一些具体表现,是一些看似不可能但又具有真实影响的<br>现象。</li><li>二八定律在社会中的现象极其普遍,它的现实意义:二八法则不仅在<br>经济学管理学领域应用广泛,它对我们自身发展也有重要的现实意义:<br>学会避免将时间和精力花费在琐事上,要学会抓主要矛盾。<br>一个人的精力和时间都是非常有限的要想真正”做好每件事情”几乎是<br>不可能的,要学会合理分配时间和精力。要想面面俱到还不如重点突破。<br>把80%的资源花在能出关键效益的炸的方面,这20%的方面又能带动其余<br>80%的发展。</li><li>二八定律运用在我自身,我认为我每天三分之一的时间用于在工作上,三分<br>之用手休息,还有三分之一也不能白白浪费,在工作中,80%时间用于解决实际<br>20%的难题就行了。其余20%用于学习新知识,扩展知识广度。而在私下<br>生活80%时间用于提升自身身心从煅练身体,阅读写作,训练口语方面着<br>手,而余下20%就拿来继续思考和处理琐事。</li><li>二八定律也可以用于人生的成长和财富积累，人生真正能好好生活的可能<br>就20%人生.所以在人生的黄金时期更要好好计划,让这20%去养活<br>余下80%人生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的青春结束了</title>
      <link href="/hypo-Z.github.io/2021/11/29/15-wo-de-qing-chun-jie-shu-liao/"/>
      <url>/hypo-Z.github.io/2021/11/29/15-wo-de-qing-chun-jie-shu-liao/</url>
      
        <content type="html"><![CDATA[<h1 id="我的青春结束了"><a href="#我的青春结束了" class="headerlink" title="我的青春结束了"></a>我的青春结束了</h1><p>在周六的那天晚天,因为第二天需要早起,我比平常更早的睡觉了,差不多<br>八点多就开始睡觉了,当我睡到九点半多时,我被微信视频信息吵醒了<br>,我咪咪糊糊打开手机开始接听。原来是我的好兄弟<br>打过来的,他略带惊讶和急切的口吻对我说道:”兄弟你听说了吗?<br>你还有你前女友的微信吗?你不知道发生什么了吗!”我缓缓说道:她<br>被求婚了是吧,我听鋭了”,他略带同情的对我说:”兄弟,你还跟她联<br>系吗?”我回忙了一下说”好像一年多没联系了,我屏敝她了。”</p><p>是啊,曾经那个学生时代难忘的回忆,在时间这个巨轮面前,就如<br>同一颗小石子被无情碾过。我一直坚信那句话,人是会变的，两个人能否<br>最终走到一起,需要的是正确的时间和正确的地点。青春的时候<br>我们天真无邪,认为世界就是你我不需要考虑现实。现实是随着<br>时间流淌我们变得越来越现实,而你我的模样早已不是当初的<br>记忆。但是,人终一日会找到她的归属,我怀着真诚的心,诚挚的<br>祝福每个在我成长路上遇到的人,希望她能幸福!</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生游戏</title>
      <link href="/hypo-Z.github.io/2021/11/25/14-ren-sheng-you-xi/"/>
      <url>/hypo-Z.github.io/2021/11/25/14-ren-sheng-you-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="人生是场游戏"><a href="#人生是场游戏" class="headerlink" title="人生是场游戏"></a>人生是场游戏</h1><p>生存是种即时策略游戏、所有的人都是这场游戏的玩家。财务自由了,<br>就是游戏的赢家。<br>具体来说又分成两种游戏财富游戏和地位游戏。财富游戏<br>的统家追求更多的财富,地位游戏的玩家追求最高的地位。<br>古时候,地位越高,财富越多,当大官就发大财.所以大家都说地位<br>游戏。现代社会财富游戏和地位游戏慢慢脱离了关系,不当大<br>官也可以发大财,财富游戏的玩家多了起来。<br>这两种游戏有本质的区别。地位游戏一定是零和的,有赢家<br>就肯定有输家。比如,我当了部门主管你就不能当了。所以地位<br>游戏很凶险,必须时刻提防其他玩家的冷枪。财富游戏不是零和的,<br>我赚了钱,不影响其人的收益很可能双赢。<br>创业是财富游戏,政治是地位游戏。因为上面的原因,我<br>认为,创业值得参与,政治不值得参与。有些创业项目也是零和的,<br>比如,抢票技术、秒杀技术、游戏外挂等,也不值得参与。</p><p>引用—网络</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/hypo-Z.github.io/2021/11/24/13-du-shu-bi-ji/"/>
      <url>/hypo-Z.github.io/2021/11/24/13-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>人不定命运的囚徒而是自己思想的囚徒——富兰克林•罗斯福</p><p>在我们进行天分比较时经常忽略沉默的证据,尤其在那些<br>受赢家通吃效应影响的行业。我们也许很喜欢那些成功故事,但太<br>把它们当回事是不应该的,因为我们并没有看到全部事实。</p><p>列夫·托尔斯泰说过,所有幸运的家庭都是一样的,而不幸的家庭<br>各有各的不幸。人们被发现犯了”喜欢苹果胜于喜欢橘子,喜欢橘子胜于<br>梨,喜欢梨胜于苹果”的错误,这视具体问题而定。<br>我们应该避免柏拉图化的思想。柏拉图化是自上而下的,程式化的,<br>封闭思维的,自我服务的商品化的,非柏拉图化是自下而上的开放<br>思维的,怀疑的经验的。<br>—-节选《黑天鹅》</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——并发</title>
      <link href="/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-bing-fa/"/>
      <url>/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——并发"><a href="#Go语言基础——并发" class="headerlink" title="Go语言基础——并发"></a>Go语言基础——并发</h1><p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发，这也是Go语言流行的一个很重要的原因。</p><h1 id="Go语言中的并发编程"><a href="#Go语言中的并发编程" class="headerlink" title="Go语言中的并发编程"></a>Go语言中的并发编程</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p><p>举个例子如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p><p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p><p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// goroutine结束就登记-1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 启动一个goroutine就登记+1</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 等待所有登记的goroutine都结束</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h2 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h2><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ul><li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">点我了解更多</a></p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> 变量 <span class="token keyword">chan</span> 元素类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举几个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch1 <span class="token keyword">chan</span> <span class="token builtin">int</span>   <span class="token comment">// 声明一个传递整型的通道</span><span class="token keyword">var</span> ch2 <span class="token keyword">chan</span> <span class="token builtin">bool</span>  <span class="token comment">// 声明一个传递布尔型的通道</span><span class="token keyword">var</span> ch3 <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// 声明一个传递int切片的通道</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// &lt;nil&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p><p>创建channel的格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> 元素类型<span class="token punctuation">,</span> <span class="token punctuation">[</span>缓冲大小<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>channel的缓冲大小是可选的。</p><p>举几个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch4 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch5 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>ch6 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">&lt;-</span> <span class="token number">10</span> <span class="token comment">// 把10发送到ch中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch <span class="token comment">// 从ch中接收值并赋值给变量x</span><span class="token operator">&lt;-</span>ch       <span class="token comment">// 从ch中接收值，忽略结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">fatal error: all goroutines are asleep - deadlock<span class="token operator">!</span>goroutine <span class="token number">1</span> <span class="token punctuation">[</span>chan send<span class="token punctuation">]</span>:main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">..</span>./src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">recv</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ret <span class="token operator">:=</span> <span class="token operator">&lt;-</span>cfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收成功"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">recv</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 启用goroutine从通道接收值</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个容量为1的有缓冲区通道</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p><p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p><p>我们来看下面这个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// channel 练习</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token comment">// 开启goroutine将0~100的数发送到ch1中</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>ch1 <span class="token operator">&lt;-</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span>i<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1 <span class="token comment">// 通道关闭后再取值ok=false</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span>ch2 <span class="token operator">&lt;-</span> i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 在主goroutine中从ch2中接收值打印</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> ch2 <span class="token punctuation">{</span> <span class="token comment">// 通道关闭后会退出for range循环</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">counter</span><span class="token punctuation">(</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>out <span class="token operator">&lt;-</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">squarer</span><span class="token punctuation">(</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">,</span> in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">{</span>out <span class="token operator">&lt;-</span> i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">printer</span><span class="token punctuation">(</span>in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">counter</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">squarer</span><span class="token punctuation">(</span>ch2<span class="token punctuation">,</span> ch1<span class="token punctuation">)</span><span class="token function">printer</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p><h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src="https://www.liwenzhou.com/images/Go/concurrence/channel01.png" alt="channel异常总结"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p><h2 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h2><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p><p>一个简易的<code>work pool</code>示例代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">,</span> jobs <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> results <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token keyword">range</span> jobs <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"worker:%d start job:%d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> j<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"worker:%d end job:%d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> j<span class="token punctuation">)</span>results <span class="token operator">&lt;-</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>jobs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>results <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">// 开启3个goroutine</span><span class="token keyword">for</span> w <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> w <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> w<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> jobs<span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 5个任务</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>jobs <span class="token operator">&lt;-</span> j<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token comment">// 输出结果</span><span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token operator">&lt;-</span>results<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span><span class="token punctuation">{</span>    <span class="token comment">// 尝试从ch1接收值</span>    data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1    <span class="token comment">// 尝试从ch2接收值</span>    data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2    …<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">case</span> data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">case</span> ch3<span class="token operator">&lt;-</span>data<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        默认操作<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个小例子来演示下<code>select</code>的使用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li><li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li></ul><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int64</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int64</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">var</span> lock sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加锁</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 解锁</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p><p>读写锁示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>x      <span class="token builtin">int64</span>wg     sync<span class="token punctuation">.</span>WaitGrouplock   sync<span class="token punctuation">.</span>Mutexrwlock sync<span class="token punctuation">.</span>RWMutex<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// lock.Lock()   // 加互斥锁</span>rwlock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加写锁</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// 假设读操作耗时10毫秒</span>rwlock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   <span class="token comment">// 解写锁</span><span class="token comment">// lock.Unlock()                     // 解互斥锁</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// lock.Lock()                  // 加互斥锁</span>rwlock<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment">// 加读锁</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// 假设读操作耗时1毫秒</span>rwlock<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment">// 解读锁</span><span class="token comment">// lock.Unlock()                // 解互斥锁</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">(wg * WaitGroup) Add(delta int)</td><td align="center">计数器+delta</td></tr><tr><td align="center">(wg *WaitGroup) Done()</td><td align="center">计数器-1</td></tr><tr><td align="center">(wg *WaitGroup) Wait()</td><td align="center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。</p><p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p><p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p><h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">{</span><span class="token string">"left"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"up"</span><span class="token punctuation">:</span>    <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">:</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Icon 被多个goroutine调用时不是并发安全的</span><span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">{</span><span class="token keyword">if</span> icons <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"up"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"down"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token keyword">var</span> loadIconsOnce sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">{</span><span class="token string">"left"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"up"</span><span class="token punctuation">:</span>    <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">:</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Icon 是并发安全的</span><span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">{</span>loadIconsOnce<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>loadIcons<span class="token punctuation">)</span><span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> singleton<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance <span class="token operator">*</span>singleton<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">{</span>    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">set</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>key <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> n<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k=:%v,v:=%v\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p><p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> m <span class="token operator">=</span> sync<span class="token punctuation">.</span>Map<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>key <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>m<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> n<span class="token punctuation">)</span>value<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k=:%v,v:=%v\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>在上面的代码中的我们通过锁操作来实现同步。而锁机制的底层是基于原子操作的，其一般直接通过CPU指令实现。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td align="center">读取操作</td></tr><tr><td align="center">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td align="center">写入操作</td></tr><tr><td align="center">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td align="center">修改操作</td></tr><tr><td align="center">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td align="center">交换操作</td></tr><tr><td align="center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td align="center">比较并交换操作</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"sync"</span><span class="token string">"sync/atomic"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Counter <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token comment">// 普通版</span><span class="token keyword">type</span> CommonCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c CommonCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c CommonCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token comment">// 互斥锁版</span><span class="token keyword">type</span> MutexCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span>lock    sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>m<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span>m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> m<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token comment">// 原子操作版</span><span class="token keyword">type</span> AtomicCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>counter<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span><span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">LoadInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroupstart <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c1 <span class="token operator">:=</span> CommonCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 非并发安全</span><span class="token function">test</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>c2 <span class="token operator">:=</span> MutexCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 使用互斥锁实现并发安全</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c2<span class="token punctuation">)</span>c3 <span class="token operator">:=</span> AtomicCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 并发安全且比互斥锁效率更高</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c3<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——网络编程</title>
      <link href="/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-wang-luo-bian-cheng/"/>
      <url>/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——网络编程"><a href="#Go语言基础——网络编程" class="headerlink" title="Go语言基础——网络编程"></a>Go语言基础——网络编程</h1><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><h2 id="socket图解"><a href="#socket图解" class="headerlink" title="socket图解"></a>socket图解</h2><p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在<code>Socket</code>后面，对用户来说只需要调用Socket规定的相关函数，让<code>Socket</code>去组织符合指定的协议数据然后进行通信。</p><p><img src="https://www.liwenzhou.com/images/Go/socket/socket.png" alt="socket图解"></p><h2 id="Go语言实现TCP通信"><a href="#Go语言实现TCP通信" class="headerlink" title="Go语言实现TCP通信"></a>Go语言实现TCP通信</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。</p><h3 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h3><p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p><p>TCP服务端程序的处理流程：</p><ol><li>监听端口</li><li>接收客户端请求建立链接</li><li>创建goroutine处理链接。</li></ol><p>我们使用Go语言的net包实现的TCP服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// tcp/server/main.go</span><span class="token comment">// TCP server端</span><span class="token comment">// 处理函数</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭连接</span><span class="token keyword">for</span> <span class="token punctuation">{</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token builtin">byte</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 读取数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read from client failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>recvStr <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client端发来的数据："</span><span class="token punctuation">,</span> recvStr<span class="token punctuation">)</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>recvStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:20000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 建立连接</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token comment">// 启动一个goroutine处理连接</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码保存之后编译成<code>server</code>或<code>server.exe</code>可执行文件。</p><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><p>一个TCP客户端进行TCP通信的流程如下：</p><ol><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><p>使用Go语言的net包实现的TCP客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// tcp/client/main.go</span><span class="token comment">// 客户端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:20000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"err :"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭连接</span>inputReader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>input<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> inputReader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 读取用户输入</span>inputInfo <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Trim</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>inputInfo<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"Q"</span> <span class="token punctuation">{</span> <span class="token comment">// 如果输入q就退出</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>inputInfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>buf <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"recv failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码编译成<code>client</code>或<code>client.exe</code>可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。</p><h2 id="TCP黏包"><a href="#TCP黏包" class="headerlink" title="TCP黏包"></a>TCP黏包</h2><h3 id="黏包示例"><a href="#黏包示例" class="headerlink" title="黏包示例"></a>黏包示例</h3><p>服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/server/main.go</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">for</span> <span class="token punctuation">{</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read from client failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>recvStr <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client发来的数据："</span><span class="token punctuation">,</span> recvStr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/client/main.go</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial failed, err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>msg <span class="token operator">:=</span> <span class="token string">`Hello, Hello. How are you?`</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/proto/proto.go</span><span class="token keyword">package</span> proto<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"bytes"</span><span class="token string">"encoding/binary"</span><span class="token punctuation">)</span><span class="token comment">// Encode 将消息编码</span><span class="token keyword">func</span> <span class="token function">Encode</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 读取消息的长度，转换成int32类型（占4个字节）</span><span class="token keyword">var</span> length <span class="token operator">=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">var</span> pkg <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span><span class="token comment">// 写入消息头</span>err <span class="token operator">:=</span> binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// 写入消息实体</span>err <span class="token operator">=</span> binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token keyword">return</span> pkg<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token comment">// Decode 解码消息</span><span class="token keyword">func</span> <span class="token function">Decode</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 读取消息的长度</span>lengthByte<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Peek</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// 读取前4个字节的数据</span>lengthBuff <span class="token operator">:=</span> bytes<span class="token punctuation">.</span><span class="token function">NewBuffer</span><span class="token punctuation">(</span>lengthByte<span class="token punctuation">)</span><span class="token keyword">var</span> length <span class="token builtin">int32</span>err <span class="token operator">:=</span> binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>lengthBuff<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// Buffered返回缓冲中现有的可读取的字节数。</span><span class="token keyword">if</span> <span class="token function">int32</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">Buffered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token operator">+</span><span class="token number">4</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// 读取真正的消息数据</span>pack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">+</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>pack<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>pack<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在服务端和客户端分别使用上面定义的<code>proto</code>包的<code>Decode</code>和<code>Encode</code>函数处理数据。</p><p>服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/server2/main.go</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"decode msg failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client发来的数据："</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/client2/main.go</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial failed, err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>msg <span class="token operator">:=</span> <span class="token string">`Hello, Hello. How are you?`</span>data<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"encode msg failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Go语言实现UDP通信"><a href="#Go语言实现UDP通信" class="headerlink" title="Go语言实现UDP通信"></a>Go语言实现UDP通信</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种<strong>无连接</strong>的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><h3 id="UDP服务端"><a href="#UDP服务端" class="headerlink" title="UDP服务端"></a>UDP服务端</h3><p>使用Go语言的<code>net</code>包实现的UDP服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// UDP/server/main.go</span><span class="token comment">// UDP server端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">ListenUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>UDPAddr<span class="token punctuation">{</span>IP<span class="token punctuation">:</span>   net<span class="token punctuation">.</span><span class="token function">IPv4</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Port<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token keyword">var</span> data <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token builtin">byte</span>n<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">ReadFromUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 接收数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read udp failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"data:%v addr:%v count:%v\n"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> listen<span class="token punctuation">.</span><span class="token function">WriteToUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write to udp failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><p>使用Go语言的<code>net</code>包实现的UDP客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// UDP 客户端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>socket<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>UDPAddr<span class="token punctuation">{</span>IP<span class="token punctuation">:</span>   net<span class="token punctuation">.</span><span class="token function">IPv4</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Port<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"连接服务端失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> socket<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>sendData <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello server"</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>sendData<span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送数据失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> remoteAddr<span class="token punctuation">,</span> err <span class="token operator">:=</span> socket<span class="token punctuation">.</span><span class="token function">ReadFromUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 接收数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收数据失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"recv:%v addr:%v count:%v\n"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remoteAddr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——数组与切片</title>
      <link href="/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-shu-zu-yu-qie-pian/"/>
      <url>/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-shu-zu-yu-qie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——数组与切片"><a href="#Go语言基础——数组与切片" class="headerlink" title="Go语言基础——数组与切片"></a>Go语言基础——数组与切片</h1><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 定义一个长度为3元素类型为int的数组a</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var 数组变量名 <span class="token punctuation">[</span>元素数量<span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span>a <span class="token operator">=</span> b <span class="token comment">//不可以这样做，因为此时a和b是不同的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>                        <span class="token comment">//数组会初始化为int类型的零值</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>                 <span class="token comment">//使用指定的初始值完成初始化</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span> <span class="token comment">//使用指定的初始值完成初始化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                      <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                       <span class="token comment">//[1 2 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                      <span class="token comment">//[北京 上海 深圳]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                          <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                           <span class="token comment">//[1 2]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of numArray:%T\n"</span><span class="token punctuation">,</span> numArray<span class="token punctuation">)</span>   <span class="token comment">//type of numArray:[2]int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                          <span class="token comment">//[北京 上海 深圳]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of cityArray:%T\n"</span><span class="token punctuation">,</span> cityArray<span class="token punctuation">)</span> <span class="token comment">//type of cityArray:[3]string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>                  <span class="token comment">// [0 1 0 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of a:%T\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">//type of a:[4]int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span><span class="token comment">// 方法1：for循环遍历</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 方法2：for range遍历</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">arraySum</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>    sum <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> x<span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> v    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 声明切片类型</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>              <span class="token comment">//声明一个字符串切片</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>             <span class="token comment">//声明一个整型切片并初始化</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token comment">//声明一个布尔切片并初始化</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token comment">//声明一个布尔切片并初始化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>              <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>              <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>              <span class="token comment">//[false true]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//false</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//false</span><span class="token comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><h4 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a>简单切片表达式</h4><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>s <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// s := a[low:high]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s:%v len(s):%v cap(s):%v\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[2:len(a)]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[0:3]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment">// 等同于 a[0:len(a)]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>s <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// s := a[low:high]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s:%v len(s):%v cap(s):%v\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>s2 <span class="token operator">:=</span> s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment">// 索引的上限是cap(s)而不是len(s)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s2:%v len(s2):%v cap(s2):%v\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:4s2:<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>:1 cap<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a<span class="token punctuation">[</span>low <span class="token punctuation">:</span> high <span class="token punctuation">:</span> max<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>t <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"t:%v len(t):%v cap(t):%v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">t:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>t<span class="token punctuation">)</span>:4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T, size, cap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>      <span class="token comment">//[0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//10</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>         <span class="token comment">//len(s1)=0;cap(s1)=0;s1==nil</span>s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment">//len(s2)=0;cap(s2)=0;s2!=nil</span>s3 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//len(s3)=0;cap(s3)=0;s3!=nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">//[0 0 0]</span>s2 <span class="token operator">:=</span> s1             <span class="token comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token comment">//[100 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token comment">//[100 0 0]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// [1]</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment">// [1 2 3 4]</span>s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>  s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// [1 2 3 4 5 6 7]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 没有必要初始化</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token comment">// 没有必要初始化</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//append()添加元素和切片扩容</span><span class="token keyword">var</span> numSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>numSlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">,</span> i<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v  len:%d  cap:%d  ptr:%p\n"</span><span class="token punctuation">,</span> numSlice<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">)</span><span class="token punctuation">,</span> numSlice<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  len:1  cap:1  ptr:0xc0000a8000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>  len:2  cap:2  ptr:0xc0000a8040<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>  len:3  cap:4  ptr:0xc0000b2020<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span>  len:4  cap:4  ptr:0xc0000b2020<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span>  len:5  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">]</span>  len:6  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span>  len:7  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">]</span>  len:8  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span>  len:9  cap:16  ptr:0xc0000b8000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">]</span>  len:10  cap:16  ptr:0xc0000b8000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> citySlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token comment">// 追加一个元素</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> <span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token comment">// 追加多个元素</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"广州"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">)</span><span class="token comment">// 追加切片</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"成都"</span><span class="token punctuation">,</span> <span class="token string">"重庆"</span><span class="token punctuation">}</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> a<span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">)</span> <span class="token comment">//[北京 上海 广州 深圳 成都 重庆]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap<span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&gt;</span> doublecap <span class="token punctuation">{</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">{</span>newcap <span class="token operator">=</span> doublecap<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// Check 0 &lt; newcap to detect overflow</span><span class="token comment">// and prevent an infinite loop.</span><span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">{</span>newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token comment">// Set newcap to the requested cap when</span><span class="token comment">// the newcap calculation overflowed.</span><span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p><strong>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</strong></p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>b <span class="token operator">:=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</strong></p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">copy<span class="token punctuation">(</span>destSlice, srcSlice <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// copy()复制切片</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">)</span>     <span class="token comment">//使用copy()函数将切片a中的元素复制到切片c</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 从切片中删除元素</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">}</span><span class="token comment">// 要删除索引为2的元素</span>a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[30 31 33 34 35 36 37]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——文件操作</title>
      <link href="/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-wen-jian-cao-zuo/"/>
      <url>/hypo-Z.github.io/2021/11/24/go-yu-yan-ji-chu-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——文件操作"><a href="#Go语言基础——文件操作" class="headerlink" title="Go语言基础——文件操作"></a>Go语言基础——文件操作</h1><h1 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h1><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 关闭文件</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Read方法定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>File<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 使用Read方法读取数据</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"读取了%d字节数据\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h3><p>使用for循环读取文件中的所有数据。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 循环读取文件</span><span class="token keyword">var</span> content <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>content <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h2><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"fmt"</span><span class="token string">"io"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token comment">// bufio按行读取示例</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>line<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">//注意是字符</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h2><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"io/ioutil"</span><span class="token punctuation">)</span><span class="token comment">// ioutil.ReadFile读取整个文件</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h1><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">OpenFile</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> flag <span class="token builtin">int</span><span class="token punctuation">,</span> perm FileMode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>File<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中：</p><p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h2 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>str <span class="token operator">:=</span> <span class="token string">"hello 沙河"</span>file<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">//写入字节切片数据</span>file<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"hello 小王子"</span><span class="token punctuation">)</span> <span class="token comment">//直接写入字符串数据</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>writer <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>writer<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"hello沙河\n"</span><span class="token punctuation">)</span> <span class="token comment">//将数据先写入缓存</span><span class="token punctuation">}</span>writer<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//将缓存中的内容写入文件</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>str <span class="token operator">:=</span> <span class="token string">"hello 沙河"</span>err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h2><p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// CopyFile 拷贝文件函数</span><span class="token keyword">func</span> <span class="token function">CopyFile</span><span class="token punctuation">(</span>dstName<span class="token punctuation">,</span> srcName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 以读方式打开源文件</span>src<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>srcName<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open %s failed, err:%v.\n"</span><span class="token punctuation">,</span> srcName<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> src<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 以写|创建的方式打开目标文件</span>dst<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span>dstName<span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_WRONLY<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open %s failed, err:%v.\n"</span><span class="token punctuation">,</span> dstName<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> dst<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">)</span> <span class="token comment">//调用io.Copy()拷贝内容</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">CopyFile</span><span class="token punctuation">(</span><span class="token string">"dst.txt"</span><span class="token punctuation">,</span> <span class="token string">"src.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"copy file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"copy done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h2><p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"flag"</span><span class="token string">"fmt"</span><span class="token string">"io"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token comment">// cat命令实现</span><span class="token keyword">func</span> <span class="token function">cat</span><span class="token punctuation">(</span>r <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span>buf<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">//注意是字符</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token comment">// 退出之前将已读到的内容输出</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 解析命令行参数</span><span class="token keyword">if</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// 如果没有参数默认从标准输入读取内容</span><span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 依次读取每个指定文件的内容并打印到终端</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"reading from %s failed, err:%v\n"</span><span class="token punctuation">,</span> flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> Golang </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天必逛且可以提升技术能力的网址</title>
      <link href="/hypo-Z.github.io/2021/11/23/12-mei-tian-bi-guang-qie-ke-yi-ti-sheng-ji-zhu-neng-li-de-wang-zhi/"/>
      <url>/hypo-Z.github.io/2021/11/23/12-mei-tian-bi-guang-qie-ke-yi-ti-sheng-ji-zhu-neng-li-de-wang-zhi/</url>
      
        <content type="html"><![CDATA[<p>1.<a href="https://www.ruanyifeng.com/blog/">阮一峰的网络日志</a> 一个技术大佬创建的博客，里面有他每周周刊，可最新的技术和推荐文章</p><p>2.<a href="https://www.liwenzhou.com/">李文周的博客</a> 刚入go语言就会搜的博主，里面有他整理的有关go语言的系列教程，跟着学不迷路</p><p>3.<a href="https://github.com/avelino/awesome-go">awsome-go</a> github上星标最多的项目，上面有最全的go项目列表，站在巨人们的肩膀上，学习项目经验</p><p>4.<a href="https://roadmap.sh/roadmaps">开发者路线图</a> 可以了解一想要发展的学习路线，为你的开发前程指明道路<br>以下是golang的学习路线图:<br><img src="https://roadmap.sh/roadmaps/golang.png" alt="golang的学习路线图" title="golang"><br>5.<a href="https://news.ycombinator.com/news">Hacker News</a> 一个国外IT技术文章发布平台，可了解一些技术知识</p><p>6.<a href="https://gobyexample.com/">GoByExample</a> 一个通过go示例学习的网站</p><p>7.<a href="https://zh-style-guide.readthedocs.io/zh_CN/latest/index.html">中文技术文档写作风格指南</a> 一个指导如何书写中文文档的技术网站，为标准化的写作风格培养习惯</p><p>8.<a href="https://www.runoob.com/">菜鸟教程</a> 一个强烈推荐的软件开发初学者教学网站，网站全免费并且教学专业，通俗易懂，技术栈全覆盖</p><p>9.<a href="https://leetcode-cn.com/">Leetcode</a> 一个学软件编程必须要来的网站，上面可以看到许多大厂的面试题并且可以一边学习一边刷题，可以学习数据结构和算法，从基础开始打牢，经常逛逛去大厂机会大大增加</p><p>10.<a href="https://www.digitalocean.com/community">digitalocean</a> 一个技术开发论坛，上面有许多语言教程，非常专业</p><p>11.<a href="https://www.jianshu.com/techareas/backend">简书</a> 一个小型的技术博客发布平台</p><p>12.<a href="https://juejin.cn/">稀土掘金</a> 一个和简书相似的发布平台，比简书稍大</p><p>13.<a href="https://segmentfault.com/">segmentfault</a> 一个开发者社区</p><p>14.<a href="https://www.cnblogs.com/">博客园</a> 属于中国早期的技术博客平台，技术博客主的资历也最老，上面有许多经验资深的博客发布的文章</p><p>15.<a href="https://www.yuque.com/">语雀</a> 同样是博客发布平台</p><p>16.<a href="https://free-for.dev/#/?id=free-fordev">free-for.dev</a> 一个开发者免费的项目支持，前期可在上面寻找项目支持</p><p>17.<a href="https://www.sina.com.cn/">新浪网</a> 了解新闻、资讯、科技等动向</p><p>18.<a href="https://www.yii3.cn/">易三文档</a> 一个有几个使用的开发使用便捷手册</p><p>19.<a href="http://www.cyc2018.xyz/">CS-Notes</a> 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值得收藏的网站</title>
      <link href="/hypo-Z.github.io/2021/11/23/11-zhi-de-shou-cang-de-wang-zhan/"/>
      <url>/hypo-Z.github.io/2021/11/23/11-zhi-de-shou-cang-de-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="值得收藏的网站（持续更新）"><a href="#值得收藏的网站（持续更新）" class="headerlink" title="值得收藏的网站（持续更新）"></a>值得收藏的网站（持续更新）</h1><p>###个人推荐指数</p><ol><li><p>**** <a href="https://mixkit.co/">Mixkit 是一个免费图库，包含很棒的视频剪辑、音乐曲目、音效和视频模板。</a></p></li><li><p>*** <a href="https://pic.netbian.com/">彼岸图网是一个4K图纸下载网站，每天能下载一张免费4K壁纸</a></p></li><li><p>*** <a href="https://www.lofi.cafe/">lofi.cafe是一个很棒国外电台网站，能在工作学习之余听听音乐，轻音乐为主</a></p></li><li><p>***<a href="https://sample-videos.com/index.php#sample-mp4-video">simple.video一个免费示例视频网站，各种格式都有</a></p></li><li><p>** <a href="http://oskarstalberg.com/game/house/index.html">一个沙盒解压小游戏</a></p></li><li><p>** <a href="https://fuun.fun/">fun.site一个趣味网站大集合的网址</a></p></li><li><p>** <a href="https://www.flickr.com/photos/biodivlibrary/">一个可以观看动物插图的网站</a></p></li><li><p>** <a href="https://bruno-simon.com/">一个有趣的3D模型的网站</a></p></li><li><p>*** <a href="https://www.nocsdegree.com/">一个收集其他职业的人自学成为软件工程师采访的网站，学习其他人的经验</a></p></li></ol><p>10.* <a href="https://gifcities.org/">GifCities 是互联网档案馆的一个特殊项目，旨在庆祝网络保存 20 周年。Internet Archive 是一个非营利性数字图书馆，其中包含数百万本免费书籍、电影、软件、音乐、网站等。</a></p><p>11.***  <a href="https://ptable.com/#%E6%80%A7%E8%B4%A8">一个化学周期表的互动网站，有助理解化学元素</a></p><p>12.*** <a href="https://typlog.com/podlist/">收集高质量的中文播客的网站</a></p><p>13.*** <a href="https://www.indiehackers.com/">一个很棒的IT交流网站，上面有各种技术人员在上面发表文章</a></p><p>14.* <a href="https://blog.usepastel.com/post/33-beautiful-free-icon-sets">33 个具有漂亮免费图标集的网站</a></p><p>15.** <a href="https://www.veer.com/?utm_source=biantuwang&amp;chid=600">veer.com是一个提供免费插图的网站</a></p><p>16.* <a href="https://colorfu.art/editor">一个可以便捷制作大头报图的网站</a></p><p>17.** <a href="https://vididoo.vercel.app/">一个在线快捷处理音视频的网站</a></p><p>18.*** <a href="https://landgreen.github.io/physics/index.html">一个在线高中物理要点讲解，配有插图和动画。</a></p><p>19.*** <a href="http://www.progressfocused.com/">一个大学心理学教授的博客，可以学习有用的心理学小知识</a></p><p>20.***** <a href="https://www.pinterest.com/">pinterest一个国外免费的高质量图片网站，许多图片都可以直接当壁纸，但需要翻墙</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成功所需的 5 种文案写作技巧</title>
      <link href="/hypo-Z.github.io/2021/11/23/10-cheng-gong-suo-xu-de-5-chong-wen-an-xie-zuo-ji-qiao/"/>
      <url>/hypo-Z.github.io/2021/11/23/10-cheng-gong-suo-xu-de-5-chong-wen-an-xie-zuo-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="成功所需的-5-种文案写作技巧"><a href="#成功所需的-5-种文案写作技巧" class="headerlink" title="成功所需的 5 种文案写作技巧"></a>成功所需的 5 种文案写作技巧</h1><h2 id="文案撰稿人需要什么技能？"><a href="#文案撰稿人需要什么技能？" class="headerlink" title="文案撰稿人需要什么技能？"></a>文案撰稿人需要什么技能？</h2><p><a href="https://matgillard.com/?source=post_page-----a7be60065eb4-----------------------------------"><img src="https://miro.medium.com/fit/c/96/96/1*VP5ZfM9aHJL7d7x3_ITVTQ.jpeg" alt="马特吉拉德"></a></p><p><a href="https://matgillard.com/?source=post_page-----a7be60065eb4-----------------------------------">马特吉拉德</a><a href="https://medium.com/m/signin?actionUrl=https://medium.com/_/subscribe/user/9ef1cfb5557/a7be60065eb4&amp;operation=register&amp;redirect=https://goodcopywriting.com/5-copywriting-skills-you-need-to-succeed-a7be60065eb4&amp;user=Mat+Gillard&amp;userId=9ef1cfb5557&amp;source=post_page-9ef1cfb5557----a7be60065eb4---------------------follow_byline--------------">跟随</a></p><p><a href="https://goodcopywriting.com/5-copywriting-skills-you-need-to-succeed-a7be60065eb4?source=post_page-----a7be60065eb4-----------------------------------">11 月 23 日</a> · 2分钟阅读</p><p><img src="https://miro.medium.com/max/1400/1*iAg35spPJaEcUtsCcLA9kg.jpeg" alt="img"></p><p>您是否需要任何特殊的资格或技能才能成为一名撰稿人？</p><p>绝对不！</p><p>成为一名成功的撰稿人不需要正式的资格。要成为一名出色的文案撰稿人，您需要具有创造力、独立性以及良好的沟通技巧和知识，或者对销售和营销有个人兴趣。</p><p>尽管如此，以下五项技能将使您更轻松地生成成功和有效的副本。</p><h1 id="英语语言技能"><a href="#英语语言技能" class="headerlink" title="英语语言技能"></a>英语语言技能</h1><p>高水平的英语语言技能是必须的。读者经常寻找使用正确句子结构、单词选择、语法和拼写的副本。</p><p>作为文案，您还应该密切注意标点符号。</p><p>有大量免费网站可以帮助您在需要时提高英语技能。广泛阅读对建立词汇量也很有帮助。</p><h1 id="注重细节"><a href="#注重细节" class="headerlink" title="注重细节"></a>注重细节</h1><p>而且，除了英语语言技能外，您还需要能够发现工作中的错误。</p><p>在发送给客户或上传给读者之前，您的副本应尽可能无错误。</p><p>很多时候，作为一名自由撰稿人，您将成为自己的校对员和文案编辑，因此需要对细节有敏锐的洞察力。</p><h1 id="研究能力"><a href="#研究能力" class="headerlink" title="研究能力"></a>研究能力</h1><p>知道如何对您想写的主题进行彻底的研究、调查和批判性分析。</p><p>当然，互联网和现代技术通过使其更快、更容易来简化流程。</p><p>当您想了解您的客户和目标受众时，出色的研究技能也适用。</p><p>如果您知道如何以及在哪里找到它，那么您可以在互联网和书籍上找到的内容是无限的。</p><h1 id="大词汇"><a href="#大词汇" class="headerlink" title="大词汇"></a>大词汇</h1><p>广泛的词汇是有帮助的。重要的是在你的文案中使用各种各样的词，而不是相同的陈词滥调。</p><p>但在某些情况下，您可能必须坚持使用常见的和经过测试的词，尤其是在想要获得强有力的标题时。</p><p>不要重复相同的词，尤其是在同一段落中。</p><p>作为初学者，同义词库是开始寻找替代词的好地方。</p><h1 id="能够看到不同的观点"><a href="#能够看到不同的观点" class="headerlink" title="能够看到不同的观点"></a>能够看到不同的观点</h1><p>作为一名文案撰稿人，沉浸在别人的故事或经历中，发挥两全其美的作用。</p><p>你的意见和他们的意见。</p><p>您必须能够仔细聆听并了解他人的观点。</p><p>当您将自己置于读者和客户的角度时，它会让您更有同理心，并尊重地分享不同的观点。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些开发问题快速解决方案</title>
      <link href="/hypo-Z.github.io/2021/11/23/9-yi-xie-kai-fa-wen-ti-kuai-su-jie-jue-fang-an-lian-jie-chi-xu-geng-xin-zhong/"/>
      <url>/hypo-Z.github.io/2021/11/23/9-yi-xie-kai-fa-wen-ti-kuai-su-jie-jue-fang-an-lian-jie-chi-xu-geng-xin-zhong/</url>
      
        <content type="html"><![CDATA[<h4 id="1-怎样写Markdown文件？"><a href="#1-怎样写Markdown文件？" class="headerlink" title="1.怎样写Markdown文件？"></a>1.怎样写Markdown文件？</h4><p><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown语法图文全面教程(10分钟学会)</a></p><h4 id="2-常用的git命令"><a href="#2-常用的git命令" class="headerlink" title="2.常用的git命令"></a>2.常用的git命令</h4><p><a href="https://blog.csdn.net/halaoda/article/details/78661334?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764899316780357255501%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764899316780357255501&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-78661334.pc_search_all_es&amp;utm_term=%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">Git 常用命令大全</a></p><h4 id="3-Linux常用命令"><a href="#3-Linux常用命令" class="headerlink" title="3.Linux常用命令"></a>3.Linux常用命令</h4><p><a href="https://blog.csdn.net/m0_47890251/article/details/106747543?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764919116780271972292%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764919116780271972292&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-106747543.pc_search_all_es&amp;utm_term=linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">Linux常用命令大全（非常详细！）</a></p><h4 id="4-SSH简介及两种远程登录的方法"><a href="#4-SSH简介及两种远程登录的方法" class="headerlink" title="4.SSH简介及两种远程登录的方法"></a>4.SSH简介及两种远程登录的方法</h4><p><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764956316780269858066%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764956316780269858066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82810342.pc_search_all_es&amp;utm_term=ssh&amp;spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法</a></p><h4 id="5-gpg使用方法"><a href="#5-gpg使用方法" class="headerlink" title="5.gpg使用方法"></a>5.gpg使用方法</h4><p><a href="https://blog.csdn.net/arv002/article/details/114322941?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764968516780271533854%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764968516780271533854&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-114322941.pc_search_all_es&amp;utm_term=gpg&amp;spm=1018.2226.3001.4187">gpg使用方法</a></p><h4 id="6-docker常用命令总结"><a href="#6-docker常用命令总结" class="headerlink" title="6.docker常用命令总结"></a>6.docker常用命令总结</h4><p><a href="https://blog.csdn.net/u013378306/article/details/86668313?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86668313.nonecase&amp;spm=1018.2226.3001.4187">docker常用命令总结</a></p><h4 id="7-官方docker简介和构建docker镜像"><a href="#7-官方docker简介和构建docker镜像" class="headerlink" title="7.官方docker简介和构建docker镜像"></a>7.官方docker简介和构建docker镜像</h4><p><a href="docker%E7%AE%80%E4%BB%8B%E5%92%8C%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F">docker简介和构建docker镜像</a></p><h4 id="8-5-个可用于改进开发过程的-Git-工作流程和分支策略"><a href="#8-5-个可用于改进开发过程的-Git-工作流程和分支策略" class="headerlink" title="8. 5 个可用于改进开发过程的 Git 工作流程和分支策略"></a>8. 5 个可用于改进开发过程的 Git 工作流程和分支策略</h4><p><a href="https://zepel.io/blog/5-git-workflows-to-improve-development/">5 个可用于改进开发过程的 Git 工作流程和分支策略</a></p><h4 id="9-理解Docker的多阶段镜像构建"><a href="#9-理解Docker的多阶段镜像构建" class="headerlink" title="9.理解Docker的多阶段镜像构建"></a>9.理解Docker的多阶段镜像构建</h4><p><a href="https://juejin.cn/post/6844903510874521608">理解Docker的多阶段镜像构建</a></p><h4 id="10-理解-gitignore文件和Dockerfile书写参考"><a href="#10-理解-gitignore文件和Dockerfile书写参考" class="headerlink" title="10.理解.gitignore文件和Dockerfile书写参考"></a>10.理解.gitignore文件和Dockerfile书写参考</h4><p><a href="https://git-scm.com/docs/gitignore">.gitignore理解</a></p><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile参考</a></p><h4 id="11-Docker-时区调整方案"><a href="#11-Docker-时区调整方案" class="headerlink" title="11.Docker 时区调整方案"></a>11.Docker 时区调整方案</h4><p><a href="https://cloud.tencent.com/developer/article/1626811">Docker 时区调整方案</a></p><h4 id="12-什么是HASH？"><a href="#12-什么是HASH？" class="headerlink" title="12.什么是HASH？"></a>12.什么是HASH？</h4><p><a href="https://blog.csdn.net/asdzheng/article/details/70226007">Hash算法总结</a></p><h4 id="13-curl的用法指南"><a href="#13-curl的用法指南" class="headerlink" title="13.curl的用法指南"></a>13.curl的用法指南</h4><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl的用法指南</a></p><p>持续更新…</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu开发环境快速安装教程</title>
      <link href="/hypo-Z.github.io/2021/11/23/8-ubuntu-kai-fa-huan-jing-kuai-su-an-zhuang-jiao-cheng/"/>
      <url>/hypo-Z.github.io/2021/11/23/8-ubuntu-kai-fa-huan-jing-kuai-su-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu开发环境快速安装教程："><a href="#Ubuntu开发环境快速安装教程：" class="headerlink" title="Ubuntu开发环境快速安装教程："></a>Ubuntu开发环境快速安装教程：</h1><h3 id="ubuntu安装go："><a href="#ubuntu安装go：" class="headerlink" title="ubuntu安装go："></a>ubuntu安装go：</h3><p>1、下载二进制包：go1.4.linux-amd64.tar.gz。</p><p>2、将下载的二进制包解压至 /usr/local目录。</p><pre class="line-numbers language-none"><code class="language-none">tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、将 /usr/local/go/bin 目录添加至PATH环境变量：</p><pre class="line-numbers language-none"><code class="language-none">export PATH=$PATH:/usr/local/go/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装docker："><a href="#ubuntu安装docker：" class="headerlink" title="ubuntu安装docker："></a>ubuntu安装docker：</h3><p>在终端中输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有错误则成功了。</p><p>二、安装需要的包</p><p>在终端输入命令</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install apt-transport-https ca-certificates software-properties-common curl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有错误则成功。<br>三、添加 GPG 密钥，并添加 Docker-ce 软件源</p><p>官方的软件源（不推荐，很慢）：</p><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https://download.docker.com/linux/ubuntu/gpg|sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中国科技大学的 Docker-ce 源（其他源类似）：</p><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \$(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="注意：添加错了可以用以下命令删除"><a href="#注意：添加错了可以用以下命令删除" class="headerlink" title="注意：添加错了可以用以下命令删除"></a>注意：添加错了可以用以下命令删除</h5><h5 id="查询keyid-下图"><a href="#查询keyid-下图" class="headerlink" title="查询keyid,下图"></a>查询keyid,下图</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-key list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="keyid-就是90那一串"><a href="#keyid-就是90那一串" class="headerlink" title="keyid 就是90那一串"></a>keyid 就是90那一串</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-key del &lt;keyid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="加参数-r可以移除"><a href="#加参数-r可以移除" class="headerlink" title="加参数-r可以移除"></a>加参数-r可以移除</h5><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository -r "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新软件包缓存</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>四、安装 Docker-ce</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>五、测试运行</p><pre class="line-numbers language-none"><code class="language-none">sudo docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>六、添加当前用户到 docker 用户组，可以不用 sudo 运行 docker</p><p>将当前用户添加到 docker 组</p><pre class="line-numbers language-none"><code class="language-none">sudo gpasswd -a ${USER} docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新登录或者用以下命令切换到docker组</p><pre class="line-numbers language-none"><code class="language-none">newgrp - docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启docker服务</p><pre class="line-numbers language-none"><code class="language-none">sudo service docker restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不加sudo直接执行docker命令检查效果</p><pre class="line-numbers language-none"><code class="language-none">docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装git："><a href="#ubuntu安装git：" class="headerlink" title="ubuntu安装git："></a>ubuntu安装git：</h3><h5 id="Linux-平台上安装"><a href="#Linux-平台上安装" class="headerlink" title="Linux 平台上安装"></a>Linux 平台上安装</h5><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p><p>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p><p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p><h5 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h5><p>Debian/Ubuntu Git 安装命令为：</p><pre class="line-numbers language-none"><code class="language-none">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \  libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ubuntu安装goland："><a href="#ubuntu安装goland：" class="headerlink" title="ubuntu安装goland："></a>ubuntu安装goland：</h3><h5 id="goland安装"><a href="#goland安装" class="headerlink" title="goland安装"></a>goland安装</h5><ol><li>下载goland<br><a href="https://www.jetbrains.com/go/download/#section=linux">Goland下载链接</a></li><li>cd到安装包目录，移动并解压</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tar</span> -zxvf goland-2020.3.4.tar.gz -C /usr/local/ <span class="token comment">#包的名字自行修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>启动Goland</li></ol><p><img src="https://img-blog.csdnimg.cn/20210320104439418.png" alt="在这里插入图片描述"></p><h3 id="ubuntu安装google-chorme："><a href="#ubuntu安装google-chorme：" class="headerlink" title="ubuntu安装google chorme："></a>ubuntu安装google chorme：</h3><p>下载Chrome</p><pre class="line-numbers language-none"><code class="language-none">$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装</p><pre class="line-numbers language-none"><code class="language-none">$ sudo dpkg -i google-chrome-stable_current_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错</p><pre class="line-numbers language-none"><code class="language-none">$ sudo dpkg -i google-chrome-stable_current_amd64.deb(Reading database ... 155736 files and directories currently installed.)Preparing to unpack google-chrome-stable_current_amd64.deb ...Unpacking google-chrome-stable (88.0.4324.96-1) ...dpkg: dependency problems prevent configuration of google-chrome-stable: google-chrome-stable depends on fonts-liberation; however:  Package fonts-liberation is not installed. google-chrome-stable depends on libatk-bridge2.0-0 (&gt;= 2.5.3); however:  Package libatk-bridge2.0-0 is not installed. google-chrome-stable depends on libatk1.0-0 (&gt;= 2.2.0); however:  Package libatk1.0-0 is not installed. google-chrome-stable depends on libatspi2.0-0 (&gt;= 2.9.90); however:  Package libatspi2.0-0 is not installed. google-chrome-stable depends on libcairo2 (&gt;= 1.6.0); however:  Package libcairo2 is not installed. google-chrome-stable depends on libcups2 (&gt;= 1.4.0); however:  Package libcups2 is not installed. google-chrome-stable depends on libgbm1 (&gt;= 8.1~0); however:  Package libgbm1 is not installed. google-chrome-stable depends on libgdk-pixbuf2.0-0 (&gt;= 2.22.0); however:  Package libgdk-pixbuf2.0-0 is not installed. google-chrome-stable depends on libgtk-3-0 (&gt;= 3.9.10); however:  Package libgtk-3-0 is not installed. google-chrome-stable depends on libnspr4 (&gt;= 2:4.9-2~); however:  Package libnspr4 is not installed. google-chrome-stable depends on libnss3 (&gt;= 2:3.22); however:  Package libnss3 is not installed. google-chrome-stable depends on libpango-1.0-0 (&gt;= 1.14.0); however:  Package libpango-1.0-0 is not installed. google-chrome-stable depends on libxkbcommon0 (&gt;= 0.4.1); however:  Package libxkbcommon0 is not installed. google-chrome-stable depends on xdg-utils (&gt;= 1.0.2); however:  Package xdg-utils is not installed.dpkg: error processing package google-chrome-stable (--install): dependency problems - leaving unconfiguredProcessing triggers for mime-support (3.64ubuntu1) ...Processing triggers for man-db (2.9.1-1) ...Errors were encountered while processing: google-chrome-stable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错原因：缺少依赖软件包</p><pre class="line-numbers language-none"><code class="language-none">dpkg: error processing package google-chrome-stable (--install): dependency problems - leaving unconfigured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解决办法：修复依赖关系</p><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get install -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果系统中有某个软件包不满足依赖条件,这个命令就会自动修复,将要安装那个软件包依赖的软件包。</p><p>查看Chrome版本信息</p><pre class="line-numbers language-none"><code class="language-none">$ google-chrome --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装teams："><a href="#ubuntu安装teams：" class="headerlink" title="ubuntu安装teams："></a>ubuntu安装teams：</h3><p>1、去官网下载二进制包teams.tar.gz。</p><p>2、将下载的二进制包解压至 /usr/local目录。</p><pre class="line-numbers language-none"><code class="language-none">tar -C /usr/local -xzf teams.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Ubuntu安装typora"><a href="#Ubuntu安装typora" class="headerlink" title="Ubuntu安装typora:"></a>Ubuntu安装typora:</h3><p>在终端中输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -# add Typora's repositorysudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get update# install typorasudo apt-get install typora<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ubuntu安装cloudmusic："><a href="#ubuntu安装cloudmusic：" class="headerlink" title="ubuntu安装cloudmusic："></a>ubuntu安装cloudmusic：</h3><p>先到网站下载安装包，网址：<a href="https://music.163.com/#/download">https://music.163.com/#/download</a> , 然后下载客户端，点击下载全部客户端，选择Linux版，选择Ubuntu18.04，其实我的20.04 版的没找到，不过这个用起来还不错。至于是32还是64，自己看吧。<br>然后将安装包下载到：~/下载 目录下，然后在这个目录下面打开终端。<br>在终端里面输入：sudo dpkg -i netease-cloud-music_1.2.1_amd64_ubuntu_20190428.deb 就行了</p><h3 id="ubuntu安装vim："><a href="#ubuntu安装vim：" class="headerlink" title="ubuntu安装vim："></a>ubuntu安装vim：</h3><p>自带的vi不好用，所以自己重新下了一下</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后进入/etc/vim目录下配置文件，使用会舒服一点</p><pre class="line-numbers language-none"><code class="language-none">sudo vim vimrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在末尾添加代码</p><pre><code>set number   set history=1000   set autoindentset smartindent set tabstop=4 set shiftwidth=4 set showmatch</code></pre><h3 id="ubuntu-安装PostMan"><a href="#ubuntu-安装PostMan" class="headerlink" title="ubuntu 安装PostMan:"></a>ubuntu 安装PostMan:</h3><pre class="line-numbers language-test" data-language="test"><code class="language-test">sudo snap install postman<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu-安装nodejs和npm"><a href="#ubuntu-安装nodejs和npm" class="headerlink" title="ubuntu 安装nodejs和npm:"></a>ubuntu 安装nodejs和npm:</h3><p>快速安装：</p><pre class="line-numbers language-none"><code class="language-none">sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* ~/.npmsudo rm -rf /usr/local/lib/node*sudo rm -rf /usr/local/bin/node*sudo rm -rf /usr/local/include/node*sudo apt-get purge nodejs npmsudo apt autoremovesudo apt-get install nodejs npmzhb@zhb-pc:~$ npm -v6.14.4zhb@zhb-pc:~$ node -vv10.19.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：以上只能安装老版本的nodejs和npm,新版本可在官网下载，但是可能出现问题。</p><p>一.下载最新版本的nodejs包（最新版本的nodejs包里默认含有npm）<br>可以去nodejs官网去查看最新版本的nodejs<br>网址如下：<a href="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/</a><br>目前最新版本为：v17.1.0</p><pre class="line-numbers language-none"><code class="language-none">wget https://nodejs.org/dist/v17.1.0/node-v17.1.0-linux-x64.tar.xz    tar xf  node-v17.1.0-linux-x64.tar.xz       // 解压cd node-v17.1.0-linux-x64/                  // 进入解压目录 ./bin/node -v                               // 执行node命令 查看版本// bin目录下有执行文件npm和node 做软链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载到你当前的目录,假如是：/home/root/</p><p>第二步 创建软连接 可以在任意路径下执行npm node<br>注意：在创建软连接的时候要写 绝对路径,软连接到/usr/local/bin/</p><pre class="line-numbers language-none"><code class="language-none">ln -s  /home/root/node-v17.1.0-linux-x64/bin/node  /usr/local/bin/ln -s /home/root/node-v17.1.0-linux-x64/bin/npm  /usr/local/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>// 注意要写文件的绝对路径</p><p>如果你在创建软连的时候，出现npm已经存在,node 已经存在<br>解决方案：<br>删除 /usr/local/bin/目录下的node，npm</p><p>rt@ubuntu:<del>$ sudo rm -rf /usr/local/bin/node<br>rt@ubuntu:</del>$ sudo rm -rf /usr/local/bin/npm</p><p>之后再创建软连接，完成。</p><pre class="line-numbers language-none"><code class="language-none">rbt@ubuntu:~$ node -vv17.1.0rt@ubuntu:~$ npm -v8.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样node和npm就同时安装成功了！</p><h3 id="ubuntu安装python3："><a href="#ubuntu安装python3：" class="headerlink" title="ubuntu安装python3："></a>ubuntu安装python3：</h3><p>ubuntu本身是有Python2.7版本的，但是不同版本的ubuntu中的Python3的版本是不同的，我现在用的是14版本就是python3.4，我想把它升级为3.6版本。当然，如果需要，你可以改为任意版本。</p><ol><li>安装python3.6(非必需)<br>在终端中输入下面的命令（不要怀疑，每行都是一个命令）</li></ol><pre class="line-numbers language-none"><code class="language-none">wget http://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz  tar -xvzf Python-3.6.4.tgz  cd Python-3.6.4  ./configure --with-ssl  make  sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些命令会使你的ubuntu下载python3.6.4，并替换你现在的python3版本。</p><ol start="2"><li>安装python运行环境<br>输入sudo passwd 输入root相关密码，输入su，进入超级管理员（如果你没设置过，需要设置root用户密码），也许你在安装时还需要升级你的apt-get，命令行下输入apt-get update</li></ol><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install pythonsudo apt-get install python-dev(编译外部模块文件使用的)sudo apt-get install python-pipsudo apt-get install libxml*sudo apt-get install net-toolssudo apt-get install lsof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python3的话安装pip，命令为sudo apt-get install python3-pip<br>执行之后，输入python3来确定你是否安装成功，如下图所示显示python3.6.4即安装成功：</p><p>3.更新pip版本</p><pre class="line-numbers language-none"><code class="language-none">sudo pip install --upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.安装SSH</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install openssh-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.安装 Nginx</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6.安装 uwsgi</p><pre class="line-numbers language-none"><code class="language-none">sudo pip install uwsgi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署django项目前输入以下命令开启8000端口</p><pre class="line-numbers language-none"><code class="language-none">uwsgi --http :8000  --chdir 项目路径 -w  项目名称.wsgi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解除端口被占用的命令：</p><pre class="line-numbers language-none"><code class="language-none">sudo fuser -k 8000/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！"><a href="#至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！" class="headerlink" title="至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！"></a>至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！</h5>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行的意义</title>
      <link href="/hypo-Z.github.io/2021/11/22/7-lu-xing-de-yi-yi/"/>
      <url>/hypo-Z.github.io/2021/11/22/7-lu-xing-de-yi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="旅行的意义"><a href="#旅行的意义" class="headerlink" title="旅行的意义"></a>旅行的意义</h1><ul><li>今天看到一句话:”年轻时,我认为旅行是人生重要的事情,但是</li></ul><p>现在,我意识到旅行不是如此。它没有那么让人兴奋,也算不上成就,</p><p>跟其它的消费行为没有太大区别。旅行中,我们真正感兴趣的东西都是</p><p>那些留在原地,努力建设的人们建造出来的。</p><p>现在想想去年我做了一年的技术支持,也去过了祖国许多的地方,对于我来说,第一份</p><p>工作它虽然谈不上好,但对于我自己的成长和视界上的提升是巨大的,从</p><p>小我就希望到外界的世界去看看.大山的孩子的心思总是单纯的。一年的时间,</p><p>一边工作的同时也欣赏了各地的风景,但是我遗憾是给我去探寻留在原地</p><p>的人们建造出来的美景、美食和美丽的心灵的时间太短。每经过一个</p><p>地方都是匆匆而过,虽然时间短暂,但留在我心中的种子已经种子,我相信这颗种子不会死去,</p><p>随着时间的成熟和我个人的成长,一定会再次绽放那个短暂回忆美丽的</p><p>花朵,因为人是一直成长的,但是那些地方和那些人一定</p><p>会留住原地继续建造，等待每个匆匆过往的旅客。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最重要的事,就是做你认为正确的事</title>
      <link href="/hypo-Z.github.io/2021/11/21/6-zui-chong-yao-de-shi-jiu-shi-zuo-ni-ren-wei-zheng-que-de-shi/"/>
      <url>/hypo-Z.github.io/2021/11/21/6-zui-chong-yao-de-shi-jiu-shi-zuo-ni-ren-wei-zheng-que-de-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="最重要的事-就是做你认为正确的事"><a href="#最重要的事-就是做你认为正确的事" class="headerlink" title="最重要的事,就是做你认为正确的事"></a>最重要的事,就是做你认为正确的事</h1><ul><li>在小时候母亲都外出务工了,由爷爷奶奶扶养到初中,他们就<br>离世了,之后就是我和姐姐在家,我爸为了能照映到我们都在离<br>家较近的地方打工,妈妈常年在外务工,从小到大父母由于文化<br>程度都不高,在能给予我支持的就是尽力供我的教育,每次他们能与<br>我沟通的就是希望我好好读书,以后能找到一份好的工作,而现在,<br>大学读完了,也有了工作.我不知道是不是就达到了父母的期望。以前的<br>我很迷茫,也幸好我老家是个小地方,没有太多选择,在小学、初中、高中,<br>我尽我的可能都进了能尽量好的班级学习,不出意外的,我考上了大学,<br>而且是个一本,(我以为的)在选考业的时候,依旧迷茫,不知道选什么专业,<br>但是,不知道为什么,我的心中就认为以后的世界一定是互联网的世界,或许<br>是有预感,或许自己爱打游戏,对于我当时的天真和想法其实<br>到现在我也觉得是正确的,因为我想有学习软件开发或许我真的可以搞出个<br>名堂来。在当时,我在选学校时,我记得我的大学的第一志愿都选了”软件工程”,<br>之后是计算机”灬反正就是和软件相关的我都写上了,但是由<br>于贵州有贫困生补助,能写三个提前批的大学名额这个名额是那<br>外省大学为了一些特设学科而给出的名额。但是这些大学的学科都不是<br>我想去的,我就抱着不想去的心态,随便选了三个我自认为得不到的大学,并<br>选择了与软件工程挨了一点边的《电子信息科学与技术》,而我也因为这个阴差<br>阳错的来到了我的母校”天津工业大学”,我很意外,也<br>有一点遗憾,没有能去我心心念念的大学学科。</li><li>读了九年的义务教育、从来没有人告诉我该做什么<br>父母告诉我好好读书,我就好好的考上了大学,<br>但是大学的学科并不是我想学习的学科、也没有人该告诉我应该做什么了,<br>又一次不出意外的,我迷茫了,在大学里充满了诱惑游戏、金钱、娱乐。<br>那时的我就像个孩子,脱离了父母的监管,在大学肆意的放纵。可以<br>想象之后的学习就像还狂奔的野马,踏进泥塘——一踏胡图,在大<br>三的学科有七科学科，我就挂了六科,谈了四年的女友也分了,当时的自己<br>就能用一个字形容:”颓废!加之我跟人借钱,欠了一屁股债。可以这么说:<br>这是我活到现在人生的最低谷。那个时候真的可以体验。 晚上在床上睡<br>不着见到第二天的太阳。经历那段时间,我也没有了其它的顾虑,将学科<br>补考,最后靠着几个难兄难弟的同学抗过了大学结束。而现在我回到了我当时<br>想报考的学科。在互联网做个软件开发,我很开心,因为我在做着我喜欢的<br>事情而我现在的工作都靠我自己学习而得到的,现在,我能理解什么是正确的事情。</li><li>罗翔老师在档节目里曾说:”你最重要是做你觉得正确的事情,<br>最重要的是你听不到内心的抱怨,最重要的是多年以后的你能够看得<br>起现在的你,过好每一天,演好当下的剧本,朝着心中的那个标杆去前进,<br>人要做到!不清高,不娇情,不抱怨,就是在黑夜中看到了微光,<br>你就朝着微光的方向走过去,虽然有的时候你去怀疑你会觉得<br>是不是走错了,但是所有的怀疑都为了确信:那就是如何过看起来好的一生<br>,那你就要去定义了,什么叫做好,这个世界有太多关于好的标准了。<br>good（好）,如果加个s,就变成了 goods (商品),所以一切事情<br>最重要的就是赚钱吗!难道能赚钱的职业就是好职业吗?那这样做<br>一切职业分工就没有意义了。你要去寻找什么叫good,然后你才能去过 good<br>的一生,你才可以避免去随波逐流,你才内心会有一种笃定,你才会拒绝跟别人<br>去攀比,也拒绝被别人攀比。对于不可控的事情,我们保持<br>乐观,对于可控的事情,我们保持谨慎。于是你就仔细去回想,你这一生<br>中所遇到的很多经历,很多重要的时刻,你才恍然大悟,原来你就是个很<br>渺小的人”。</li><li>虽然现在我的人生才走了四分之一的阶段,但是我还要面对我人生的以后的<br>各个重大时刻。所以,我希望以后的我能够坦然的面对,也希望以后的<br>自己,能够看得起现在的自己</li></ul><p>——致自己<br>2021.11.20</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以后的世界将是游戏的世界</title>
      <link href="/hypo-Z.github.io/2021/11/20/5-yi-hou-de-shi-jie-jiang-shi-you-xi-de-shi-jie/"/>
      <url>/hypo-Z.github.io/2021/11/20/5-yi-hou-de-shi-jie-jiang-shi-you-xi-de-shi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="以后的世界将是游戏的世界"><a href="#以后的世界将是游戏的世界" class="headerlink" title="以后的世界将是游戏的世界"></a>以后的世界将是游戏的世界</h1><p>上周同时观看了两部电影,分别是《头号流家》与《失控玩家》两部</p><p>电影都是讲述近未来的游戏世界,《头号玩家》以玩家视角为切入点,</p><p>讲述玩家以VR眼镜和体感服装为媒介,进入一个虚拟世界与众多玩家</p><p>一起游玩,这个世界与现实世界就如同一个平行</p><p>宇宙,玩家可以在这个宇宙里面做任何它想做的事情。而</p><p>《失控玩家》则以游戏NPC为视角,向观众介绍了人工智能与</p><p>游戏世界不同的可能性。又时逢前段时间,元宇宙的概率</p><p>大火,就向人们抛出了可在人工智能,大数据,去服务逐渐</p><p>盛行的时代,在不久的未来,就会出现这种产品。但是,一方面</p><p>上层的服务需要有底层硬件的支持。就现阶段而言,VR眼镜</p><p>与体感套件都很初级,服务器也难以支持这种大型的游戏服务。所以在我看来我对</p><p>以后的游戏市场保持乐观心态,可能在未来5年的时间,我们将看到游戏</p><p>市场的澎渤发展。我会不断观察和验证我的观点。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对新人的一些建议</title>
      <link href="/hypo-Z.github.io/2021/11/19/4-dui-xin-ren-de-yi-xie-jian-yi/"/>
      <url>/hypo-Z.github.io/2021/11/19/4-dui-xin-ren-de-yi-xie-jian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="软件开发人员促销：获得更高水平的建议"><a href="#软件开发人员促销：获得更高水平的建议" class="headerlink" title="软件开发人员促销：获得更高水平的建议"></a>软件开发人员促销：获得更高水平的建议</h1><p>我最近的促销活动进展顺利。当<a href="https://blog.pragmaticengineer.com/things-ive-learned-transitioning-from-engineer-to-engineering-manager/">我从工程师过渡到管理人员时</a>，我有八个人向我报告。两年后，他们都被提升到了一个新的水平，还有一些其他的开发人员，他们后来加入了我的团队。从那以后，我帮助团队以外的人整理了成功的晋升案例，并成为了几个工程师晋升委员会的成员。最近，我也被提升到了更高一级的工程管理。</p><p>升职迟早会成为工程师的敏感话题。加入一家公司时，很少有开发人员会考虑到这一点——这是理所当然的，因为人们都专注于跟上进度。但随着时间的推移，随着越来越多的人在他们身边得到晋升，晋升成为许多人的首要考虑。作为经理，这自然成为我经常思考的话题。</p><p><strong>本文收集了我向团队中的工程师提供的晋升建议</strong>- 其中许多人后来被提升到更高级别。</p><ul><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#do-your-preparation">做好准备</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#set-your-sight-on-the-promotion">将目光投向促销</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#get-help-frequent-feedback">获得帮助和频繁的反馈</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#put-in-the-work">投入工作</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#stay-grounded">脚踏实地</a></li><li>帮助别人</li></ul><h2 id="做好准备"><a href="#做好准备" class="headerlink" title="做好准备"></a>做好准备</h2><p>一旦你决定你对升职有兴趣，就从收集基本信息开始，并评估升职对你的现实程度。</p><h4 id="了解贵公司的晋升流程。"><a href="#了解贵公司的晋升流程。" class="headerlink" title="了解贵公司的晋升流程。"></a>了解贵公司的晋升流程。</h4><p>每家公司都有不同的晋升流程。虽然类似的公司可能有类似的流程，但不要想当然。如果有关于该过程的信息，那就是一个很好的开始。最好的起点是询问您的经理。随着公司的成长和成熟，促销流程发生了变化。我观察到的最常见的促销过程类型是以下三种：</p><ul><li><strong>非正式升职：经理决定谁升职</strong>。几位经理进入一个房间，然后拿出一份晋升人员名单，这是小型初创公司和公司的典型流程。在会议上，管理人员介绍他们团队中的人员，然后由团队决定他们是否准备好晋升。</li><li><strong>半正式的晋升过程，有一个以经理为主的晋升委员会</strong>。随着公司的发展，将所有经理聚集在一起变得困难且耗时。此外，先前过程的偏见开始变得更加明显。领导层将致力于制定一个更具可扩展性和更公平的流程。这通常从写下每个工程级别的基本期望开始，并要求经理提交简短的文档，说明他们团队中的工程师为什么准备晋升。</li><li><strong>正式的晋升流程：晋升套餐和委员会</strong>。谷歌、优步和几家大型科技公司都在效仿这种流程。它需要有明确和广泛定义的工作阶梯，在每个级别都有明确的期望。我们的想法是使促销活动尽可能公正。作为更公平和透明的过程的回报，产生了更多的文件。广泛的自我审查、同行审查和经理审查被写入。由高级工程师和管理人员组成的晋升委员会决定晋升是否通过。</li></ul><p>所有方法都有其优点和缺点。了解您的组织正在关注什么，以便您更好地了解您和您的经理必须如何准备。</p><h4 id="评估自己"><a href="#评估自己" class="headerlink" title="评估自己"></a>评估自己</h4><p>大多数科技公司都采用一种方法，将已经在那里工作的人提升到更高的水平。晋升通常是对您的影响力和技能始终超出对您的期望的认可，并且符合下一个级别的规范。</p><p>那么，与下一个级别相比，您的表现如何？当您在一家公司工作时，回答这个问题要容易得多，在文档中明确定义了能力和级别，您可以参考。定义明确的能力的一些很好的例子包括<a href="https://progression.monzo.com/">Monzo</a>、<a href="https://docs.google.com/spreadsheets/d/12h50IYqd7fsO7tJ0l1OuHYbz5vN2d24a8EIDFhu2AZQ/edit#gid=2035430096">Square</a>或<a href="https://dresscode.renttherunway.com/blog/ladder">Rent The Runway 等</a>。如果您的公司拥有明确定义的能力，请通读您所在级别和下一级别的期望。列出您所展示的技能、您所产生的影响以及它如何与这些期望相匹配。</p><p>如果您的公司没有明确的能力和期望，您仍然需要弄清楚您在当前的期望中表现如何。您还想知道达到下一个级别的预期目标。<strong>根据经验，要考虑晋升，您应该在目前的水平上做得很好。</strong>因此，您可以从获取有关您当前表现的反馈开始，与最适合向您提供反馈的人交谈：您的经理。</p><h4 id="让你的经理站在你这边"><a href="#让你的经理站在你这边" class="headerlink" title="让你的经理站在你这边"></a>让你的经理站在你这边</h4><p>无论您的公司遵循什么流程，如果您的经理不支持升职，那么您获得晋升的机会非常渺茫。所以一定要让你的经理站在你这边。你怎么做到这一点？询问他们促销是如何运作的，他们的促销理念是什么。与当前和下一级别相比，询问他们如何评价您当前的表现。根据您的经理的不同，您可能会决定逐步提出这个问题，但您迟早需要就此进行坦诚的对话。</p><p>这种谈话对我来说总是很尴尬，作为一名工程师，我在职业生涯中很长一段时间都避免这种谈话。回想起来，我希望我没有。原因很简单。</p><p>*<strong>当*您准备好*时，*晋升符合您经理的最佳利益。</strong>管理者的评判标准是他们是否有能力让他们的团队提供更好的产出。他们通过让他们的工程师作为一个团队更有效率来做到这一点。为了让团队更有效率，团队中的工程师需要成长为更高效、更可靠和更资深。外部可见的增长指标之一是促销活动。晋升意味着经理帮助这个人成长——要么通过指导、指导，要么只是让他们摆脱困境。一个团队越来越高级的经理表明他们在培养人才方面做得很好。</p><p>所以我们知道晋升会让经理看起来很好。尽管如此，仍有很多开发人员认为<em>“我的经理永远不会提拔我”。</em>问问自己：这是为什么？一位领导停滞不前的经理开始引起来自上级和团队的不必要的关注。如果人们不断收到平均或差劲的绩效评估，而从不准备升职，那对经理来说也不好看。所以在你问过自己为什么你的经理似乎不想提拔你之后，也问问你的经理。告诉您您可以和应该发展哪些领域符合他们的最大利益。</p><h4 id="在高级酒吧以上的促销活动中要切合实际"><a href="#在高级酒吧以上的促销活动中要切合实际" class="headerlink" title="在高级酒吧以上的促销活动中要切合实际"></a>在高级酒吧以上的促销活动中要切合实际</h4><p>通常，晋升到高级职位主要是基于获得技能、展示这些技能并产生影响。但是，在高级工程师级别之上，还有其他因素在起作用。</p><p>首先，可能有多少人可以晋升到更高级别的预算限制。有些地方需要一个商业案例，说明为什么给定的团队或区域需要领导、员工或首席工程师。如果没有商业案例，您可能无法获得晋升。即使您可能有公平的晋升机会，也是如此。</p><p>其次，在高级工程师级别以上，您可能会发现很难找到足够大且影响力足以保证晋升的项目。例如，您的团队可能正忙于交付小的、增量的功能，这些功能没有什么复杂性，但具有可观的商业价值。几乎可以肯定，仅仅在这里工作出色，您不会被提升到高级级别。在这种情况下，您需要掌控自己的职业并决定如何前进。你是否在等待新的机会到来？您是否调动团队来领导复杂而有影响力的绿地项目的工作？您是否提出了一项具有巨大业务影响的新计划，说服利益相关者启动并最终领导它？没有简单的答案：你必须采取主动，争取支持，</p><p><img src="https://blog.pragmaticengineer.com/content/images/2019/10/levels-1.png" alt="img"></p><p><strong>随着您的职业阶梯上升，进入下一个级别变得越来越难。</strong>这是开发人员阶梯上的类似挑战，就像管理一样。从经理到总监通常同样困难，就像从高级工程师到员工或原则一样。</p><h2 id="将目光投向促销"><a href="#将目光投向促销" class="headerlink" title="将目光投向促销"></a>将目光投向促销</h2><p>一旦您了解晋升流程的运作方式、评估自己并让您的经理站在您这边，就该集中注意力了。</p><h4 id="设定目标以缩小您在下一级别缺乏的领域的差距"><a href="#设定目标以缩小您在下一级别缺乏的领域的差距" class="headerlink" title="设定目标以缩小您在下一级别缺乏的领域的差距"></a>设定目标以缩小您在下一级别缺乏的领域的差距</h4><p>毫无疑问，您需要在多个领域变得更好或展示影响力。这可能涉及软件工程、有影响力的执行、设计复杂问题的解决方案、与他人更好地协作等领域。</p><p>设定可帮助您实现目标的 SMART 目标 - 具体、可衡量、可实现、现实、及时。设定只取决于你自己的目标，而不取决于外部因素，比如被给予机会。例如，如果您确定要改进的领域是在架构上变得更好，那么不要设定构建复杂项目的通用目标。但是您可以设定一个目标，每月至少彻底审查一份提案，在该领域指导至少一名初级工程师 3 个月，或阅读相关书籍并在接下来的 2 个月内向您的团队和组织展示学习成果。如果你被确认领导一个项目，你可以设定一个目标，让两个比你高的人审查你的提案，他们在你的团队之外。</p><h4 id="采取行动并承担责任，就像您已经处于下一个级别一样"><a href="#采取行动并承担责任，就像您已经处于下一个级别一样" class="headerlink" title="采取行动并承担责任，就像您已经处于下一个级别一样"></a>采取行动并承担责任，就像您已经处于下一个级别一样</h4><p>有两种促销情况。一个是非常简单的：毫无疑问，工程师已经在下一个级别执行了很长时间。另一个更具挑战性：这个人表现出很多希望，但有一些地方他们没有达到下一个层次。第二种促销案例是抛硬币类型，结果可能以任何一种方式进行。</p><p>当您为升职而努力时，目标是在下一个级别上始终如一地表现：不要仅将其限制在您的重点领域。如果您的目标是高层，而您团队的项目面临风险，请建立并帮助整个项目取得成功。如果你的经理要求志愿者做一件无聊但重要的家务活，而且没有人加紧努力，请考虑举手。在粉碎这项工作的基础上，自动化它的一部分，让团队中的下一个人更容易完成它。</p><h4 id="记录您的成就和影响"><a href="#记录您的成就和影响" class="headerlink" title="记录您的成就和影响"></a>记录您的成就和影响</h4><p>当您的经理或您整理升职案例的时候到了，第一个问题将是关于您取得的成就，这保证了这次升职。到那个时候，你会忘记你所做的很多伟大的工作。因此，提前开始并开始写下您正在完成的所有工作。</p><p>开始一个<a href="https://blog.pragmaticengineer.com/work-log-template-for-software-engineers/">工作日志文件</a>或类似的东西，你会不断更新。<a href="https://blog.pragmaticengineer.com/work-log-template-for-software-engineers/">这是我创建的 Google Doc 模板</a>。与您的经理分享此信息，以便他们也了解您所做的所有工作。没有人比你更了解你所做的工作。你可能会因为你完成了多少额外的事情而让你的经理大吃一惊。当你得到晋升时，你会让你们的生活更轻松。</p><p>考虑针对下一个职业阶梯级别<a href="https://blog.pragmaticengineer.com/performance-review-template-and-example-for-software-engineers/">进行自我评估</a>，列出您认为证明您已经证明在下一个级别工作的例子。向您的经理寻求反馈，并使用此审查来确定您可以努力缩小的下一个级别的差距。</p><h2 id="获得帮助和频繁的反馈"><a href="#获得帮助和频繁的反馈" class="headerlink" title="获得帮助和频繁的反馈"></a>获得帮助和频繁的反馈</h2><p>争取晋升的过程并不短：可能需要几个月的时间。很容易忘记自己的表现，以及您是否仍然在证明自己处于下一个级别的目标上。</p><h4 id="在公司找个导师，帮你"><a href="#在公司找个导师，帮你" class="headerlink" title="在公司找个导师，帮你"></a>在公司找个导师，帮你</h4><p>虽然您的经理可能会在您的升职工作中站在您这边，但他们能给您的反馈也有限。您可以<a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/">通过获得一位导师（另一位工程师）</a>来加速您的职业发展。</p><p>尝试找到已经处于下一个级别的开发人员。更好的是，如果他们在公司内得到提拔。向他们寻求指导，特别是在成长到一个新的水平上。与他们分享您的评估和目标，并寻求反馈和帮助以帮助您成长到更高的水平。</p><p>在我的公司内，我注意到主动建立此类指导的开发人员看到了多种好处。一方面，他们根据导师的反馈对自己的成长方式变得更具战略性。这些导师通常在公司工作的时间更长，并帮助工程师了解促销活动中一些不太清楚的部分。其次，即使他们没有得到提升，有导师的开发人员也更容易反弹。他们有自己的导师，他们投资于让他们更上一层楼。这使这些开发人员更容易团结一致，继续在他们的游戏中保持出色，并在下一个周期进行推广。</p><h4 id="要求定期、明确的反馈"><a href="#要求定期、明确的反馈" class="headerlink" title="要求定期、明确的反馈"></a>要求定期、明确的反馈</h4><p>设定目标并为之努力是一回事。但是，尤其是当您正在努力实现升职等重要里程碑时，定期获得有关您的工作方式的反馈同样重要。</p><p>注意定期向经理展示您认为自己取得的进展。向他们询问有关您在下一级别的进展情况的反馈。尽早进行对话，了解他们是否支持您在下一个周期获得晋升。即使答案是“还没有”，让他们帮助定义可操作的事情，如果你完成了，你将为下一个级别做好准备。</p><h4 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h4><p><a href="https://newsletter.pragmaticengineer.com/">订阅我的每周通讯</a>，为工程经理和高级工程师提供建议、观察和灵感。</p><h2 id="投入工作"><a href="#投入工作" class="headerlink" title="投入工作"></a>投入工作</h2><p>如果您已向您的经理和导师明确表示您正在为晋升而努力，请投入工作。在提名前的几个月里，加倍努力在更高的水平上表现，完成工作并帮助他人。</p><h4 id="不要疏远你的同龄人"><a href="#不要疏远你的同龄人" class="headerlink" title="不要疏远你的同龄人"></a>不要疏远你的同龄人</h4><p>我有时会看到工程师犯的一个错误是过于专注于<em>他们的</em>晋升，以至于最终损害了团队。到了升职时间，他们往往最终没有升职，因为很明显，他们与优秀的团队合作者背道而驰。越来越多的公司小心翼翼——理所当然！- 不提拔拉低团队的人。</p><p>为了实现您为晋升而设定的目标，让人们避开是一个糟糕的策略。首先，这是非常短期的思考。在晋升时可能会要求您可能走过的同龄人提供反馈。但即使他们不是，这也是不成熟的标志。您获得的资历越高，就越期望您成为一名出色的团队合作者，<em>同时取得</em>可靠的成绩。要达到平衡并不总是那么容易。但是，如果您发现自己以一种让团队中的人感到不安的方式推进自己的目标，请考虑改变您的方法以提高协作性。</p><h4 id="即使你觉得口袋里有东西，也不要退缩"><a href="#即使你觉得口袋里有东西，也不要退缩" class="headerlink" title="即使你觉得口袋里有东西，也不要退缩"></a>即使你觉得口袋里有东西，也不要退缩</h4><p>有一次，开发人员与他们的经理设定了目标，如果他们成功领导并交付 ComplexProjectX，他们将获得晋升。项目进展顺利，人就升职了。此人一听这好消息，一脚踹开，放下了这个项目，没有委托给其他人。随着项目的推出，越来越多的问题浮出水面，没有人采取行动。最终，不得不恢复推出。</p><p>这发生在晋升委员会讨论这位工程师的案子之前。在讨论中，他们一致认为，虽然这个人在很多方面都表现出很高的技能，但他们通过从方向盘上消失的第11个小时来表现出不成熟。没有沟通，也没有很好的解释为什么会发生这种情况。该人在那个周期没有得到提升。</p><h2 id="脚踏实地"><a href="#脚踏实地" class="headerlink" title="脚踏实地"></a>脚踏实地</h2><h4 id="不要相信任何向您承诺“肯定会升职”的人。"><a href="#不要相信任何向您承诺“肯定会升职”的人。" class="headerlink" title="不要相信任何向您承诺“肯定会升职”的人。"></a>不要相信任何向您承诺“肯定会升职”的人。</h4><p>我告诉我团队中的所有工程师的第一件事是，我和任何经理都不能保证“肯定会升职”。如果有人告诉他们这些，请不要相信。我见过太多的开发人员被这样的承诺烧毁。即使有最好的经理，也有很多原因导致“确定”的晋升不会实现。</p><p>首先，任何经理都可能会意外离开。最常见的苦涩故事是这样的：<em>“X 经理答应我会升职，因为我做得很好。然后他们离开了。我的新经理没有兑现这个承诺，决定不提拔我”。</em>第二个原因是，任何经理都可能误判他们的直属部门的表现或公司晋升的政治局势。相信关于“已经在口袋里”类型的声明的好消息很诱人：不要。如果你以表面价值接受这样的承诺，无论它们可能是多么真诚，你都会让自己失望。</p><h4 id="不要让晋升成为你唯一的目标"><a href="#不要让晋升成为你唯一的目标" class="headerlink" title="不要让晋升成为你唯一的目标"></a>不要让晋升成为你唯一的目标</h4><p>无论您在下一级别的表现如何，无论您的经理多么支持您，您都可能不会得到提升。如果你的唯一目标是升职本身，你会士气低落，可能会考虑辞职并寻找新工作，仅仅因为结果本身。</p><p>我曾经有一位我强烈支持的工程师，我 100% 相信他们会得到晋升。尽管我为这个人而战，但他们仍然没有走上连锁店为他们辩护。此后，我更加致力于帮助这位工程师在下一个周期中获得认可。幸运的是，这位开发人员不仅关注结果，而且同样关心其他领域的发展。下一次，他们粉碎了晋升过程，继续保持高增长轨迹。</p><p><strong>如果你的主要目标是职业发展，即使你没有得到提升，你也会获得宝贵的技能。</strong>这些技能可能是传达工程最佳实践、指导他人、领导项目、分享知识等。专注于这些技能，而不是仅仅提升。根据贵公司遵循的流程，促销会成功还是失败。但没有人能夺走你的成长。</p><h4 id="促销不是获得正面反馈的唯一途径"><a href="#促销不是获得正面反馈的唯一途径" class="headerlink" title="促销不是获得正面反馈的唯一途径"></a>促销不是获得正面反馈的唯一途径</h4><p>许多人将晋升视为对工作出色的证明。然而，虽然成功的促销确实意味着出色的反馈，但您获得的大部分正面认可不会通过促销获得。</p><p>你每天都会从和你一起工作的人那里得到反馈，他们会说“<em>谢谢</em>”、“<em>你真的帮了我</em>”或“<em>没有你我会被困更长时间</em>”。你会从你的经理和导师那里得到反馈。而且，当然，还有正式的绩效评估，您的经理还将在其中总结您所做的出色工作 - 以及需要改进的领域。获得奖金或加薪也是所有积极的反馈——所有这些都将比晋升更频繁。</p><h4 id="保持耐心并保持积极态度。这是一场漫长的比赛。"><a href="#保持耐心并保持积极态度。这是一场漫长的比赛。" class="headerlink" title="保持耐心并保持积极态度。这是一场漫长的比赛。"></a>保持耐心并保持积极态度。这是一场漫长的比赛。</h4><p>我有一位有几年经验的才华横溢的开发人员加入了我的团队，他渴望达到高级水平。他们有一个朋友最近晋升到了这个级别，他们觉得这个朋友在他们之前。这个人很沮丧，在经过他们的自我评估后，我告诉他们，与下一个级别相比，他们有太多的差距，无法在本周期晋升。我说，即使他们投入工作，我也看不到他们在下一个周期之前升职，也就是 9 个月之后。我建议我们制定一个计划来实现这一目标。</p><p>首先，这个人很不高兴，认为我已经为他们准备好了。慢慢地，冷静下来之后，我们制定了一个计划。一步一步地，我们取得了进展，他们开始意识到他们需要做多少工作。最终，9个月后，他们升职了。他们还不到5年的经验，已经是高级水平了。作为参考，我花了更长的时间才能达到相同的水平。尽管如此，与他们不同的是，我从未感到落后。</p><p>额外的 6 个月或 12 个月会对您的职业生涯产生影响吗？你越早接触它，你就越认为它会起作用。然而，一段时间后，您可能会意识到这不是短跑，而是马拉松。<strong>虽然您可能会在第一份工作几年后获得晋升，但随着时间的推移，晋升会放缓：获得晋升将更具挑战性。</strong></p><p>玩长时间的游戏。保持积极的态度并专注于您持续的专业成长。将您的成长视为一次旅程，而不是促销的竞争。这样做你会更加平衡。</p><h2 id="帮助别人"><a href="#帮助别人" class="headerlink" title="帮助别人"></a>帮助别人</h2><p>在公司内晋升从来都不是一件容易的事。当您在这方面取得成功时，请考虑回馈并收留某人，帮助他们成长。让其他人知道您愿意指导他人。如果您在团队中看到某人具有良好的成长潜力并且您觉得可以提供帮助，请主动提出指导他们。</p><p>即使你还没有得到提升，也要帮助他人成长并因他们的成长而获得认可。如果你所在的公司有更重量级的晋升流程，有同行评审，你可能会被其他人要求对他们的晋升进行同行评审。如果您在更高级别加入，其他工程师可能会向您寻求有关发展的建议。</p><p><strong>不要忘记，升职是对你成长的认可。最好的成长方式之一就是</strong><a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/"><strong>通过指导</strong></a><strong>来</strong><a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/"><strong>教导他人</strong></a><strong>。</strong>保持平易近人和乐于助人的态度，并为此付出代价。你会学到更多，结交许多盟友，这样你的职业生涯将变得更加愉快。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幸存者偏差</title>
      <link href="/hypo-Z.github.io/2021/11/18/3-xing-cun-zhe-pian-chai/"/>
      <url>/hypo-Z.github.io/2021/11/18/3-xing-cun-zhe-pian-chai/</url>
      
        <content type="html"><![CDATA[<h1 id="幸存者偏差"><a href="#幸存者偏差" class="headerlink" title="幸存者偏差"></a>幸存者偏差</h1><ul><li><p>二战时,美国邀请沃德教授利用统计学知识加强飞机。机翼是最容易击中的<br>位置机尾则是最少被击中的位置，沃德教授的结论：”是应该加强机尾的保护”,<br>而军方指挥官认为:”应该加强机翼的保护,因为这是最容易被击<br>中的地方”。</p></li><li><p>我们太容易在编造历史理论时忘记已经死去的人,但这个问题不仅存在于<br>历史中,还存在于我们在所有领域打造样本并搜集证据的方式中。我们<br>把这种扭曲称为偏差,也就是你所看到的事物与真正存在的庸物之间的差异。<br>我们的认知系统对于不出现在我们眼前或不引起我们感情注意<br>的事物可能没有反应。</p></li><li><p>我们天生肤浅,只注意我们看到的东西,不注意没给<br>我们留下生动印象的东西。我们向沉默的证据发动了双重战争。潜意识<br>的推理机制的确存在这样的机制忽视沉默的证据,即使我们知道需要考虑它。<br>不进入视线则不进入大脑我们对抽象的东西怀有天性上的甚至行动上的蔑视。</p></li></ul><p>—–节选自《黑天鹅》</p><p>作者:纳西姆·尼古拉斯·塔勒布</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超前消费的利与弊?</title>
      <link href="/hypo-Z.github.io/2021/11/17/2-chao-qian-xiao-fei-de-li-yu-bi/"/>
      <url>/hypo-Z.github.io/2021/11/17/2-chao-qian-xiao-fei-de-li-yu-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="超前消费的利与弊"><a href="#超前消费的利与弊" class="headerlink" title="超前消费的利与弊?"></a>超前消费的利与弊?</h1><p>就在昨天,我接到一个电话,说是想邀请我去招商银行办一张信用卡,</p><p>我当时没有答应他说是考虑一下，之后我就想这种形式的消费对我来说的利弊如何？</p><p>在我看来,就像花呗、信用卡之类形式的消费方式就与</p><p>货款无异,都是透支你的个人信用、在你没有这个经济实力的</p><p>情况下,银行给你提供这种方式让你消费,而你恰好踏入这个陷井,因</p><p>为银行给你支出的钱就是从其它人流入的钱流转,银行通过流转收取利息。</p><ul><li>超前消费的利:老话说的好!早卖早享受,晚买享折扣!但是对于你想要购</li></ul><p>买的物品没有足够的资金银行就跟你提供这种方式,抵押你的信用、</p><p>促使你去消费这样就使你能够在每月付出较少代价情况,购买你想要的物品,</p><ul><li>超前消费的弊:虽然你能够提前享受购买物品的快感,去透支你的信用、</li></ul><p>但是它是限制的,并且关键在于你有能力还上你的信用,在你资金链</p><p>充足情况下,信用能帮你周转，但你不能靠此无为乐,</p><p>透支信用的后果就是对自身信用的破坏这种消费形式属于风险</p><p>不大,但后果严重,就如同在悬崖攀爬过程中风险不大。因为你在</p><p>保险绳,就相当于你的资金链,一但你的保险绳断开、跌下谷底便是粉身碎骨。</p><ul><li>总结:对于我来说、自身在可支配资金情况下尽减少或者不用</li></ul><p>这种消费,因为只要你习惯这种形式的消费,你就没有了对他的畏惧感。</p><p>俗话说:淹死的都是会水的。小心驶得万年船。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你眼中的世界</title>
      <link href="/hypo-Z.github.io/2021/11/16/1-ni-yan-zhong-de-shi-jie/"/>
      <url>/hypo-Z.github.io/2021/11/16/1-ni-yan-zhong-de-shi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="你的眼里是什么样的世界就是什么样的"><a href="#你的眼里是什么样的世界就是什么样的" class="headerlink" title="你的眼里是什么样的世界就是什么样的,"></a>你的眼里是什么样的世界就是什么样的,</h1><ul><li>这个世界很大,而人却很渺小人就如同马路上的沙粒微不足道,</li></ul><p>每个人都有不同的生活环境,从小到大，你眼中的世界是什么样的呢?</p><p>我认为世界是一直在变化的,而人也是一样在成长的，人眼中的世界是很局限的，</p><p>人的一生所经历的事物也是有限的,你能经历的就</p><p>只是你身边所能接触到的事与物,在一方面来说,这个世界是有一套它自身</p><p>运转的规则,你只能只身于世界的一个小环境中用你的眼睛去观察</p><p>成的一小部分,所以这个你所认识的世界仅仅是你看到的一小部分、而</p><p>你就认为这就是世界的全部,心中就难免与他所看的世界产生差距。</p><p>另一方面、世界是不断变化的,你所观察到的东西也是不断的变化,</p><p>而且人的心智上的成长也会影响你观察这个世界而得出不同的结</p><p>论。所以说,虽然这个世界有这么多我们看不清的事物和道理，</p><p>但只要我们一直保持独立的思考，并且能拥有一套我们去解释这个世界</p><p>的方法，我们就可以过好大部分的人生了!</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
