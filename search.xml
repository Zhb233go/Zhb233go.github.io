<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>热情假设</title>
      <link href="/zhb233go.github.io/2021/12/07/21-re-qing-jia-she/"/>
      <url>/zhb233go.github.io/2021/12/07/21-re-qing-jia-she/</url>
      
        <content type="html"><![CDATA[<h1 id="热情假设"><a href="#热情假设" class="headerlink" title="热情假设"></a>热情假设</h1><p>2005年，斯坦福大学邀请乔布斯在毕业典礼演讲。这个演讲后来成为经典，《乔布斯传》说”或许有些演讲对后世影响更大，但是你找不到（比这篇）更好的演讲。”</p><p>演讲中，乔布斯说了一段有名的话。</p><blockquote><p>“你们的时间有限，所以不要把它浪费在过其他人的生活。最重要的是，你要有勇气跟随你的内心和直觉。某种程度上，它们已经知道你真正想要成为什么样子。其他所有事情都是次要的。”</p></blockquote><p>这段话后来被称为”热情假设”，很多人都引用它鼓励年轻人：寻找职业方向的时候，要跟随内心的热情（passion），去做那些你有强烈意愿从事的工作。</p><p>但是，美国最近出版了一本新书《优秀到无法忽略》（<a href="https://commoncog.com/blog/so-good-they-cant-ignore-you/">《So Good They Can’t Ignore You》</a>），声称乔布斯的这个建议是完全错误的，误导年轻人。别的不说，乔布斯本人也不遵守”热情假设”。年轻时，他对禅宗思想最感兴趣，去印度学习佛教。如果他真的追随自己的内心，他就应该去当一个禅宗老师，而不是跑回美国创办苹果公司。</p><p>这本书认为，以下几个原因导致”热情假设”不是一个好的建议。</p><ul><li><p>第一，热情真的很罕见。大部分人都对自己的工作没兴趣，而是对某种爱好（比如打球、钓鱼）有兴趣。如果大部分人都找不到自己的职业热情，你怎么能叫他们去追随热情呢？</p></li><li><p>第二，热情需要时间来建立。许多人刚开始工作的时候，对自己的职业并没有兴趣，随着时间积累，他们的经验越来越多，能够掌控的东西越来越多，这才慢慢开始热爱自己的工作。找工作阶段，你可能根本不会意识到这个职业就是你的热情所在。</p></li><li><p>第三，过度强调热情，容易对现状产生不满。2010年的一项调查发现，只有45％的美国人对自己的工作满意。由于很多人相信，无法产生热情的工作不是好工作，导致对职业生涯抱有不切实际的期望，对现有的工作不满意，不断跳槽。</p></li></ul><p>这本书提出，热情不是凭空产生的，它跟自主权有关。如果你在某个职位上的自主权越大，能够掌控的东西越多，就越容易对当前的职业产生热情。<strong>与其强调跟随内心的热情，不如强调如何在某种职业里面获得自主权。你必须使自己变得优秀，让别人无法忽视你，同意让你掌控更多的资源</strong> ，这就是书名的含义。</p><p>——引自阮一峰的网络日志27期</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑天鹅》读后感</title>
      <link href="/zhb233go.github.io/2021/12/06/20-hei-tian-e-du-hou-gan/"/>
      <url>/zhb233go.github.io/2021/12/06/20-hei-tian-e-du-hou-gan/</url>
      
        <content type="html"><![CDATA[<h1 id="《黑天鹅》读后感"><a href="#《黑天鹅》读后感" class="headerlink" title="《黑天鹅》读后感"></a><strong>《黑天鹅》读后感</strong></h1><p>上周终于将《黑天鹅》看完了，利用在地铁上的闲暇时间看的，我知道读书需要一个安静的环境，所以我不知道我有没有看漏一些地方，以下是我读完后的一点浅显的理解：</p><ol><li>黑天鹅事件是不可预测的，对于人们财富的影响是巨大的；</li><li>黑天鹅事件对于财富越大的人越具有影响力，对于贫困的人影响不大；</li><li>黑天鹅事件的影响具有两面性</li><li>黑天鹅事件是可减弱的但不可消除。</li></ol><h3 id="广义解释："><a href="#广义解释：" class="headerlink" title="广义解释："></a>广义解释：</h3><p>黑天鹅事件（英文：”Black swan” incidents)指非常难以预测，且不寻常的事件，通常会引起市场连锁负面反应甚至颠覆。</p><p>一般来说，“黑天鹅”事件是指满足以下三个特点的事件：它具有意外性；它产生重大影响；虽然它具有意外性，但人的本性促使我们在事后为它的发生编造理由，并且或多或少认为它是可解释和可预测的。</p><p>黑天鹅存在于各个领域，无论金融市场、商业、经济还是个人生活，都逃不过它的控制。“<a href="https://baike.baidu.com/item/%E7%81%B0%E7%8A%80%E7%89%9B/22030944">灰犀牛</a></p><p>”是与“黑天鹅”相互补足的概念，“<a href="https://baike.baidu.com/item/%E7%81%B0%E7%8A%80%E7%89%9B%E4%BA%8B%E4%BB%B6/22044335">灰犀牛事件</a>”是太过于常见以至于人们习以为常的风险，“黑天鹅事件”则是极其罕见的、出乎人们意料的风险。</p><h3 id="“黑天鹅”的逻辑是："><a href="#“黑天鹅”的逻辑是：" class="headerlink" title="“黑天鹅”的逻辑是："></a>“黑天鹅”的逻辑是：</h3><p><a href="https://baike.baidu.com/item/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B">你不知道的事</a>比你知道的事更有意义。在人类社会发展的进程中，对我们的历史和社会产生重大影响的，通常都不是我们已知或可以预见的东西。</p><h3 id="对我自己现阶段的解读："><a href="#对我自己现阶段的解读：" class="headerlink" title="对我自己现阶段的解读："></a>对我自己现阶段的解读：</h3><p>就像是这去年刚出的疫情一样，对于我这样的普通人，给我的影响就是出门不方便，人们交流减少，娱乐方式减少。对于个人的财富没有多少影响。但对于一些工厂来说影响确实巨大的，实体产业遭受打击。另一方面线上产业确越发蓬勃。给我的启发就是：看待一个事物时，更应该关注它背后的运行机制，因为在表面上出现的仅仅的它的结果，要从过程去分析结果；它也提醒我需要加强自身的风险意识，去预防不可预测的风险。</p><p>一本好书是值得反复阅读的，之后一定会再阅读一遍，相信会有更多的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/zhb233go.github.io/2021/12/06/0-hello-world/"/>
      <url>/zhb233go.github.io/2021/12/06/0-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Go使用S3搭建Lambda无状态服务</title>
      <link href="/zhb233go.github.io/2021/12/04/go-shi-yong-s3-da-jian-lambda-wu-zhuang-tai-fu-wu/"/>
      <url>/zhb233go.github.io/2021/12/04/go-shi-yong-s3-da-jian-lambda-wu-zhuang-tai-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="golang使用S3搭建Lambda无状态服务"><a href="#golang使用S3搭建Lambda无状态服务" class="headerlink" title="golang使用S3搭建Lambda无状态服务"></a>golang使用S3搭建Lambda无状态服务</h1><p>由于项目需求我需要使用aws的Lambda服务来自动处理存入图片的缩略图的生成和存入功能。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>根据尺寸需求生成对应的缩略图</li><li>自动保存入S3对应位置</li><li>将位置信息告诉后端存入数据库</li><li>日志记录报错和运行信息</li></ul><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><h4 id="1-一个aws账号"><a href="#1-一个aws账号" class="headerlink" title="1.一个aws账号"></a>1.一个aws账号</h4><h4 id="2-编辑好需求的程序-需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。"><a href="#2-编辑好需求的程序-需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。" class="headerlink" title="2.编辑好需求的程序,需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。"></a>2.编辑好需求的程序,需要在本地测试好，确定没问题再转化成Lambda格式，虽然在aws控制台可以测试，但需要打包，很麻烦，先做测试，减少上线步骤。</h4><p>官方的例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>        <span class="token string">"fmt"</span>        <span class="token string">"context"</span>        <span class="token string">"github.com/aws/aws-lambda-go/lambda"</span><span class="token punctuation">)</span><span class="token keyword">type</span> MyEvent <span class="token keyword">struct</span> <span class="token punctuation">{</span>        Name <span class="token builtin">string</span> <span class="token string">`json:"name"`</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">HandleRequest</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> name MyEvent<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Hello %s!"</span><span class="token punctuation">,</span> name<span class="token punctuation">.</span>Name <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lambda<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>HandleRequest<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面列出了有效的处理程序签名。TIn 和 TOut 表示类型与 encoding/json 标准库兼容。有关更多信息，请参阅 func Unmarshal，以了解如何反序列化这些类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>TIn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-部署-zip文件存档"><a href="#3-部署-zip文件存档" class="headerlink" title="3.部署.zip文件存档"></a>3.部署.zip文件存档</h4><h5 id="在-macOS-和-Linux-上创建-zip-文件"><a href="#在-macOS-和-Linux-上创建-zip-文件" class="headerlink" title="在 macOS 和 Linux 上创建 .zip 文件"></a>在 macOS 和 Linux 上创建 .zip 文件</h5><p>编译您的可执行文件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux <span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将 GOOS 设置为 linux 可确保编译的可执行文件与 Go 运行时兼容（即使您在非 Linux 环境中编译它也是如此）。</p><p>（可选）如果您的 main 程序包包含多个文件，请使用以下 go build 命令来编译此程序包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux <span class="token keyword">go</span> build main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（可选）您可能需要使用 Linux 上的 CGO_ENABLED=0 编译程序包：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">GOOS<span class="token operator">=</span>linux CGO_ENABLED<span class="token operator">=</span><span class="token number">0</span> <span class="token keyword">go</span> build main<span class="token punctuation">.</span><span class="token keyword">go</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令为标准 C 库 (libc) 版本创建稳定的二进制程序包，这在 Lambda 和其他设备上可能有所不同。</p><p>Lambda 使用 POSIX 文件权限，因此在创建 .zip 文件存档之前，您可能需要为部署程序包文件夹设置权限。</p><p>通过将可执行文件打包为 .zip 文件来创建部署程序包。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">zip function<span class="token punctuation">.</span>zip main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里有个坑需要踩一下：<br>main包下，最好是将全部程序放在main.go里面，防止在编译时报错，这样打好zip包后到控制台测试运行，一定要做测试，这样才能确保你的程序能够成功运行，最好是查看图片与需求结果是否相同。</p><p>…补充…</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON Web Token 入门教程</title>
      <link href="/zhb233go.github.io/2021/12/03/19-json-web-token-ru-men-jiao-cheng/"/>
      <url>/zhb233go.github.io/2021/12/03/19-json-web-token-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>JSON Web Token 入门教程<br>作者： 阮一峰</p><p>日期： 2018年7月23日</p><p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p><p>一、跨域认证的问题<br>互联网服务离不开用户认证。一般流程是下面这样。</p><p>1、用户向服务器发送用户名和密码。</p><p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p><p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p><p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p><p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p><p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p><p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><p>二、JWT 的原理<br>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><pre class="line-numbers language-none"><code class="language-none">{  "姓名": "张三",  "角色": "管理员",  "到期时间": "2018年7月1日0点0分"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><p>三、JWT 的数据结构<br>实际的 JWT 大概就像下面这样。</p><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><p>Header（头部）<br>Payload（负载）<br>Signature（签名）<br>写成一行，就是下面的样子。</p><pre class="line-numbers language-none"><code class="language-none">Header.Payload.Signature<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面依次介绍这三个部分。</p><p>3.1 Header<br>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><pre class="line-numbers language-none"><code class="language-none">{  "alg": "HS256",  "typ": "JWT"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。</p><p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><p>3.2 Payload<br>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><p>iss (issuer)：签发人<br>exp (expiration time)：过期时间<br>sub (subject)：主题<br>aud (audience)：受众<br>nbf (Not Before)：生效时间<br>iat (Issued At)：签发时间<br>jti (JWT ID)：编号<br>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p><pre class="line-numbers language-none"><code class="language-none">{  "sub": "1234567890",  "name": "John Doe",  "admin": true}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><p>3.3 Signature<br>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><pre class="line-numbers language-none"><code class="language-none">HMACSHA256(  base64UrlEncode(header) + "." +  base64UrlEncode(payload),  secret)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><p>3.4 Base64URL<br>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p><p>四、JWT 的使用方式<br>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p><p><code>Authorization: Bearer &lt;token&gt;</code></p><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><p>五、JWT 的几个特点<br>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p><p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p><p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p><p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p><p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p><p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><p>六、参考链接<br><a href="https://jwt.io/introduction/">Introduction to JSON Web Tokens</a>，by Auth0<br><a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c">Sessionless Authentication using JWTs (with Node + Express + Passport JS)</a>, by Bryan Manuele<br><a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md">Learn how to use JSON Web Tokens</a>, by dwyl</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是微服务架构？</title>
      <link href="/zhb233go.github.io/2021/12/03/18-shi-me-shi-wei-fu-wu-jia-gou/"/>
      <url>/zhb233go.github.io/2021/12/03/18-shi-me-shi-wei-fu-wu-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>什么是软件架构？<br>软件架构的重要性<br>什么是微服务架构？<br>微服务架构的优缺点<br>其他突出的软件架构模式<br>构建微服务架构的最佳实践<br>计划构建微服务架构？</p><h2 id="什么是软件架构？"><a href="#什么是软件架构？" class="headerlink" title="什么是软件架构？"></a>什么是软件架构？</h2><p><img src="https://www.devteam.space/wp-content/uploads/2019/01/What-is-software-architecture.jpg"><br>软件架构模式的模式</p><p>软件架构本质上是任何给定软件系统的结构。它用于提供整个系统的图形表示，有助于开发人员。</p><p>通常有多个组件，每个组件都解决一个或多个功能。</p><p>上面的软件架构图示例显示了这些组件如何相互交互。在“软件架构”中阅读更多相关信息。请记住，上图只是一个基本示例。</p><p>我们称之为软件架构的示意图只是一种视觉表示。每个系统图都显示了软件架构师决定的一系列设计原则，以确保最佳的整体系统功能。做出架构决策是为了确保最佳的安全性、性能、可管理性等。</p><p>这些设计原则、架构决策和示意图都是软件架构的组成部分。它们共同使系统能够满足其业务、运营和技术目标。在此 Techopedia 软件架构定义中阅读更多内容。</p><h2 id="软件架构的重要性"><a href="#软件架构的重要性" class="headerlink" title="软件架构的重要性"></a>软件架构的重要性</h2><p>软件架构对于产品的成功极其重要。有几个原因。</p><h3 id="第一组决定"><a href="#第一组决定" class="headerlink" title="第一组决定"></a>第一组决定</h3><p>在“软件开发生命周期”（SDLC）期间，开发团队在软件架构的创建过程中做出与系统相关的关键决策。在此过程之前，将仅概述业务需求。</p><p>如您所知，确保第一组决策正确无误，将使您的项目处于最佳状态以顺利运行。另一方面，如果这些决定不正确，您的项目几乎肯定会遇到严重的问题。在“良好软件架构的重要性”中阅读更多相关信息。</p><h3 id="视觉呈现的交流工具"><a href="#视觉呈现的交流工具" class="headerlink" title="视觉呈现的交流工具"></a>视觉呈现的交流工具</h3><p>软件架构是一种工具，通过提供示意性表示来帮助沟通，这些表示显示与改进核心功能相关的底层决策。做对了，您的所有项目利益相关者以及您的开发团队将准确了解您的产品将如何运作。</p><h3 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h3><p>软件架构有助于持续开发，特别是对于未来的项目。由于您已经制定和实施了一次架构决策，并拥有示意图，因此可以在未来的项目中重复使用或扩展这些决策。</p><p>这意味着您可以为新产品重用大部分核心结构，因为只有开发工具、编程语言等会有所不同。没有良好的软件架构，项目或产品可能会失败。在此 Quora 问答主题中阅读更多相关信息。</p><h2 id="什么是微服务架构？"><a href="#什么是微服务架构？" class="headerlink" title="什么是微服务架构？"></a>什么是微服务架构？</h2><p><img src="https://www.devteam.space/wp-content/uploads/2019/01/What-is-the-microservices-architecture.jpg"><br>单体架构和微服务架构差异的示意图</p><p>微服务架构模式帮助开发人员创建多个较小的程序，而不是一个大程序。一个大程序通常很难维护，此外，添加新功能也很困难。使用微服务架构，程序员为每个功能创建一个小程序。添加新功能只需要创建另一个小程序。</p><p>视频点播平台 Netflix 是这种架构模式的一个很好的例子。正如您所料，Netflix“用户界面”(UI) 中的每个部分都是不同的服务。实际上，UI 就像是不同网站的集合，尽管它看起来只是一个。阅读“微服务架构（示例和图表） ”了解更多详情。</p><h2 id="微服务架构的优缺点"><a href="#微服务架构的优缺点" class="headerlink" title="微服务架构的优缺点"></a>微服务架构的优缺点</h2><h4 id="这种模式有很多优点："><a href="#这种模式有很多优点：" class="headerlink" title="这种模式有很多优点："></a>这种模式有很多优点：</h4><p>当企业提供彼此明显分离的功能时，这种架构模式可以使他们的应用程序具有高度可扩展性。<br>个别服务可能有不同的需求概况，因此，企业将为这些个别服务实施扩展策略。这有助于优化和确定资源的优先级。<br>如果您使用这种架构模式，您会发现阅读和理解您的代码库会容易得多。<br>维护应用程序更容易。<br>单个微服务可以单独部署。您只部署已更改的微服务，而不是整个应用程序。这减少了在部署过程中花费的时间和精力。<br>您发现调试应用程序更容易，因为您无需查看大型应用程序的多个层。<br>微服务架构模式可以更轻松地隔离故障。<br>如果您使用微服务架构模式，您可以构建更具弹性的服务，这会提高您的应用程序的容错能力。<br>如果您使用微服务架构，则可以提高可重用性。在此模式中，您可以围绕业务功能构建和组织微服务。当与其他业务功能存在共性时，您可以以最少的更改重用您之前开发的微服务。这种重用有助于降低您的开发成本。<br>在“什么是微服务？”。</p><h4 id="也有缺点："><a href="#也有缺点：" class="headerlink" title="也有缺点："></a>也有缺点：</h4><p>如果我们不能清楚地将服务彼此分开，这种模式会增加复杂性。<br>如果多个服务使用相同的任务，则此模式会对性能产生不利影响。<br>如果由于网站不同部分的页面速度不同，微服务过多，用户可能会发现 UI 混乱。如果您使用太多不同的编程语言来开发不同的微服务，那么您的应用程序将更加难以维护。<br>如果您使用微服务架构，集成测试可能会很困难。如果您的组件位于其他系统/环境中，那么您会发现很难设置端到端的集成测试环境。<br>您需要仔细定义微服务与其他服务交互的接口。如果您有太多由不同团队开发的微服务，那么定义此类接口可能会很困难。不同的微服务将相互依赖输入。不同的开发团队需要清楚地了解其他微服务可能使用的接口，因此，沟通是关键。<br>微服务架构实现的一个突出例子<br>想看看微服务架构在起作用吗？好吧，Netflix 就是您的最佳选择！这家流行的流媒体服务提供商充分利用了这种架构模式。</p><p>Netflix 仍在经历高速增长，然而，该公司最初难以跟上它的步伐。它有一个单体架构，它的数据中心与此保持一致。Netflix 无法以足够快的速度建立足够数量的数据中心来跟上其令人印象深刻的增长。</p><p>同年，一个模块代码中缺少一个分号导致 Netflix 网站瘫痪。该网站关闭了几个小时，需要一个大型工程团队的共同努力才能恢复。当 Netflix 不得不进行故障排除时，它总是不得不聘请一个由多个领域组成的大型工程团队。嗯，这就是使用单体架构的巨大应用程序的缺点！</p><p>Netflix 于 2009 年开始转向 AWS 云微服务架构，当时微服务架构模式并不流行，甚至连“微服务”这个词都没有使用。</p><p>该公司于 2009 年首次迁移了一款非面向客户的应用程序，并且进展顺利。随后，Netflix 将其网站的几个面向客户的功能转移到了 AWS 云微服务架构中。到 2011 年 12 月，Netflix 完成了搬迁。</p><p>就本月的情况而言，Netflix 微服务架构中的 API 网关每天处理 20 亿次 API 调用！您可以阅读“为什么不提及 Netflix 就不能谈论微服务”以了解有关此转变的更多信息。</p><p>其他突出的软件架构模式<br>当我们回顾其他软件架构模式的特征时，微服务架构的重要性变得更加清晰。</p><p>微服务架构还有其他四种关键模式：</p><h4 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h4><p>这是最常见的软件架构模式。大多数业务应用程序将信息存储在数据库表中。这种模式在层中有代码。最顶层接受数据。然后数据导航到最底部的层，即数据库。</p><p>大多数关键框架（如 Java EE）都使用这种模式。分层架构提供了一些优势，例如，应用程序易于维护，测试更容易。在“大型企业 Java 项目架构”中阅读更多相关信息。</p><p>缺点是代码量大且无组织，其中大部分只在层之间传递数据，不执行任何业务逻辑。这会影响产品的性能。</p><h4 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h4><p>许多用例涉及仅在有数据要处理时才执行的程序。在事件驱动架构的情况下，中央单元接收所有数据输入。特定的数据输入是事件。然后中央单元委托适当的组件处理特定类型的数据。</p><p>并非所有模块都处理所有数据。这使得应用程序具有可扩展性，此外，开发人员可以轻松扩展系统以应对新事件。在“前 5 种软件架构模式：如何做出正确选择”中阅读更多相关信息。</p><p>有一些缺点。当模块相互影响时，测试变得更加困难。如果多个模块处理同一个事件，它会使错误处理复杂化。由于消息传递开销，系统可能会变慢。</p><h4 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h4><p>常用工具有一组用户重复执行的任务。著名的“集成开发环境”(IDE) Eclipse 就是一个这样的例子，它具有可重复的任务，如打开文件、编辑文件等。</p><p>微内核架构使用微内核来包含这些基本功能。我们可以将其上的所有其他内容视为“插件”。这种模式非常适合流行的工具，因为它可以提高性能。但是，很难定义常见的任务。在“软件架构：您需要了解的 5 种模式”中阅读更多相关信息。</p><h4 id="天基建筑"><a href="#天基建筑" class="headerlink" title="天基建筑"></a>天基建筑</h4><p>基于空间的架构的目标 是在高负载时为 Web 应用程序提供健壮性和稳定性。大多数网站都是围绕数据库构建的，因此，它们依赖于数据库来处理负载。</p><p>使用基于空间的架构，软件架构师将处理和存储拆分到多个服务器中。数据和服务调用分布在节点之间。这有助于避免数据库在高负载情况下崩溃。请注意，测试整个系统可能很困难，因为模拟负载条件可能很棘手。</p><h3 id="构建微服务架构的最佳实践"><a href="#构建微服务架构的最佳实践" class="headerlink" title="构建微服务架构的最佳实践"></a>构建微服务架构的最佳实践</h3><p>微服务架构实现的最佳实践<br>寻找最佳微服务架构<br>概述您的微服务<br>领域驱动设计<br>让每个人都加入<br>使用 RESTful API<br>为特定的微服务建立团队<br>设置服务器和数据存储环境<br>文档 API<br>使用最好的 DevOps 工具包<br>监控是关键</p><h4 id="最佳实践-1：确定微服务架构是否符合您的要求"><a href="#最佳实践-1：确定微服务架构是否符合您的要求" class="headerlink" title="最佳实践 #1：确定微服务架构是否符合您的要求"></a>最佳实践 #1：确定微服务架构是否符合您的要求</h4><p>Amazon、Twitter、eBay 和 PayPal 是成功实施微服务架构设计的组织的例子。这是一种流行的模式，然而，这并不意味着它对你有用。</p><p>如果您不能将您的 Web 应用程序分解为提供价值的功能，那么微服务架构对您来说就没有意义了。阅读“模式：按业务能力分解”以获得更多见解。</p><h4 id="最佳实践-2：定义您的微服务"><a href="#最佳实践-2：定义您的微服务" class="headerlink" title="最佳实践#2：定义您的微服务"></a>最佳实践#2：定义您的微服务</h4><p>您需要明确区分业务功能、服务和微服务。如果没有这个，您可能会构建过大的微服务。这是一种不完整的形式，您将看不到使用微服务方法的任何好处。</p><p>另一方面是创建过多微服务的可能性。这将导致您的架构过度碎片化。请记住，要管理微服务架构，您需要一个成熟的运营团队。在“微服务权衡”中了解它。</p><p>如果微服务太多，运营管理成本会很高。您将看到运营成本的激增掩盖了您从微服务中获得的收益。</p><h4 id="最佳实践-3：使用“领域驱动设计”（DDD）来设计微服务"><a href="#最佳实践-3：使用“领域驱动设计”（DDD）来设计微服务" class="headerlink" title="最佳实践#3：使用“领域驱动设计”（DDD）来设计微服务"></a>最佳实践#3：使用“领域驱动设计”（DDD）来设计微服务</h4><p>虽然这一步与定义微服务的练习密切相关，但它更进了一步。在这里，您可以围绕您的业务领域设计微服务。让我们再次回顾 Netflix 示例。他们从不同的服务器运行他们的内容交付和不同的跟踪服务。</p><p>“领域驱动设计”(DDD) 是一种设计原则，它使用实用的规则和思想来表达面向对象的模型。它帮助软件架构师了解不同的业务领域，因此，他们可以专注于构建业务可以很好理解的微服务架构。在“ DDD 101 — 5 分钟之旅”中阅读更多相关信息。</p><h4 id="最佳实践-4：尽早获得组织领导和团队的支持"><a href="#最佳实践-4：尽早获得组织领导和团队的支持" class="headerlink" title="最佳实践#4：尽早获得组织领导和团队的支持"></a>最佳实践#4：尽早获得组织领导和团队的支持</h4><p>实现微服务架构设计不仅仅是一个技术决策。这种转型代价高昂，而且影响不仅限于内部开发团队。从单体架构过渡是一个漫长的项目。组织中的高级管理人员必须为此投入资金。</p><p>对您的开发团队的影响将是巨大的。到目前为止，您的团队一直在使用端到端测试过程来测试整个系统，以防出现增强。您现在需要围绕微服务对系统进行模块化。这需要文化转型。</p><p>转型将有助于您的业务敏捷性，因为它将促进持续交付。但是，团队必须完全接受转型。阅读我们的指南“敏捷帮助变革管理的 5 种方式”，了解如何有效地帮助这种转变。</p><h4 id="最佳实践-5：最佳地使用-RESTful-API"><a href="#最佳实践-5：最佳地使用-RESTful-API" class="headerlink" title="最佳实践 #5：最佳地使用 RESTful API"></a>最佳实践 #5：最佳地使用 RESTful API</h4><p>如果您优化使用 RESTful API，微服务架构模式可以提供重要的价值。RESTful API 提供了许多优点，例如，您不需要在客户端安装任何东西。您不需要 SDK 或框架，因为使用 API 服务的 HTTP 请求就足够了。在此 Quora 问答主题中阅读有关 RESTful API 优势的更多信息。</p><p>RESTful API 领域的专家 Leonard Richardson 提出了 REST API 使用的成熟度模型。为了从您的微服务架构中实现最佳价值，您应该尝试达到此成熟度模型的最高水平。阅读“微服务架构的 10 个最佳实践”以获得更多见解。</p><h4 id="最佳实践-6：围绕微服务组织团队"><a href="#最佳实践-6：围绕微服务组织团队" class="headerlink" title="最佳实践 #6：围绕微服务组织团队"></a>最佳实践 #6：围绕微服务组织团队</h4><p>您需要建立不同的团队来处理不同的微服务。这些团队应该被赋予足够的权力来处理他们的微服务。但是，所有团队都应该跨职能并了解整个项目计划。</p><p>每个团队都应该具备构建云原生应用程序的必要技能。每个团队都需要业务分析师、开发人员、测试人员和 DevOps 工程师。每个团队都应该有自己的项目经理 (PM)。我们的指南“如何建立Scrum开发团队？”可以帮助您组织这些团队。</p><h4 id="最佳实践-7：为每个微服务提供单独的数据存储"><a href="#最佳实践-7：为每个微服务提供单独的数据存储" class="headerlink" title="最佳实践 #7：为每个微服务提供单独的数据存储"></a>最佳实践 #7：为每个微服务提供单独的数据存储</h4><p>每个微服务都应该为其数据存储做好准备。每个微服务都应该完全拥有自己的数据。当然，数据可以在微服务之间共享，但是，这应该通过 API 进行。</p><p>如果多个微服务共享同一个数据存储，这会导致服务之间的耦合。这将大大违背微服务架构的目的。在“ Top 5+ 微服务架构和设计最佳实践”中阅读更多相关信息。</p><h4 id="最佳实践-8：基于领域设计-API-并很好地记录它们"><a href="#最佳实践-8：基于领域设计-API-并很好地记录它们" class="headerlink" title="最佳实践 #8：基于领域设计 API 并很好地记录它们"></a>最佳实践 #8：基于领域设计 API 并很好地记录它们</h4><p>充分注意基于业务领域设计 API。很好地记录 API。考虑使用Swagger 之类的工具。我们有一个指南“如何为您的移动应用程序构建 RESTful API？”您可以咨询。</p><h4 id="最佳实践-9：使用好的-DevOps-工具集"><a href="#最佳实践-9：使用好的-DevOps-工具集" class="headerlink" title="最佳实践 #9：使用好的 DevOps 工具集"></a>最佳实践 #9：使用好的 DevOps 工具集</h4><p>到目前为止，您应该已经将微服务设计得足够好，可以独立部署它们。为了从这些微服务中实现最佳价值，您需要自动化构建和部署管理。因此，您将需要一套良好的 DevOps 工具。</p><p>用于部署自动化的 Jenkins 和用于容器化的 Docker 是一个很好的组合。但是，如果您需要更多示例，请阅读“ 2019 年的 10 个最佳 DevOps 工具”。</p><h4 id="最佳实践-10：投资于监控"><a href="#最佳实践-10：投资于监控" class="headerlink" title="最佳实践 #10：投资于监控"></a>最佳实践 #10：投资于监控</h4><p>如果您使用的是单体架构并正在过渡到微服务架构，则必须解决日益增加的复杂性。对性能和动态环境的需求增加需要更高级的监控。</p><p>一个好的监控解决方案应该解决资源分配的持续变化。这样的解决方案应该将从监控中收集的数据存储在中央数据库中。它产生的洞察力应该揭示应用程序的动态特性。</p><p>每个微服务都应该使用监控代理。监控系统应支持根本原因分析。阅读更多关于它在“成功微服务设计的 5 个基础”中的重要性。</p><h3 id="部署微服务架构时的关键考虑因素"><a href="#部署微服务架构时的关键考虑因素" class="headerlink" title="部署微服务架构时的关键考虑因素"></a>部署微服务架构时的关键考虑因素</h3><p>可以看到，部署微服务架构是一个涉及到的项目。在进行此类项目时，请牢记以下注意事项：</p><ol><li><p>管理依赖<br>您需要在微服务架构中以不同于单体应用程序中的方式管理依赖项。微服务架构涉及每个独立运行的服务。但是，一个微服务可能需要访问系统的其他部分。这就是复杂性出现的地方。仔细考虑依赖关系。</p></li><li><p>寻找具有所需知识的建筑师<br>架构师将在实施微服务架构中发挥关键作用。你需要一个称职的建筑师。架构师可能需要使用事件驱动的聚合来实现此架构，这需要适当的后端相关专业知识。</p></li></ol><p>请记住，微服务架构中的微服务是分布式系统。因此，架构师需要具备这方面的良好知识。</p><p>此外，架构师需要实现从多个数据存储中检索数据的查询。在微服务架构中，这将比单体应用更复杂。该项目可能会使用“事件溯源”模式，这会增加复杂性。架构师可能需要在此处使用“通用查询职责分离”(CQRS) 模式。</p><p>在某些情况下，架构师可能需要使用“断路器”模式。这可以帮助多个服务在为请求提供服务时进行协作。一个服务可能会同步调用另一个服务。此其他服务可能会停机，或者，它可能会遇到高延迟。“断路器”模式可防止此类问题影响其他服务。</p><p>负载平衡恰好是架构师需要足够经验的另一个领域。它有助于微服务在管理系统负载的同时保持安全性和可用性。</p><p>开发人员可能会在创建微服务时对要实现的端点数量感到困惑。知识渊博的软件架构师可以在这里发挥很大的作用，因为他/她知道端点的数量取决于服务的类型。</p><ol start="3"><li>使用正确的工具和框架，如“Spring Boot”<br>使用正确的开源工具可以极大地帮助实现微服务架构。幸运的是，您可以利用丰富的开源工具生态系统。</li></ol><p>例如，您可以使用流行的开源框架“Spring Boot”轻松创建微服务。以下是此类工具的更多示例：</p><p>API开发的邮递员；<br>用于消息传递的 Amazon Simple Queue Service (SQS)；<br>用于监控的 Logstash；<br>用于部署的 Kubernetes。<br>GitHub 在这里值得一提，尽管它不是完全开源的。这有助于您进行版本控制和源代码管理。</p><ol start="4"><li>为可扩展性设计微服务<br>在设计微服务时，可扩展性是一个关键因素。无论是创建新服务还是增强现有服务，都需要注意这一点。为此，您需要考虑各种方法和技术。</li></ol><p>一个很好的例子是缓存。请记住遵循正确的教程在微服务架构中实现它。异步消息传递使您能够在构建微服务时提供更好的可扩展性。</p><ol start="5"><li>处理认证和授权<br>处理用户身份验证和授权在微服务和单体应用程序之间差异很大。您需要非常了解这些差异的架构师和开发人员。</li></ol><p>例如，他们需要准确地定义有界上下文。这将帮助他们定义具有大量粒度的用户授权。</p><p>再举一个例子。您的团队将需要使用令牌进行用户身份验证。存在各种类型的令牌，例如“JSON Web 令牌”(JWT)。近年来，这种开放标准的代币越来越受欢迎。您需要了解此类现代标准的架构师和开发人员。</p><ol start="6"><li>恰当地使用服务网格<br>有时您需要实现外部配置，如凭据以及微服务架构模式。您可能需要监控指标以了解应用程序的执行情况。考虑使用服务网格来管理服务之间的通信。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习惯的养成</title>
      <link href="/zhb233go.github.io/2021/12/02/17-xi-guan-de-yang-cheng/"/>
      <url>/zhb233go.github.io/2021/12/02/17-xi-guan-de-yang-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="习惯的养成"><a href="#习惯的养成" class="headerlink" title="习惯的养成"></a>习惯的养成</h1><p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p><p>看一本书 → 看一页书<br>写一篇文章 → 写一句话<br>跑10公里 → 穿上跑鞋<br>做100次俯卧撑 → 做1次俯卧撑<br>多吃蔬菜水果 → 吃一个水果<br>编写一个程序 → 编写一个函数 → 编写一行代码<br>这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。</p><p>阅读一页 → 阅读10页 → 读完第一章<br>写一个句子 → 写文章的开头 → 写出正文<br>穿上跑鞋 → 步行5分钟 → 跑步5分钟<br>一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。</p><p><img src="https://www.wangbase.com/blogimg/asset/202007/bg2020072418.jpg" alt="image"></p><p>一个人应该能够换尿布，策划战争，杀猪，开船，设计房子，写十四行诗，结算账户，砌墙，接脱臼的骨头，安慰濒死的人，服从命令，发布命令，携手合作，独立行动，解数学方程，分析新问题，铲粪，电脑编程，做出可口的饭，善打架，勇敢地死去。只有昆虫才专业化。<br>—— 罗伯特・安森・海因莱因</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二八定律</title>
      <link href="/zhb233go.github.io/2021/11/30/16-er-ba-ding-lu/"/>
      <url>/zhb233go.github.io/2021/11/30/16-er-ba-ding-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="二八定律"><a href="#二八定律" class="headerlink" title="二八定律"></a>二八定律</h1><ul><li>二八定律又叫帕累托定律,是19世纪末20世纪初意大利经济学家<br>帕累托发现的一种奇怪的社会现象。他认为,在任何一组东西中最重要的</li><li>只占其中一小部分,约20%,其余80%尽管是多数却是次要的,因此又称 二八定律,<br>最著名的是”社会上20%的人掌握了80%的财富!”外汇市场二八定律实际就是二<br>八定律在外汇市场上的一些具体表现,是一些看似不可能但又具有真实影响的<br>现象。</li><li>二八定律在社会中的现象极其普遍,它的现实意义:二八法则不仅在<br>经济学管理学领域应用广泛,它对我们自身发展也有重要的现实意义:<br>学会避免将时间和精力花费在琐事上,要学会抓主要矛盾。<br>一个人的精力和时间都是非常有限的要想真正”做好每件事情”几乎是<br>不可能的,要学会合理分配时间和精力。要想面面俱到还不如重点突破。<br>把80%的资源花在能出关键效益的炸的方面,这20%的方面又能带动其余<br>80%的发展。</li><li>二八定律运用在我自身,我认为我每天三分之一的时间用于在工作上,三分<br>之用手休息,还有三分之一也不能白白浪费,在工作中,80%时间用于解决实际<br>贴到20%的难题就行了。其余20%用于学习新知识,扩展知识广度。而在私下<br>生活80%时间用于提升自身身心从煅练身体,阅读写作,训练口语方面着<br>手,而余下20%就拿来继续思考和处理琐事。</li><li>二八定律也可以用于人生的成长和财富积累，人生真正能好好生活的可能<br>就20%人生.所以在人生的黄金时期更要好好计划,让这20%去养活<br>余下80%人生。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的青春结束了</title>
      <link href="/zhb233go.github.io/2021/11/29/15-wo-de-qing-chun-jie-shu-liao/"/>
      <url>/zhb233go.github.io/2021/11/29/15-wo-de-qing-chun-jie-shu-liao/</url>
      
        <content type="html"><![CDATA[<h1 id="我的青春结束了"><a href="#我的青春结束了" class="headerlink" title="我的青春结束了"></a>我的青春结束了</h1><p>在周六的那天晚天,因为第二天需要早起,我比平常更早的,差不多,<br>八点多就开始睡觉了,当我睡到九点半多时,我彼声微信视频闹铃吵醒了<br>,我咪咪糊糊打开手机开始接听。原来是我的好兄弟<br>打过来的,他略带惊讶和急切的口吻对我说道:”兄弟你听说了吗?<br>你还有你前女友的微信吗?你不知道发生什么了吗!”我缓缓说道:她<br>被求婚了是吧,我听鋭了”,他略带同情的对我说:”兄弟,你还跟她联<br>系吗?”我回忙了一下说”好像一年多没联系了,我屏敝她了。”</p><p>是啊,曾经那个学生时代难忘的回忆,在时间这个巨轮面前,就如<br>同一颗小石子被无情碾过。我一直坚信那句话,人是会变的，两个人能否<br>最终走到一起,需要的是正确的时间和正确的地点。青春的时候<br>我们天真无邪,认为世界就是你我不需要考虑现实。现实是随着<br>时间流淌我们变得越来越现实,而你我的模样早已不是当初的<br>记忆,但是,人终一日会找到她的归属,我怀着真诚的心,诚挚的<br>祝福每个在我成长路上遇到的人,希望她能幸福!</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人生游戏</title>
      <link href="/zhb233go.github.io/2021/11/25/14-ren-sheng-you-xi/"/>
      <url>/zhb233go.github.io/2021/11/25/14-ren-sheng-you-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="人生是场游戏"><a href="#人生是场游戏" class="headerlink" title="人生是场游戏"></a>人生是场游戏</h1><p>生存是种即时策略游戏、所有的人都是这场游戏的玩家。财务自由了,<br>就是游戏的赢家。<br>具体来说又分成两种游戏财富游戏和地位游戏。财富游戏<br>的统家追求更多的财富,地位游戏的玩家追求最高的地位。<br>古时候,地位越高,财富越多,当大官就发大财.所以大家都说地位<br>游戏。现代社会财富游戏和地位游戏慢慢脱离了关系,不当大<br>官也可以发大财,财富游戏的玩家多了起来。<br>这两种游戏有本质的区别。地位游戏一定是零和的,有赢家<br>就肯定有输家。比如,我当了部门主管你就不能当了。所以地位<br>游戏很凶险,必须时刻提防其他玩家的冷枪。财富游戏不是零和的,<br>我赚了钱,不影响其人的收益很可能双赢。<br>创业是财富游戏,政治是地位游戏。因为上面的原因,我<br>认为,创业值得参与,政治不值得参与。有些创业项目也是零和的,<br>比如,抢票技术、秒杀技术、游戏外挂等,也不值得参与。</p><p>引用—网络</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/zhb233go.github.io/2021/11/24/13-du-shu-bi-ji/"/>
      <url>/zhb233go.github.io/2021/11/24/13-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h1><p>人不定命运的囚徒而是自己思想的囚徒——富兰克林•罗斯福</p><p>在我们进行天分比较时经常忽略沉默的证据,尤其在那些<br>受赢家通吃效应影响的行业。我们也许很喜欢那些成功故事,但太<br>把它们当回事是不应该的,因为我们并没有看到全部事实。</p><p>列夫·托尔斯泰说过,所有幸运的家庭都是一样的,而不幸的家庭<br>各有各的不幸。人们被发现犯了”喜欢苹果胜于喜欢橘子,喜欢橘子胜于<br>梨,喜欢梨胜于苹果”的错误,这视具体问题而定。<br>我们应该避免柏拉图化的思想。柏拉图化是自上而下的,程式化的,封闭思维的,自我服务的商品化的,非柏拉图化是自下而上的开放<br>思维的,怀疑的经验的。—-节选《黑天鹅》</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——并发</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-bing-fa/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-bing-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——并发"><a href="#Go语言基础——并发" class="headerlink" title="Go语言基础——并发"></a>Go语言基础——并发</h1><p>并发是编程里面一个非常重要的概念，Go语言在语言层面天生支持并发，这也是Go语言流行的一个很重要的原因。</p><h1 id="Go语言中的并发编程"><a href="#Go语言中的并发编程" class="headerlink" title="Go语言中的并发编程"></a>Go语言中的并发编程</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并发：同一时间段内执行多个任务（你在用微信和两个女朋友聊天）。</p><p>并行：同一时刻执行多个任务（你和你朋友都在用微信和女朋友聊天）。</p><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>在java/c++中我们要实现并发编程的时候，我们通常需要自己维护一个线程池，并且需要自己去包装一个又一个的任务，同时需要自己去调度线程执行任务并维护上下文切换，这一切通常会耗费程序员大量的心智。那么能不能有一种机制，程序员只需要定义很多个任务，让系统去帮助我们把这些任务分配到CPU上实现并发执行呢？</p><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>Go语言中使用<code>goroutine</code>非常简单，只需要在调用函数的时候在前面加上<code>go</code>关键字，就可以为一个函数创建一个<code>goroutine</code>。</p><p>一个<code>goroutine</code>必定对应一个函数，可以创建多个<code>goroutine</code>去执行相同的函数。</p><h3 id="启动单个goroutine"><a href="#启动单个goroutine" class="headerlink" title="启动单个goroutine"></a>启动单个goroutine</h3><p>启动goroutine的方式非常简单，只需要在调用的函数（普通函数和匿名函数）前面加上一个<code>go</code>关键字。</p><p>举个例子如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例中hello函数和下面的语句是串行的，执行的结果是打印完<code>Hello Goroutine!</code>后打印<code>main goroutine done!</code>。</p><p>接下来我们在调用hello函数前面加上关键字<code>go</code>，也就是启动一个goroutine去执行hello这个函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这一次的执行结果只打印了<code>main goroutine done!</code>，并没有打印<code>Hello Goroutine!</code>。为什么呢？</p><p>在程序启动时，Go程序就会为<code>main()</code>函数创建一个默认的<code>goroutine</code>。</p><p>当main()函数返回的时候该<code>goroutine</code>就结束了，所有在<code>main()</code>函数中启动的<code>goroutine</code>会一同结束，<code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是<code>time.Sleep</code>了。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行上面的代码你会发现，这一次先打印<code>main goroutine done!</code>，然后紧接着打印<code>Hello Goroutine!</code>。</p><p>首先为什么会先打印<code>main goroutine done!</code>是因为我们在创建新的goroutine的时候需要花费一些时间，而此时main函数所在的<code>goroutine</code>是继续执行的。</p><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// goroutine结束就登记-1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 启动一个goroutine就登记+1</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 等待所有登记的goroutine都结束</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h2 id="goroutine与线程"><a href="#goroutine与线程" class="headerlink" title="goroutine与线程"></a>goroutine与线程</h2><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h3 id="goroutine调度"><a href="#goroutine调度" class="headerlink" title="goroutine调度"></a>goroutine调度</h3><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ul><li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">点我了解更多</a></p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B:"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>runtime<span class="token punctuation">.</span><span class="token function">GOMAXPROCS</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><h3 id="channel类型"><a href="#channel类型" class="headerlink" title="channel类型"></a>channel类型</h3><p><code>channel</code>是一种类型，一种引用类型。声明通道类型的格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> 变量 <span class="token keyword">chan</span> 元素类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>举几个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch1 <span class="token keyword">chan</span> <span class="token builtin">int</span>   <span class="token comment">// 声明一个传递整型的通道</span><span class="token keyword">var</span> ch2 <span class="token keyword">chan</span> <span class="token builtin">bool</span>  <span class="token comment">// 声明一个传递布尔型的通道</span><span class="token keyword">var</span> ch3 <span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// 声明一个传递int切片的通道</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><p>通道是引用类型，通道类型的空值是<code>nil</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// &lt;nil&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>声明的通道后需要使用<code>make</code>函数初始化之后才能使用。</p><p>创建channel的格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> 元素类型<span class="token punctuation">,</span> <span class="token punctuation">[</span>缓冲大小<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>channel的缓冲大小是可选的。</p><p>举几个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch4 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch5 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>ch6 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">ch <span class="token operator">&lt;-</span> <span class="token number">10</span> <span class="token comment">// 把10发送到ch中</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token operator">&lt;-</span> ch <span class="token comment">// 从ch中接收值并赋值给变量x</span><span class="token operator">&lt;-</span>ch       <span class="token comment">// 从ch中接收值，忽略结果</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">fatal error: all goroutines are asleep - deadlock<span class="token operator">!</span>goroutine <span class="token number">1</span> <span class="token punctuation">[</span>chan send<span class="token punctuation">]</span>:main.main<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">..</span>./src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">recv</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ret <span class="token operator">:=</span> <span class="token operator">&lt;-</span>cfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收成功"</span><span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">recv</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token comment">// 启用goroutine从通道接收值</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个容量为1的有缓冲区通道</span>ch <span class="token operator">&lt;-</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="for-range从通道循环取值"><a href="#for-range从通道循环取值" class="headerlink" title="for range从通道循环取值"></a>for range从通道循环取值</h3><p>当向通道中发送完数据时，我们可以通过<code>close</code>函数来关闭通道。</p><p>当通道被关闭时，再往该通道发送值会引发<code>panic</code>，从该通道取值的操作会先取完通道中的值，再然后取到的值一直都是对应类型的零值。那如何判断一个通道是否被关闭了呢？</p><p>我们来看下面这个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// channel 练习</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token comment">// 开启goroutine将0~100的数发送到ch1中</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>ch1 <span class="token operator">&lt;-</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 开启goroutine从ch1中接收值，并将该值的平方发送到ch2中</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span>i<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1 <span class="token comment">// 通道关闭后再取值ok=false</span><span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span>ch2 <span class="token operator">&lt;-</span> i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 在主goroutine中从ch2中接收值打印</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> ch2 <span class="token punctuation">{</span> <span class="token comment">// 通道关闭后会退出for range循环</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子中我们看到有两种方式在接收值的时候判断该通道是否被关闭，不过我们通常使用的是<code>for range</code>的方式。使用<code>for range</code>遍历通道，当通道被关闭的时候就会退出<code>for range</code>。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">counter</span><span class="token punctuation">(</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>out <span class="token operator">&lt;-</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">squarer</span><span class="token punctuation">(</span>out <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">,</span> in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">{</span>out <span class="token operator">&lt;-</span> i <span class="token operator">*</span> i<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">printer</span><span class="token punctuation">(</span>in <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> in <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">counter</span><span class="token punctuation">(</span>ch1<span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">squarer</span><span class="token punctuation">(</span>ch2<span class="token punctuation">,</span> ch1<span class="token punctuation">)</span><span class="token function">printer</span><span class="token punctuation">(</span>ch2<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p><h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src="https://www.liwenzhou.com/images/Go/concurrence/channel01.png" alt="channel异常总结"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p><h2 id="worker-pool（goroutine池）"><a href="#worker-pool（goroutine池）" class="headerlink" title="worker pool（goroutine池）"></a>worker pool（goroutine池）</h2><p>在工作中我们通常会使用可以指定启动的goroutine数量–<code>worker pool</code>模式，控制<code>goroutine</code>的数量，防止<code>goroutine</code>泄漏和暴涨。</p><p>一个简易的<code>work pool</code>示例代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">worker</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">,</span> jobs <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> results <span class="token keyword">chan</span><span class="token operator">&lt;-</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token keyword">range</span> jobs <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"worker:%d start job:%d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> j<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"worker:%d end job:%d\n"</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> j<span class="token punctuation">)</span>results <span class="token operator">&lt;-</span> j <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>jobs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>results <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token comment">// 开启3个goroutine</span><span class="token keyword">for</span> w <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> w <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> w<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">go</span> <span class="token function">worker</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> jobs<span class="token punctuation">,</span> results<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 5个任务</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>jobs <span class="token operator">&lt;-</span> j<span class="token punctuation">}</span><span class="token function">close</span><span class="token punctuation">(</span>jobs<span class="token punctuation">)</span><span class="token comment">// 输出结果</span><span class="token keyword">for</span> a <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> a <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> a<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token operator">&lt;-</span>results<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h2><p>在某些场景下我们需要同时从多个通道接收数据。通道在接收数据时，如果没有数据可以接收将会发生阻塞。你也许会写出如下代码使用遍历的方式来实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span><span class="token punctuation">{</span>    <span class="token comment">// 尝试从ch1接收值</span>    data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch1    <span class="token comment">// 尝试从ch2接收值</span>    data<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2    …<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种方式虽然可以实现从多个通道接收值的需求，但是运行性能会差很多。为了应对这种场景，Go内置了<code>select</code>关键字，可以同时响应多个通道的操作。</p><p><code>select</code>的使用类似于switch语句，它有一系列case分支和一个默认的分支。每个case会对应一个通道的通信（接收或发送）过程。<code>select</code>会一直等待，直到某个<code>case</code>的通信操作完成时，就会执行<code>case</code>分支对应的语句。具体格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">case</span> data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">case</span> ch3<span class="token operator">&lt;-</span>data<span class="token punctuation">:</span>        <span class="token operator">...</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        默认操作<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>举个小例子来演示下<code>select</code>的使用：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">case</span> ch <span class="token operator">&lt;-</span> i<span class="token punctuation">:</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>select</code>语句能提高代码的可读性。</p><ul><li>可处理一个或多个channel的发送/接收操作。</li><li>如果多个<code>case</code>同时满足，<code>select</code>会随机选择一个。</li><li>对于没有<code>case</code>的<code>select{}</code>会一直等待，可用于阻塞main函数。</li></ul><h2 id="并发安全和锁"><a href="#并发安全和锁" class="headerlink" title="并发安全和锁"></a>并发安全和锁</h2><p>有时候在Go代码中可能会存在多个<code>goroutine</code>同时操作一个资源（临界区），这种情况会发生<code>竞态问题</code>（数据竞态）。类比现实生活中的例子有十字路口被各个方向的的汽车竞争；还有火车上的卫生间被车厢里的人竞争。</p><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int64</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中我们开启了两个<code>goroutine</code>去累加变量x的值，这两个<code>goroutine</code>在访问和修改<code>x</code>变量的时候就会存在数据竞争，导致最后的结果与期待的不符。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个<code>goroutine</code>可以访问共享资源。Go语言中使用<code>sync</code>包的<code>Mutex</code>类型来实现互斥锁。 使用互斥锁来修复上面代码的问题：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int64</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">var</span> lock sync<span class="token punctuation">.</span>Mutex<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加锁</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 解锁</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用互斥锁能够保证同一时间有且只有一个<code>goroutine</code>进入临界区，其他的<code>goroutine</code>则在等待锁；当互斥锁释放后，等待的<code>goroutine</code>才可以获取锁进入临界区，多个<code>goroutine</code>同时等待一个锁时，唤醒的策略是随机的。</p><h3 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h3><p>互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用<code>sync</code>包中的<code>RWMutex</code>类型。</p><p>读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的<code>goroutine</code>如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个<code>goroutine</code>获取写锁之后，其他的<code>goroutine</code>无论是获取读锁还是写锁都会等待。</p><p>读写锁示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>x      <span class="token builtin">int64</span>wg     sync<span class="token punctuation">.</span>WaitGrouplock   sync<span class="token punctuation">.</span>Mutexrwlock sync<span class="token punctuation">.</span>RWMutex<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// lock.Lock()   // 加互斥锁</span>rwlock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加写锁</span>x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// 假设读操作耗时10毫秒</span>rwlock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   <span class="token comment">// 解写锁</span><span class="token comment">// lock.Unlock()                     // 解互斥锁</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// lock.Lock()                  // 加互斥锁</span>rwlock<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>               <span class="token comment">// 加读锁</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span> <span class="token comment">// 假设读操作耗时1毫秒</span>rwlock<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment">// 解读锁</span><span class="token comment">// lock.Unlock()                // 解互斥锁</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>start <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>end<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是读写锁非常适合读多写少的场景，如果读和写的操作差别不大，读写锁的优势就发挥不出来。</p><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><p>在代码中生硬的使用<code>time.Sleep</code>肯定是不合适的，Go语言中可以使用<code>sync.WaitGroup</code>来实现并发任务的同步。 <code>sync.WaitGroup</code>有以下几个方法：</p><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">(wg * WaitGroup) Add(delta int)</td><td align="center">计数器+delta</td></tr><tr><td align="center">(wg *WaitGroup) Done()</td><td align="center">计数器-1</td></tr><tr><td align="center">(wg *WaitGroup) Wait()</td><td align="center">阻塞直到计数器变为0</td></tr></tbody></table><p><code>sync.WaitGroup</code>内部维护着一个计数器，计数器的值可以增加和减少。例如当我们启动了N 个并发任务时，就将计数器值增加N。每个任务完成时通过调用Done()方法将计数器减1。通过调用Wait()来等待并发任务执行完，当计数器值为0时，表示所有并发任务已经完成。</p><p>我们利用<code>sync.WaitGroup</code>将上面的代码优化一下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">func</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello Goroutine!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动另外一个goroutine去执行hello函数</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"main goroutine done!"</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意<code>sync.WaitGroup</code>是一个结构体，传递的时候要传递指针。</p><h3 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h3><p>说在前面的话：这是一个进阶知识点。</p><p>在编程的很多场景下我们需要确保某些操作在高并发的场景下只执行一次，例如只加载一次配置文件、只关闭一次通道等。</p><p>Go语言中的<code>sync</code>包中提供了一个针对只执行一次场景的解决方案–<code>sync.Once</code>。</p><p><code>sync.Once</code>只有一个<code>Do</code>方法，其签名如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>o <span class="token operator">*</span>Once<span class="token punctuation">)</span> <span class="token function">Do</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>备注：如果要执行的函数<code>f</code>需要传递参数就需要搭配闭包来使用。</em></p><h4 id="加载配置文件示例"><a href="#加载配置文件示例" class="headerlink" title="加载配置文件示例"></a>加载配置文件示例</h4><p>延迟一个开销很大的初始化操作到真正用到它的时候再执行是一个很好的实践。因为预先初始化一个变量（比如在init函数中完成初始化）会增加程序的启动耗时，而且有可能实际执行过程中这个变量没有用上，那么这个初始化操作就不是必须要做的。我们来看一个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">{</span><span class="token string">"left"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"up"</span><span class="token punctuation">:</span>    <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">:</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Icon 被多个goroutine调用时不是并发安全的</span><span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">{</span><span class="token keyword">if</span> icons <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多个<code>goroutine</code>并发调用Icon函数时不是并发安全的，现代的编译器和CPU可能会在保证每个<code>goroutine</code>都满足串行一致的基础上自由地重排访问内存的顺序。loadIcons函数可能会被重排为以下结果：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"left"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"up"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"right"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span>icons<span class="token punctuation">[</span><span class="token string">"down"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种情况下就会出现即使判断了<code>icons</code>不是nil也不意味着变量初始化完成了。考虑到这种情况，我们能想到的办法就是添加互斥锁，保证初始化<code>icons</code>的时候不会被其他的<code>goroutine</code>操作，但是这样做又会引发性能问题。</p><p>使用<code>sync.Once</code>改造的示例代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> icons <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token keyword">var</span> loadIconsOnce sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">loadIcons</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>icons <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>image<span class="token punctuation">.</span>Image<span class="token punctuation">{</span><span class="token string">"left"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"left.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"up"</span><span class="token punctuation">:</span>    <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"up.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"right"</span><span class="token punctuation">:</span> <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"right.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"down"</span><span class="token punctuation">:</span>  <span class="token function">loadIcon</span><span class="token punctuation">(</span><span class="token string">"down.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">// Icon 是并发安全的</span><span class="token keyword">func</span> <span class="token function">Icon</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> image<span class="token punctuation">.</span>Image <span class="token punctuation">{</span>loadIconsOnce<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>loadIcons<span class="token punctuation">)</span><span class="token keyword">return</span> icons<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="并发安全的单例模式"><a href="#并发安全的单例模式" class="headerlink" title="并发安全的单例模式"></a>并发安全的单例模式</h4><p>下面是借助<code>sync.Once</code>实现的并发安全的单例模式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> singleton<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">type</span> singleton <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">var</span> instance <span class="token operator">*</span>singleton<span class="token keyword">var</span> once sync<span class="token punctuation">.</span>Once<span class="token keyword">func</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>singleton <span class="token punctuation">{</span>    once<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token operator">&amp;</span>singleton<span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> instance<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sync.Once</code>其实内部包含一个互斥锁和一个布尔值，互斥锁保证布尔值和数据的安全，而布尔值用来记录初始化是否完成。这样设计就能保证初始化操作的时候是并发安全的并且初始化操作也不会被执行多次。</p><h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>Go语言中内置的map不是并发安全的。请看下面的示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span><span class="token keyword">return</span> m<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">set</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> value <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>key <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> n<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k=:%v,v:=%v\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码开启少量几个<code>goroutine</code>的时候可能没什么问题，当并发多了之后执行上面的代码就会报<code>fatal error: concurrent map writes</code>错误。</p><p>像这种场景下就需要为map加锁来保证并发的安全性了，Go语言的<code>sync</code>包中提供了一个开箱即用的并发安全版map–<code>sync.Map</code>。开箱即用表示不用像内置的map一样使用make函数初始化就能直接使用。同时<code>sync.Map</code>内置了诸如<code>Store</code>、<code>Load</code>、<code>LoadOrStore</code>、<code>Delete</code>、<code>Range</code>等操作方法。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> m <span class="token operator">=</span> sync<span class="token punctuation">.</span>Map<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>wg <span class="token operator">:=</span> sync<span class="token punctuation">.</span>WaitGroup<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>key <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>m<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> n<span class="token punctuation">)</span>value<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> m<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"k=:%v,v:=%v\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>在上面的代码中的我们通过锁操作来实现同步。而锁机制的底层是基于原子操作的，其一般直接通过CPU指令实现。Go语言中原子操作由内置的标准库<code>sync/atomic</code>提供。</p><h3 id="atomic包"><a href="#atomic包" class="headerlink" title="atomic包"></a>atomic包</h3><table><thead><tr><th align="center">方法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">func LoadInt32(addr *int32) (val int32) func LoadInt64(addr *int64) (val int64) func LoadUint32(addr *uint32) (val uint32) func LoadUint64(addr *uint64) (val uint64) func LoadUintptr(addr *uintptr) (val uintptr) func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</td><td align="center">读取操作</td></tr><tr><td align="center">func StoreInt32(addr *int32, val int32) func StoreInt64(addr *int64, val int64) func StoreUint32(addr *uint32, val uint32) func StoreUint64(addr *uint64, val uint64) func StoreUintptr(addr *uintptr, val uintptr) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</td><td align="center">写入操作</td></tr><tr><td align="center">func AddInt32(addr *int32, delta int32) (new int32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</td><td align="center">修改操作</td></tr><tr><td align="center">func SwapInt32(addr *int32, new int32) (old int32) func SwapInt64(addr *int64, new int64) (old int64) func SwapUint32(addr *uint32, new uint32) (old uint32) func SwapUint64(addr *uint64, new uint64) (old uint64) func SwapUintptr(addr *uintptr, new uintptr) (old uintptr) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</td><td align="center">交换操作</td></tr><tr><td align="center">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool) func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool) func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool) func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</td><td align="center">比较并交换操作</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们填写一个示例来比较下互斥锁和原子操作的性能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"sync"</span><span class="token string">"sync/atomic"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">type</span> Counter <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token comment">// 普通版</span><span class="token keyword">type</span> CommonCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c CommonCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c CommonCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token comment">// 互斥锁版</span><span class="token keyword">type</span> MutexCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span>lock    sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>m<span class="token punctuation">.</span>counter<span class="token operator">++</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MutexCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span>m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> m<span class="token punctuation">.</span>counter<span class="token punctuation">}</span><span class="token comment">// 原子操作版</span><span class="token keyword">type</span> AtomicCounter <span class="token keyword">struct</span> <span class="token punctuation">{</span>counter <span class="token builtin">int64</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>counter<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>a <span class="token operator">*</span>AtomicCounter<span class="token punctuation">)</span> <span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">{</span><span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">LoadInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroupstart <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>end <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>c1 <span class="token operator">:=</span> CommonCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 非并发安全</span><span class="token function">test</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>c2 <span class="token operator">:=</span> MutexCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 使用互斥锁实现并发安全</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c2<span class="token punctuation">)</span>c3 <span class="token operator">:=</span> AtomicCounter<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 并发安全且比互斥锁效率更高</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c3<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>atomic</code>包提供了底层的原子级内存操作，对于同步算法的实现很有用。这些函数必须谨慎地保证正确使用。除了某些特殊的底层应用，使用通道或者sync包的函数/类型实现同步更好。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——网络编程</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wang-luo-bian-cheng/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——网络编程"><a href="#Go语言基础——网络编程" class="headerlink" title="Go语言基础——网络编程"></a>Go语言基础——网络编程</h1><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><h2 id="socket图解"><a href="#socket图解" class="headerlink" title="socket图解"></a>socket图解</h2><p><code>Socket</code>是应用层与TCP/IP协议族通信的中间软件抽象层。在设计模式中，<code>Socket</code>其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在<code>Socket</code>后面，对用户来说只需要调用Socket规定的相关函数，让<code>Socket</code>去组织符合指定的协议数据然后进行通信。</p><p><img src="https://www.liwenzhou.com/images/Go/socket/socket.png" alt="socket图解"></p><h2 id="Go语言实现TCP通信"><a href="#Go语言实现TCP通信" class="headerlink" title="Go语言实现TCP通信"></a>Go语言实现TCP通信</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题。</p><h3 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h3><p>一个TCP服务端可以同时连接很多个客户端，例如世界各地的用户使用自己电脑上的浏览器访问淘宝网。因为Go语言中创建多个goroutine实现并发非常方便和高效，所以我们可以每建立一次链接就创建一个goroutine去处理。</p><p>TCP服务端程序的处理流程：</p><ol><li>监听端口</li><li>接收客户端请求建立链接</li><li>创建goroutine处理链接。</li></ol><p>我们使用Go语言的net包实现的TCP服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// tcp/server/main.go</span><span class="token comment">// TCP server端</span><span class="token comment">// 处理函数</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭连接</span><span class="token keyword">for</span> <span class="token punctuation">{</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token builtin">byte</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 读取数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read from client failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>recvStr <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client端发来的数据："</span><span class="token punctuation">,</span> recvStr<span class="token punctuation">)</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>recvStr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:20000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 建立连接</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span> <span class="token comment">// 启动一个goroutine处理连接</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码保存之后编译成<code>server</code>或<code>server.exe</code>可执行文件。</p><h3 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h3><p>一个TCP客户端进行TCP通信的流程如下：</p><ol><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><p>使用Go语言的net包实现的TCP客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// tcp/client/main.go</span><span class="token comment">// 客户端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:20000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"err :"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 关闭连接</span>inputReader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>input<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> inputReader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">// 读取用户输入</span>inputInfo <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Trim</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token string">"\r\n"</span><span class="token punctuation">)</span><span class="token keyword">if</span> strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>inputInfo<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"Q"</span> <span class="token punctuation">{</span> <span class="token comment">// 如果输入q就退出</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>inputInfo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span>buf <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> conn<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"recv failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码编译成<code>client</code>或<code>client.exe</code>可执行文件，先启动server端再启动client端，在client端输入任意内容回车之后就能够在server端看到client端发送的数据，从而实现TCP通信。</p><h2 id="TCP黏包"><a href="#TCP黏包" class="headerlink" title="TCP黏包"></a>TCP黏包</h2><h3 id="黏包示例"><a href="#黏包示例" class="headerlink" title="黏包示例"></a>黏包示例</h3><p>服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/server/main.go</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">for</span> <span class="token punctuation">{</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read from client failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>recvStr <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client发来的数据："</span><span class="token punctuation">,</span> recvStr<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/client/main.go</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial failed, err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>msg <span class="token operator">:=</span> <span class="token string">`Hello, Hello. How are you?`</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的代码保存后，分别编译。先启动服务端再启动客户端，可以看到服务端输出结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?Hello, Hello. How are you?收到client发来的数据： Hello, Hello. How are you?Hello, Hello. How are you?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端分10次发送的数据，在服务端并没有成功的输出10次，而是多条数据“粘”到了一起。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>主要原因就是tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol><li>由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。</li></ol><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><p>我们可以自己定义一个协议，比如数据包的前4个字节为包头，里面存储的是发送的数据的长度。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/proto/proto.go</span><span class="token keyword">package</span> proto<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"bytes"</span><span class="token string">"encoding/binary"</span><span class="token punctuation">)</span><span class="token comment">// Encode 将消息编码</span><span class="token keyword">func</span> <span class="token function">Encode</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 读取消息的长度，转换成int32类型（占4个字节）</span><span class="token keyword">var</span> length <span class="token operator">=</span> <span class="token function">int32</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">var</span> pkg <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>bytes<span class="token punctuation">.</span>Buffer<span class="token punctuation">)</span><span class="token comment">// 写入消息头</span>err <span class="token operator">:=</span> binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// 写入消息实体</span>err <span class="token operator">=</span> binary<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token keyword">return</span> pkg<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token comment">// Decode 解码消息</span><span class="token keyword">func</span> <span class="token function">Decode</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 读取消息的长度</span>lengthByte<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">Peek</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// 读取前4个字节的数据</span>lengthBuff <span class="token operator">:=</span> bytes<span class="token punctuation">.</span><span class="token function">NewBuffer</span><span class="token punctuation">(</span>lengthByte<span class="token punctuation">)</span><span class="token keyword">var</span> length <span class="token builtin">int32</span>err <span class="token operator">:=</span> binary<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>lengthBuff<span class="token punctuation">,</span> binary<span class="token punctuation">.</span>LittleEndian<span class="token punctuation">,</span> <span class="token operator">&amp;</span>length<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// Buffered返回缓冲中现有的可读取的字节数。</span><span class="token keyword">if</span> <span class="token function">int32</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">Buffered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token operator">+</span><span class="token number">4</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token comment">// 读取真正的消息数据</span>pack <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">+</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>pack<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> err<span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token function">string</span><span class="token punctuation">(</span>pack<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来在服务端和客户端分别使用上面定义的<code>proto</code>包的<code>Decode</code>和<code>Encode</code>函数处理数据。</p><p>服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/server2/main.go</span><span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>conn net<span class="token punctuation">.</span>Conn<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>msg<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"decode msg failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"收到client发来的数据："</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Listen</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">Accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"accept failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token keyword">go</span> <span class="token function">process</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// socket_stick/client2/main.go</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span><span class="token string">"tcp"</span><span class="token punctuation">,</span> <span class="token string">"127.0.0.1:30000"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"dial failed, err"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> conn<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>msg <span class="token operator">:=</span> <span class="token string">`Hello, Hello. How are you?`</span>data<span class="token punctuation">,</span> err <span class="token operator">:=</span> proto<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"encode msg failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>conn<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Go语言实现UDP通信"><a href="#Go语言实现UDP通信" class="headerlink" title="Go语言实现UDP通信"></a>Go语言实现UDP通信</h2><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种<strong>无连接</strong>的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><h3 id="UDP服务端"><a href="#UDP服务端" class="headerlink" title="UDP服务端"></a>UDP服务端</h3><p>使用Go语言的<code>net</code>包实现的UDP服务端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// UDP/server/main.go</span><span class="token comment">// UDP server端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>listen<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">ListenUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>UDPAddr<span class="token punctuation">{</span>IP<span class="token punctuation">:</span>   net<span class="token punctuation">.</span><span class="token function">IPv4</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Port<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"listen failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> listen<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token keyword">var</span> data <span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token builtin">byte</span>n<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> err <span class="token operator">:=</span> listen<span class="token punctuation">.</span><span class="token function">ReadFromUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 接收数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read udp failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"data:%v addr:%v count:%v\n"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> listen<span class="token punctuation">.</span><span class="token function">WriteToUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span> addr<span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write to udp failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="UDP客户端"><a href="#UDP客户端" class="headerlink" title="UDP客户端"></a>UDP客户端</h3><p>使用Go语言的<code>net</code>包实现的UDP客户端代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// UDP 客户端</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>socket<span class="token punctuation">,</span> err <span class="token operator">:=</span> net<span class="token punctuation">.</span><span class="token function">DialUDP</span><span class="token punctuation">(</span><span class="token string">"udp"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>net<span class="token punctuation">.</span>UDPAddr<span class="token punctuation">{</span>IP<span class="token punctuation">:</span>   net<span class="token punctuation">.</span><span class="token function">IPv4</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>Port<span class="token punctuation">:</span> <span class="token number">30000</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"连接服务端失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> socket<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>sendData <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello server"</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>sendData<span class="token punctuation">)</span> <span class="token comment">// 发送数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"发送数据失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">4096</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> remoteAddr<span class="token punctuation">,</span> err <span class="token operator">:=</span> socket<span class="token punctuation">.</span><span class="token function">ReadFromUDP</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment">// 接收数据</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"接收数据失败，err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"recv:%v addr:%v count:%v\n"</span><span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remoteAddr<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——数组与切片</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-shu-zu-yu-qie-pian/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-shu-zu-yu-qie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——数组与切片"><a href="#Go语言基础——数组与切片" class="headerlink" title="Go语言基础——数组与切片"></a>Go语言基础——数组与切片</h1><h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>数组是同一种数据类型元素的集合。 在Go语言中，数组从声明时就确定，使用时可以修改数组成员，但是数组大小不可变化。 基本语法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 定义一个长度为3元素类型为int的数组a</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="数组定义："><a href="#数组定义：" class="headerlink" title="数组定义："></a>数组定义：</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">var 数组变量名 <span class="token punctuation">[</span>元素数量<span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>比如：<code>var a [5]int</code>， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。 <code>[5]int</code>和<code>[10]int</code>是不同的类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span>a <span class="token operator">=</span> b <span class="token comment">//不可以这样做，因为此时a和b是不同的类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>数组可以通过下标进行访问，下标是从<code>0</code>开始，最后一个元素下标是：<code>len-1</code>，访问越界（下标在合法范围之外），则触发访问越界，会panic。</p><h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><p>数组的初始化也有很多方式。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>初始化数组时可以使用初始化列表来设置数组元素的值。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span>                        <span class="token comment">//数组会初始化为int类型的零值</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span>                 <span class="token comment">//使用指定的初始值完成初始化</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span> <span class="token comment">//使用指定的初始值完成初始化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                      <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                       <span class="token comment">//[1 2 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                      <span class="token comment">//[北京 上海 深圳]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>按照上面的方法每次都要确保提供的初始值和数组长度一致，一般情况下我们可以让编译器根据初始值的个数自行推断数组的长度，例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> testArray <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">var</span> numArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token keyword">var</span> cityArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>testArray<span class="token punctuation">)</span>                          <span class="token comment">//[0 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>numArray<span class="token punctuation">)</span>                           <span class="token comment">//[1 2]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of numArray:%T\n"</span><span class="token punctuation">,</span> numArray<span class="token punctuation">)</span>   <span class="token comment">//type of numArray:[2]int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>cityArray<span class="token punctuation">)</span>                          <span class="token comment">//[北京 上海 深圳]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of cityArray:%T\n"</span><span class="token punctuation">,</span> cityArray<span class="token punctuation">)</span> <span class="token comment">//type of cityArray:[3]string</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>我们还可以使用指定索引值的方式来初始化数组，例如:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>                  <span class="token comment">// [0 1 0 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"type of a:%T\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment">//type of a:[4]int</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>遍历数组a有以下两种方法：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"北京"</span><span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">}</span><span class="token comment">// 方法1：for循环遍历</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 方法2：for range遍历</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> a <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">arraySum</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>    sum <span class="token operator">:=</span> <span class="token number">0</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> x<span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> v    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个求和函数只能接受<code>[3]int</code>类型，其他的都不支持。 再比如，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。</p><h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含<code>地址</code>、<code>长度</code>和<code>容量</code>。切片一般用于快速地操作一块数据集合。</p><h2 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h2><p>声明切片类型的基本语法如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，</p><ul><li>name:表示变量名</li><li>T:表示切片中的元素类型</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 声明切片类型</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>              <span class="token comment">//声明一个字符串切片</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>             <span class="token comment">//声明一个整型切片并初始化</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token comment">//声明一个布尔切片并初始化</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span> <span class="token comment">//声明一个布尔切片并初始化</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>              <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>              <span class="token comment">//[]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>              <span class="token comment">//[false true]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//true</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//false</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>       <span class="token comment">//false</span><span class="token comment">// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片拥有自己的长度和容量，我们可以通过使用内置的<code>len()</code>函数求长度，使用内置的<code>cap()</code>函数求切片的容量。</p><h3 id="切片表达式"><a href="#切片表达式" class="headerlink" title="切片表达式"></a>切片表达式</h3><p>切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。</p><h4 id="简单切片表达式"><a href="#简单切片表达式" class="headerlink" title="简单切片表达式"></a>简单切片表达式</h4><p>切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的<code>low</code>和<code>high</code>表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出<code>1&lt;=索引值&lt;4</code>的元素组成切片s，得到的切片<code>长度=high-low</code>，容量等于得到的切片的底层数组的容量。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>s <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// s := a[low:high]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s:%v len(s):%v cap(s):%v\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为了方便起见，可以省略切片表达式中的任何索引。省略了<code>low</code>则默认为0；省略了<code>high</code>则默认为切片操作数的长度:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[2:len(a)]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// 等同于 a[0:3]</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment">// 等同于 a[0:len(a)]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>对于数组或字符串，如果<code>0 &lt;= low &lt;= high &lt;= len(a)</code>，则索引合法，否则就会索引越界（out of range）。</p><p>对切片再执行切片表达式时（切片再切片），<code>high</code>的上限边界是切片的容量<code>cap(a)</code>，而不是长度。<strong>常量索引</strong>必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果<code>low</code>和<code>high</code>两个指标都是常数，它们必须满足<code>low &lt;= high</code>。如果索引在运行时超出范围，就会发生运行时<code>panic</code>。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>s <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">// s := a[low:high]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s:%v len(s):%v cap(s):%v\n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>s2 <span class="token operator">:=</span> s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>  <span class="token comment">// 索引的上限是cap(s)而不是len(s)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"s2:%v len(s2):%v cap(s2):%v\n"</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">s:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>s<span class="token punctuation">)</span>:4s2:<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>:1 cap<span class="token punctuation">(</span>s2<span class="token punctuation">)</span>:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="完整切片表达式"><a href="#完整切片表达式" class="headerlink" title="完整切片表达式"></a>完整切片表达式</h4><p>对于数组，指向数组的指针，或切片a(<strong>注意不能是字符串</strong>)支持完整切片表达式：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">a<span class="token punctuation">[</span>low <span class="token punctuation">:</span> high <span class="token punctuation">:</span> max<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的代码会构造与简单切片表达式<code>a[low: high]</code>相同类型、相同长度和元素的切片。另外，它会将得到的结果切片的容量设置为<code>max-low</code>。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>t <span class="token operator">:=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"t:%v len(t):%v cap(t):%v\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">t:<span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>:2 cap<span class="token punctuation">(</span>t<span class="token punctuation">)</span>:4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>完整切片表达式需要满足的条件是<code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，其他条件和简单切片表达式相同。</p><h3 id="使用make-函数构造切片"><a href="#使用make-函数构造切片" class="headerlink" title="使用make()函数构造切片"></a>使用make()函数构造切片</h3><p>我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的<code>make()</code>函数，格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">make<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T, size, cap<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>T:切片的元素类型</li><li>size:切片中元素的数量</li><li>cap:切片的容量</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>      <span class="token comment">//[0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">cap</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//10</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码中<code>a</code>的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以<code>len(a)</code>返回2，<code>cap(a)</code>则返回该切片的容量。</p><h3 id="切片的本质"><a href="#切片的本质" class="headerlink" title="切片的本质"></a>切片的本质</h3><p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</p><p>举个例子，现在有一个数组<code>a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}</code>，切片<code>s1 := a[:5]</code>，相应示意图如下。<img src="https://www.liwenzhou.com/images/Go/slice/slice_01.png" alt="slice_01">切片<code>s2 := a[3:6]</code>，相应示意图如下：<img src="https://www.liwenzhou.com/images/Go/slice/slice_02.png" alt="slice_02"></p><h3 id="判断切片是否为空"><a href="#判断切片是否为空" class="headerlink" title="判断切片是否为空"></a>判断切片是否为空</h3><p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>来判断，而不应该使用<code>s == nil</code>来判断。</p><h2 id="切片不能直接比较"><a href="#切片不能直接比较" class="headerlink" title="切片不能直接比较"></a>切片不能直接比较</h2><p>切片之间是不能比较的，我们不能使用<code>==</code>操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和<code>nil</code>比较。 一个<code>nil</code>值的切片并没有底层数组，一个<code>nil</code>值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是<code>nil</code>，例如下面的示例：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>         <span class="token comment">//len(s1)=0;cap(s1)=0;s1==nil</span>s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment">//len(s2)=0;cap(s2)=0;s2!=nil</span>s3 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//len(s3)=0;cap(s3)=0;s3!=nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以要判断一个切片是否是空的，要是用<code>len(s) == 0</code>来判断，不应该使用<code>s == nil</code>来判断。</p><h2 id="切片的赋值拷贝"><a href="#切片的赋值拷贝" class="headerlink" title="切片的赋值拷贝"></a>切片的赋值拷贝</h2><p>下面的代码中演示了拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment">//[0 0 0]</span>s2 <span class="token operator">:=</span> s1             <span class="token comment">//将s1直接赋值给s2，s1和s2共用一个底层数组</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token comment">//[100 0 0]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token comment">//[100 0 0]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片遍历"><a href="#切片遍历" class="headerlink" title="切片遍历"></a>切片遍历</h2><p>切片的遍历方式和数组是一致的，支持索引遍历和<code>for range</code>遍历。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> index<span class="token punctuation">,</span> value <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="append-方法为切片添加元素"><a href="#append-方法为切片添加元素" class="headerlink" title="append()方法为切片添加元素"></a>append()方法为切片添加元素</h2><p>Go语言的内建函数<code>append()</code>可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，也可以添加另一个切片中的元素（后面加…）。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token comment">// [1]</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment">// [1 2 3 4]</span>s2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">}</span>  s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token comment">// [1 2 3 4 5 6 7]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>通过var声明的零值切片可以在<code>append()</code>函数直接使用，无需初始化。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>没有必要像下面的代码一样初始化一个切片再传入<code>append()</code>函数使用，</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 没有必要初始化</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>  <span class="token comment">// 没有必要初始化</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。“扩容”操作往往发生在<code>append()</code>函数调用时，所以我们通常都需要用原变量接收append函数的返回值。</p><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//append()添加元素和切片扩容</span><span class="token keyword">var</span> numSlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>numSlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">,</span> i<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v  len:%d  cap:%d  ptr:%p\n"</span><span class="token punctuation">,</span> numSlice<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>numSlice<span class="token punctuation">)</span><span class="token punctuation">,</span> numSlice<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  len:1  cap:1  ptr:0xc0000a8000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">]</span>  len:2  cap:2  ptr:0xc0000a8040<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>  len:3  cap:4  ptr:0xc0000b2020<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span>  len:4  cap:4  ptr:0xc0000b2020<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span>  len:5  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span><span class="token punctuation">]</span>  len:6  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span>  len:7  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span><span class="token punctuation">]</span>  len:8  cap:8  ptr:0xc0000b6000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span>  len:9  cap:16  ptr:0xc0000b8000<span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">]</span>  len:10  cap:16  ptr:0xc0000b8000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的结果可以看出：</p><ol><li><code>append()</code>函数将元素追加到切片的最后并返回该切片。</li><li>切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。</li></ol><p>append()函数还支持一次性追加多个元素。 例如：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> citySlice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token comment">// 追加一个元素</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> <span class="token string">"北京"</span><span class="token punctuation">)</span><span class="token comment">// 追加多个元素</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> <span class="token string">"上海"</span><span class="token punctuation">,</span> <span class="token string">"广州"</span><span class="token punctuation">,</span> <span class="token string">"深圳"</span><span class="token punctuation">)</span><span class="token comment">// 追加切片</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token string">"成都"</span><span class="token punctuation">,</span> <span class="token string">"重庆"</span><span class="token punctuation">}</span>citySlice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">,</span> a<span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>citySlice<span class="token punctuation">)</span> <span class="token comment">//[北京 上海 广州 深圳 成都 重庆]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="切片的扩容策略"><a href="#切片的扩容策略" class="headerlink" title="切片的扩容策略"></a>切片的扩容策略</h2><p>可以通过查看<code>$GOROOT/src/runtime/slice.go</code>源码，其中扩容相关代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">newcap <span class="token operator">:=</span> old<span class="token punctuation">.</span><span class="token builtin">cap</span>doublecap <span class="token operator">:=</span> newcap <span class="token operator">+</span> newcap<span class="token keyword">if</span> <span class="token builtin">cap</span> <span class="token operator">&gt;</span> doublecap <span class="token punctuation">{</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">if</span> old<span class="token punctuation">.</span><span class="token builtin">len</span> <span class="token operator">&lt;</span> <span class="token number">1024</span> <span class="token punctuation">{</span>newcap <span class="token operator">=</span> doublecap<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// Check 0 &lt; newcap to detect overflow</span><span class="token comment">// and prevent an infinite loop.</span><span class="token keyword">for</span> <span class="token number">0</span> <span class="token operator">&lt;</span> newcap <span class="token operator">&amp;&amp;</span> newcap <span class="token operator">&lt;</span> <span class="token builtin">cap</span> <span class="token punctuation">{</span>newcap <span class="token operator">+=</span> newcap <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token comment">// Set newcap to the requested cap when</span><span class="token comment">// the newcap calculation overflowed.</span><span class="token keyword">if</span> newcap <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>newcap <span class="token operator">=</span> <span class="token builtin">cap</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的代码可以看出以下内容：</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。</li><li>否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。</li></ul><p><strong>需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如<code>int</code>和<code>string</code>类型的处理方式就不一样。</strong></p><h2 id="使用copy-函数复制切片"><a href="#使用copy-函数复制切片" class="headerlink" title="使用copy()函数复制切片"></a>使用copy()函数复制切片</h2><p>首先我们来看一个问题：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>b <span class="token operator">:=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。</strong></p><p>Go语言内建的<code>copy()</code>函数可以迅速地将一个切片的数据复制到另外一个切片空间中，<code>copy()</code>函数的使用格式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">copy<span class="token punctuation">(</span>destSlice, srcSlice <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中：</p><ul><li>srcSlice: 数据来源切片</li><li>destSlice: 目标切片</li></ul><p>举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// copy()复制切片</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span>c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">)</span>     <span class="token comment">//使用copy()函数将切片a中的元素复制到切片c</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1000</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[1 2 3 4 5]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">//[1000 2 3 4 5]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="从切片中删除元素"><a href="#从切片中删除元素" class="headerlink" title="从切片中删除元素"></a>从切片中删除元素</h2><p>Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 从切片中删除元素</span>a <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">}</span><span class="token comment">// 要删除索引为2的元素</span>a <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//[30 31 33 34 35 36 37]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结一下就是：要从切片a中删除索引为<code>index</code>的元素，操作方法是<code>a = append(a[:index], a[index+1:]...)</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础——文件操作</title>
      <link href="/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wen-jian-cao-zuo/"/>
      <url>/zhb233go.github.io/2021/11/24/go-yu-yan-ji-chu-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言基础——文件操作"><a href="#Go语言基础——文件操作" class="headerlink" title="Go语言基础——文件操作"></a>Go语言基础——文件操作</h1><h1 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h1><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token comment">// 关闭文件</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><h2 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>Read方法定义如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>File<span class="token punctuation">)</span> <span class="token function">Read</span><span class="token punctuation">(</span>b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 使用Read方法读取数据</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"读取了%d字节数据\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h3><p>使用for循环读取文件中的所有数据。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 只读方式打开当前目录下的main.go文件</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed!, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 循环读取文件</span><span class="token keyword">var</span> content <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token keyword">var</span> tmp <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>n<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>content <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h2><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"fmt"</span><span class="token string">"io"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token comment">// bufio按行读取示例</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">{</span>line<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">//注意是字符</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完了"</span><span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h2><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"io/ioutil"</span><span class="token punctuation">)</span><span class="token comment">// ioutil.ReadFile读取整个文件</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./main.go"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h1><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">OpenFile</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> flag <span class="token builtin">int</span><span class="token punctuation">,</span> perm FileMode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>File<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中：</p><p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h2 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>str <span class="token operator">:=</span> <span class="token string">"hello 沙河"</span>file<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">//写入字节切片数据</span>file<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"hello 小王子"</span><span class="token punctuation">)</span> <span class="token comment">//直接写入字符串数据</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token operator">|</span>os<span class="token punctuation">.</span>O_WRONLY<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"open file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>writer <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>writer<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"hello沙河\n"</span><span class="token punctuation">)</span> <span class="token comment">//将数据先写入缓存</span><span class="token punctuation">}</span>writer<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//将缓存中的内容写入文件</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>str <span class="token operator">:=</span> <span class="token string">"hello 沙河"</span>err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h2><p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// CopyFile 拷贝文件函数</span><span class="token keyword">func</span> <span class="token function">CopyFile</span><span class="token punctuation">(</span>dstName<span class="token punctuation">,</span> srcName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 以读方式打开源文件</span>src<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>srcName<span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open %s failed, err:%v.\n"</span><span class="token punctuation">,</span> srcName<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> src<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 以写|创建的方式打开目标文件</span>dst<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span>dstName<span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_WRONLY<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open %s failed, err:%v.\n"</span><span class="token punctuation">,</span> dstName<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">defer</span> dst<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> io<span class="token punctuation">.</span><span class="token function">Copy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span> src<span class="token punctuation">)</span> <span class="token comment">//调用io.Copy()拷贝内容</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">CopyFile</span><span class="token punctuation">(</span><span class="token string">"dst.txt"</span><span class="token punctuation">,</span> <span class="token string">"src.txt"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"copy file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"copy done!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h2><p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"bufio"</span><span class="token string">"flag"</span><span class="token string">"fmt"</span><span class="token string">"io"</span><span class="token string">"os"</span><span class="token punctuation">)</span><span class="token comment">// cat命令实现</span><span class="token keyword">func</span> <span class="token function">cat</span><span class="token punctuation">(</span>r <span class="token operator">*</span>bufio<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span>buf<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">ReadBytes</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment">//注意是字符</span><span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span><span class="token comment">// 退出之前将已读到的内容输出</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token keyword">break</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 解析命令行参数</span><span class="token keyword">if</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span><span class="token comment">// 如果没有参数默认从标准输入读取内容</span><span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment">// 依次读取每个指定文件的内容并打印到终端</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flag<span class="token punctuation">.</span><span class="token function">NArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>f<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdout<span class="token punctuation">,</span> <span class="token string">"reading from %s failed, err:%v\n"</span><span class="token punctuation">,</span> flag<span class="token punctuation">.</span><span class="token function">Arg</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">}</span><span class="token function">cat</span><span class="token punctuation">(</span>bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天必逛且可以提升技术能力的网址</title>
      <link href="/zhb233go.github.io/2021/11/23/12-mei-tian-bi-guang-qie-ke-yi-ti-sheng-ji-zhu-neng-li-de-wang-zhi/"/>
      <url>/zhb233go.github.io/2021/11/23/12-mei-tian-bi-guang-qie-ke-yi-ti-sheng-ji-zhu-neng-li-de-wang-zhi/</url>
      
        <content type="html"><![CDATA[<p>1.<a href="https://www.ruanyifeng.com/blog/">阮一峰的网络日志</a> 一个技术大佬创建的博客，里面有他每周周刊，可最新的技术和推荐文章</p><p>2.<a href="https://www.liwenzhou.com/">李文周的博客</a> 刚入go语言就会搜的博主，里面有他整理的有关go语言的系列教程，跟着学不迷路</p><p>3.<a href="https://github.com/avelino/awesome-go">awsome-go</a> github上星标最多的项目，上面有最全的go项目列表，站在巨人们的肩膀上，学习项目经验</p><p>4.<a href="https://roadmap.sh/roadmaps">开发者路线图</a> 可以了解一想要发展的学习路线，为你的开发前程指明道路<br>以下是golang的学习路线图:<br><img src="https://roadmap.sh/roadmaps/golang.png" alt="golang的学习路线图" title="golang"><br>5.<a href="https://news.ycombinator.com/news">Hacker News</a> 一个国外IT技术文章发布平台，可了解一些技术知识</p><p>6.<a href="https://gobyexample.com/">GoByExample</a> 一个通过go示例学习的网站</p><p>7.<a href="https://zh-style-guide.readthedocs.io/zh_CN/latest/index.html">中文技术文档写作风格指南</a> 一个指导如何书写中文文档的技术网站，为标准化的写作风格培养习惯</p><p>8.<a href="https://www.runoob.com/">菜鸟教程</a> 一个强烈推荐的软件开发初学者教学网站，网站全免费并且教学专业，通俗易懂，技术栈全覆盖</p><p>9.<a href="https://leetcode-cn.com/">Leetcode</a> 一个学软件编程必须要来的网站，上面可以看到许多大厂的面试题并且可以一边学习一边刷题，可以学习数据结构和算法，从基础开始打牢，经常逛逛去大厂机会大大增加</p><p>10.<a href="https://www.digitalocean.com/community">digitalocean</a> 一个技术开发论坛，上面有许多语言教程，非常专业</p><p>11.<a href="https://www.jianshu.com/techareas/backend">简书</a> 一个小型的技术博客发布平台</p><p>12.<a href="https://juejin.cn/">稀土掘金</a> 一个和简书相似的发布平台，比简书稍大</p><p>13.<a href="https://segmentfault.com/">segmentfault</a> 一个开发者社区</p><p>14.<a href="https://www.cnblogs.com/">博客园</a> 属于中国早期的技术博客平台，技术博客主的资历也最老，上面有许多经验资深的博客发布的文章</p><p>15.<a href="https://www.yuque.com/">语雀</a> 同样是博客发布平台</p><p>16.<a href="https://free-for.dev/#/?id=free-fordev">free-for.dev</a> 一个开发者免费的项目支持，前期可在上面寻找项目支持</p><p>17.<a href="https://www.sina.com.cn/">新浪网</a> 了解新闻、资讯、科技等动向</p><p>18.<a href="https://www.yii3.cn/">易三文档</a> 一个有几个使用的开发使用便捷手册</p><p>19.<a href="http://www.cyc2018.xyz/">CS-Notes</a> 技术面试必备基础知识、Leetcode、计算机操作系统、计算机网络、系统设计</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值得收藏的网站</title>
      <link href="/zhb233go.github.io/2021/11/23/11-zhi-de-shou-cang-de-wang-zhan/"/>
      <url>/zhb233go.github.io/2021/11/23/11-zhi-de-shou-cang-de-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="值得收藏的网站（持续更新）"><a href="#值得收藏的网站（持续更新）" class="headerlink" title="值得收藏的网站（持续更新）"></a>值得收藏的网站（持续更新）</h1><ol><li><p><a href="https://mixkit.co/">Mixkit 是一个免费图库，包含很棒的视频剪辑、音乐曲目、音效和视频模板。</a></p></li><li><p><a href="https://pic.netbian.com/">彼岸图网是一个4K图纸下载网站，每天能下载一张免费4K壁纸</a></p></li><li><p><a href="https://www.lofi.cafe/">lofi.cafe是一个很棒国外电台网站，能在工作学习之余听听音乐，轻音乐为主</a></p></li><li><p><a href="https://sample-videos.com/index.php#sample-mp4-video">一个免费示例视频网站，各种格式都有</a></p></li><li><p><a href="http://oskarstalberg.com/game/house/index.html">一个沙盒解压小游戏</a></p></li><li><p><a href="https://fuun.fun/">一个趣味网站大集合的网址</a></p></li><li><p><a href="https://www.flickr.com/photos/biodivlibrary/">一个可以观看动物插图的网站</a></p></li><li><p><a href="https://bruno-simon.com/">一个有趣的3D模型的网站</a></p></li><li><p><a href="https://www.nocsdegree.com/">一个收集其他职业的人自学成为软件工程师采访的网站，学习其他人的经验</a></p></li><li><p><a href="https://gifcities.org/">GifCities 是互联网档案馆的一个特殊项目，旨在庆祝网络保存 20 周年。Internet Archive 是一个非营利性数字图书馆，其中包含数百万本免费书籍、电影、软件、音乐、网站等。</a></p></li><li><p><a href="https://ptable.com/#%E6%80%A7%E8%B4%A8">一个化学周期表的互动网站，有助理解化学元素</a></p></li><li><p><a href="https://typlog.com/podlist/">收集高质量的中文博客的网站</a></p></li><li><p><a href="https://www.indiehackers.com/">一个很棒的IT交流网站，上面有各种技术人员在上面发表文章</a></p></li><li><p><a href="https://blog.usepastel.com/post/33-beautiful-free-icon-sets">33 个具有漂亮免费图标集的网站</a></p></li><li><p><a href="https://www.veer.com/?utm_source=biantuwang&amp;chid=600">veer.com是一个提供免费插图的网站</a></p></li><li><p><a href="https://colorfu.art/editor">一个可以便捷制作大头报图的网站</a></p></li><li><p><a href="https://vididoo.vercel.app/">一个在线快捷处理音视频的网站</a></p></li><li><p><a href="https://landgreen.github.io/physics/index.html">一个在线高中物理要点讲解，配有插图和动画。</a></p></li></ol><p>19.<a href="http://www.progressfocused.com/">一个大学心理学教授的博客，可以学习有用的心理学小知识</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成功所需的 5 种文案写作技巧</title>
      <link href="/zhb233go.github.io/2021/11/23/10-cheng-gong-suo-xu-de-5-chong-wen-an-xie-zuo-ji-qiao/"/>
      <url>/zhb233go.github.io/2021/11/23/10-cheng-gong-suo-xu-de-5-chong-wen-an-xie-zuo-ji-qiao/</url>
      
        <content type="html"><![CDATA[<h1 id="成功所需的-5-种文案写作技巧"><a href="#成功所需的-5-种文案写作技巧" class="headerlink" title="成功所需的 5 种文案写作技巧"></a>成功所需的 5 种文案写作技巧</h1><h2 id="文案撰稿人需要什么技能？"><a href="#文案撰稿人需要什么技能？" class="headerlink" title="文案撰稿人需要什么技能？"></a>文案撰稿人需要什么技能？</h2><p><a href="https://matgillard.com/?source=post_page-----a7be60065eb4-----------------------------------"><img src="https://miro.medium.com/fit/c/96/96/1*VP5ZfM9aHJL7d7x3_ITVTQ.jpeg" alt="马特吉拉德"></a></p><p><a href="https://matgillard.com/?source=post_page-----a7be60065eb4-----------------------------------">马特吉拉德</a><a href="https://medium.com/m/signin?actionUrl=https://medium.com/_/subscribe/user/9ef1cfb5557/a7be60065eb4&amp;operation=register&amp;redirect=https://goodcopywriting.com/5-copywriting-skills-you-need-to-succeed-a7be60065eb4&amp;user=Mat+Gillard&amp;userId=9ef1cfb5557&amp;source=post_page-9ef1cfb5557----a7be60065eb4---------------------follow_byline--------------">跟随</a></p><p><a href="https://goodcopywriting.com/5-copywriting-skills-you-need-to-succeed-a7be60065eb4?source=post_page-----a7be60065eb4-----------------------------------">11 月 23 日</a> · 2分钟阅读</p><p><img src="https://miro.medium.com/max/1400/1*iAg35spPJaEcUtsCcLA9kg.jpeg" alt="img"></p><p>您是否需要任何特殊的资格或技能才能成为一名撰稿人？</p><p>绝对不！</p><p>成为一名成功的撰稿人不需要正式的资格。要成为一名出色的文案撰稿人，您需要具有创造力、独立性以及良好的沟通技巧和知识，或者对销售和营销有个人兴趣。</p><p>尽管如此，以下五项技能将使您更轻松地生成成功和有效的副本。</p><h1 id="英语语言技能"><a href="#英语语言技能" class="headerlink" title="英语语言技能"></a>英语语言技能</h1><p>高水平的英语语言技能是必须的。读者经常寻找使用正确句子结构、单词选择、语法和拼写的副本。</p><p>作为文案，您还应该密切注意标点符号。</p><p>有大量免费网站可以帮助您在需要时提高英语技能。广泛阅读对建立词汇量也很有帮助。</p><h1 id="注重细节"><a href="#注重细节" class="headerlink" title="注重细节"></a>注重细节</h1><p>而且，除了英语语言技能外，您还需要能够发现工作中的错误。</p><p>在发送给客户或上传给读者之前，您的副本应尽可能无错误。</p><p>很多时候，作为一名自由撰稿人，您将成为自己的校对员和文案编辑，因此需要对细节有敏锐的洞察力。</p><h1 id="研究能力"><a href="#研究能力" class="headerlink" title="研究能力"></a>研究能力</h1><p>知道如何对您想写的主题进行彻底的研究、调查和批判性分析。</p><p>当然，互联网和现代技术通过使其更快、更容易来简化流程。</p><p>当您想了解您的客户和目标受众时，出色的研究技能也适用。</p><p>如果您知道如何以及在哪里找到它，那么您可以在互联网和书籍上找到的内容是无限的。</p><h1 id="大词汇"><a href="#大词汇" class="headerlink" title="大词汇"></a>大词汇</h1><p>广泛的词汇是有帮助的。重要的是在你的文案中使用各种各样的词，而不是相同的陈词滥调。</p><p>但在某些情况下，您可能必须坚持使用常见的和经过测试的词，尤其是在想要获得强有力的标题时。</p><p>不要重复相同的词，尤其是在同一段落中。</p><p>作为初学者，同义词库是开始寻找替代词的好地方。</p><h1 id="能够看到不同的观点"><a href="#能够看到不同的观点" class="headerlink" title="能够看到不同的观点"></a>能够看到不同的观点</h1><p>作为一名文案撰稿人，沉浸在别人的故事或经历中，发挥两全其美的作用。</p><p>你的意见和他们的意见。</p><p>您必须能够仔细聆听并了解他人的观点。</p><p>当您将自己置于读者和客户的角度时，它会让您更有同理心，并尊重地分享不同的观点。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些开发问题快速解决方案</title>
      <link href="/zhb233go.github.io/2021/11/23/9-yi-xie-kai-fa-wen-ti-kuai-su-jie-jue-fang-an-lian-jie-chi-xu-geng-xin-zhong/"/>
      <url>/zhb233go.github.io/2021/11/23/9-yi-xie-kai-fa-wen-ti-kuai-su-jie-jue-fang-an-lian-jie-chi-xu-geng-xin-zhong/</url>
      
        <content type="html"><![CDATA[<h4 id="1-怎样写Markdown文件？"><a href="#1-怎样写Markdown文件？" class="headerlink" title="1.怎样写Markdown文件？"></a>1.怎样写Markdown文件？</h4><p><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown语法图文全面教程(10分钟学会)</a></p><h4 id="2-常用的git命令"><a href="#2-常用的git命令" class="headerlink" title="2.常用的git命令"></a>2.常用的git命令</h4><p><a href="https://blog.csdn.net/halaoda/article/details/78661334?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764899316780357255501%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764899316780357255501&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-78661334.pc_search_all_es&amp;utm_term=%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">Git 常用命令大全</a></p><h4 id="3-Linux常用命令"><a href="#3-Linux常用命令" class="headerlink" title="3.Linux常用命令"></a>3.Linux常用命令</h4><p><a href="https://blog.csdn.net/m0_47890251/article/details/106747543?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764919116780271972292%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764919116780271972292&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-5-106747543.pc_search_all_es&amp;utm_term=linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;spm=1018.2226.3001.4187">Linux常用命令大全（非常详细！）</a></p><h4 id="4-SSH简介及两种远程登录的方法"><a href="#4-SSH简介及两种远程登录的方法" class="headerlink" title="4.SSH简介及两种远程登录的方法"></a>4.SSH简介及两种远程登录的方法</h4><p><a href="https://blog.csdn.net/li528405176/article/details/82810342?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764956316780269858066%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764956316780269858066&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82810342.pc_search_all_es&amp;utm_term=ssh&amp;spm=1018.2226.3001.4187">SSH简介及两种远程登录的方法</a></p><h4 id="5-gpg使用方法"><a href="#5-gpg使用方法" class="headerlink" title="5.gpg使用方法"></a>5.gpg使用方法</h4><p><a href="https://blog.csdn.net/arv002/article/details/114322941?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163764968516780271533854%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163764968516780271533854&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-114322941.pc_search_all_es&amp;utm_term=gpg&amp;spm=1018.2226.3001.4187">gpg使用方法</a></p><h4 id="6-docker常用命令总结"><a href="#6-docker常用命令总结" class="headerlink" title="6.docker常用命令总结"></a>6.docker常用命令总结</h4><p><a href="https://blog.csdn.net/u013378306/article/details/86668313?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86668313.nonecase&amp;spm=1018.2226.3001.4187">docker常用命令总结</a></p><h4 id="7-官方docker简介和构建docker镜像"><a href="#7-官方docker简介和构建docker镜像" class="headerlink" title="7.官方docker简介和构建docker镜像"></a>7.官方docker简介和构建docker镜像</h4><p><a href="docker%E7%AE%80%E4%BB%8B%E5%92%8C%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F">docker简介和构建docker镜像</a></p><h4 id="8-5-个可用于改进开发过程的-Git-工作流程和分支策略"><a href="#8-5-个可用于改进开发过程的-Git-工作流程和分支策略" class="headerlink" title="8. 5 个可用于改进开发过程的 Git 工作流程和分支策略"></a>8. 5 个可用于改进开发过程的 Git 工作流程和分支策略</h4><p><a href="https://zepel.io/blog/5-git-workflows-to-improve-development/">5 个可用于改进开发过程的 Git 工作流程和分支策略</a></p><h4 id="9-理解Docker的多阶段镜像构建"><a href="#9-理解Docker的多阶段镜像构建" class="headerlink" title="9.理解Docker的多阶段镜像构建"></a>9.理解Docker的多阶段镜像构建</h4><p><a href="https://juejin.cn/post/6844903510874521608">理解Docker的多阶段镜像构建</a></p><h4 id="10-理解-gitignore文件和Dockerfile书写参考"><a href="#10-理解-gitignore文件和Dockerfile书写参考" class="headerlink" title="10.理解.gitignore文件和Dockerfile书写参考"></a>10.理解.gitignore文件和Dockerfile书写参考</h4><p><a href="https://git-scm.com/docs/gitignore">.gitignore理解</a></p><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile参考</a></p><h4 id="11-Docker-时区调整方案"><a href="#11-Docker-时区调整方案" class="headerlink" title="11.Docker 时区调整方案"></a>11.Docker 时区调整方案</h4><p><a href="https://cloud.tencent.com/developer/article/1626811">Docker 时区调整方案</a></p><h4 id="12-什么是HASH？"><a href="#12-什么是HASH？" class="headerlink" title="12.什么是HASH？"></a>12.什么是HASH？</h4><p><a href="https://blog.csdn.net/asdzheng/article/details/70226007">Hash算法总结</a></p><h4 id="13-curl的用法指南"><a href="#13-curl的用法指南" class="headerlink" title="13.curl的用法指南"></a>13.curl的用法指南</h4><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl的用法指南</a></p><p>持续更新…</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu开发环境快速安装教程</title>
      <link href="/zhb233go.github.io/2021/11/23/8-ubuntu-kai-fa-huan-jing-kuai-su-an-zhuang-jiao-cheng/"/>
      <url>/zhb233go.github.io/2021/11/23/8-ubuntu-kai-fa-huan-jing-kuai-su-an-zhuang-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu开发环境快速安装教程："><a href="#Ubuntu开发环境快速安装教程：" class="headerlink" title="Ubuntu开发环境快速安装教程："></a>Ubuntu开发环境快速安装教程：</h1><h3 id="ubuntu安装go："><a href="#ubuntu安装go：" class="headerlink" title="ubuntu安装go："></a>ubuntu安装go：</h3><p>1、下载二进制包：go1.4.linux-amd64.tar.gz。</p><p>2、将下载的二进制包解压至 /usr/local目录。</p><pre class="line-numbers language-none"><code class="language-none">tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、将 /usr/local/go/bin 目录添加至PATH环境变量：</p><pre class="line-numbers language-none"><code class="language-none">export PATH=$PATH:/usr/local/go/bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装docker："><a href="#ubuntu安装docker：" class="headerlink" title="ubuntu安装docker："></a>ubuntu安装docker：</h3><p>在终端中输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有错误则成功了。</p><p>二、安装需要的包</p><p>在终端输入命令</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install apt-transport-https ca-certificates software-properties-common curl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>没有错误则成功。<br>三、添加 GPG 密钥，并添加 Docker-ce 软件源</p><p>官方的软件源（不推荐，很慢）：</p><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https://download.docker.com/linux/ubuntu/gpg|sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>中国科技大学的 Docker-ce 源（其他源类似）：</p><pre class="line-numbers language-none"><code class="language-none">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository "deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \$(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="注意：添加错了可以用以下命令删除"><a href="#注意：添加错了可以用以下命令删除" class="headerlink" title="注意：添加错了可以用以下命令删除"></a>注意：添加错了可以用以下命令删除</h5><h5 id="查询keyid-下图"><a href="#查询keyid-下图" class="headerlink" title="查询keyid,下图"></a>查询keyid,下图</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-key list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="keyid-就是90那一串"><a href="#keyid-就是90那一串" class="headerlink" title="keyid 就是90那一串"></a>keyid 就是90那一串</h5><pre class="line-numbers language-none"><code class="language-none">sudo apt-key del &lt;keyid&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="加参数-r可以移除"><a href="#加参数-r可以移除" class="headerlink" title="加参数-r可以移除"></a>加参数-r可以移除</h5><pre class="line-numbers language-none"><code class="language-none">sudo add-apt-repository -r "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更新软件包缓存</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>四、安装 Docker-ce</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install docker-ce<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>五、测试运行</p><pre class="line-numbers language-none"><code class="language-none">sudo docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>六、添加当前用户到 docker 用户组，可以不用 sudo 运行 docker</p><p>将当前用户添加到 docker 组</p><pre class="line-numbers language-none"><code class="language-none">sudo gpasswd -a ${USER} docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新登录或者用以下命令切换到docker组</p><pre class="line-numbers language-none"><code class="language-none">newgrp - docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重启docker服务</p><pre class="line-numbers language-none"><code class="language-none">sudo service docker restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不加sudo直接执行docker命令检查效果</p><pre class="line-numbers language-none"><code class="language-none">docker ps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装git："><a href="#ubuntu安装git：" class="headerlink" title="ubuntu安装git："></a>ubuntu安装git：</h3><h5 id="Linux-平台上安装"><a href="#Linux-平台上安装" class="headerlink" title="Linux 平台上安装"></a>Linux 平台上安装</h5><p>Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。</p><p>在有 yum 的系统上（比如 Fedora）或者有 apt-get 的系统上（比如 Debian 体系），可以用下面的命令安装：</p><p>各 Linux 系统可以使用其安装包管理工具（apt-get、yum 等）进行安装：</p><h5 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h5><p>Debian/Ubuntu Git 安装命令为：</p><pre class="line-numbers language-none"><code class="language-none">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \  libz-dev libssl-dev$ apt-get install git$ git --versiongit version 1.8.1.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ubuntu安装goland："><a href="#ubuntu安装goland：" class="headerlink" title="ubuntu安装goland："></a>ubuntu安装goland：</h3><h5 id="goland安装"><a href="#goland安装" class="headerlink" title="goland安装"></a>goland安装</h5><ol><li>下载goland<br><a href="https://www.jetbrains.com/go/download/#section=linux">Goland下载链接</a></li><li>cd到安装包目录，移动并解压</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">tar</span> -zxvf goland-2020.3.4.tar.gz -C /usr/local/ <span class="token comment">#包的名字自行修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>启动Goland</li></ol><p><img src="https://img-blog.csdnimg.cn/20210320104439418.png" alt="在这里插入图片描述"></p><h3 id="ubuntu安装google-chorme："><a href="#ubuntu安装google-chorme：" class="headerlink" title="ubuntu安装google chorme："></a>ubuntu安装google chorme：</h3><p>下载Chrome</p><pre class="line-numbers language-none"><code class="language-none">$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装</p><pre class="line-numbers language-none"><code class="language-none">$ sudo dpkg -i google-chrome-stable_current_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>报错</p><pre class="line-numbers language-none"><code class="language-none">$ sudo dpkg -i google-chrome-stable_current_amd64.deb(Reading database ... 155736 files and directories currently installed.)Preparing to unpack google-chrome-stable_current_amd64.deb ...Unpacking google-chrome-stable (88.0.4324.96-1) ...dpkg: dependency problems prevent configuration of google-chrome-stable: google-chrome-stable depends on fonts-liberation; however:  Package fonts-liberation is not installed. google-chrome-stable depends on libatk-bridge2.0-0 (&gt;= 2.5.3); however:  Package libatk-bridge2.0-0 is not installed. google-chrome-stable depends on libatk1.0-0 (&gt;= 2.2.0); however:  Package libatk1.0-0 is not installed. google-chrome-stable depends on libatspi2.0-0 (&gt;= 2.9.90); however:  Package libatspi2.0-0 is not installed. google-chrome-stable depends on libcairo2 (&gt;= 1.6.0); however:  Package libcairo2 is not installed. google-chrome-stable depends on libcups2 (&gt;= 1.4.0); however:  Package libcups2 is not installed. google-chrome-stable depends on libgbm1 (&gt;= 8.1~0); however:  Package libgbm1 is not installed. google-chrome-stable depends on libgdk-pixbuf2.0-0 (&gt;= 2.22.0); however:  Package libgdk-pixbuf2.0-0 is not installed. google-chrome-stable depends on libgtk-3-0 (&gt;= 3.9.10); however:  Package libgtk-3-0 is not installed. google-chrome-stable depends on libnspr4 (&gt;= 2:4.9-2~); however:  Package libnspr4 is not installed. google-chrome-stable depends on libnss3 (&gt;= 2:3.22); however:  Package libnss3 is not installed. google-chrome-stable depends on libpango-1.0-0 (&gt;= 1.14.0); however:  Package libpango-1.0-0 is not installed. google-chrome-stable depends on libxkbcommon0 (&gt;= 0.4.1); however:  Package libxkbcommon0 is not installed. google-chrome-stable depends on xdg-utils (&gt;= 1.0.2); however:  Package xdg-utils is not installed.dpkg: error processing package google-chrome-stable (--install): dependency problems - leaving unconfiguredProcessing triggers for mime-support (3.64ubuntu1) ...Processing triggers for man-db (2.9.1-1) ...Errors were encountered while processing: google-chrome-stable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>报错原因：缺少依赖软件包</p><pre class="line-numbers language-none"><code class="language-none">dpkg: error processing package google-chrome-stable (--install): dependency problems - leaving unconfigured<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解决办法：修复依赖关系</p><pre class="line-numbers language-none"><code class="language-none">$ sudo apt-get install -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果系统中有某个软件包不满足依赖条件,这个命令就会自动修复,将要安装那个软件包依赖的软件包。</p><p>查看Chrome版本信息</p><pre class="line-numbers language-none"><code class="language-none">$ google-chrome --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="ubuntu安装teams："><a href="#ubuntu安装teams：" class="headerlink" title="ubuntu安装teams："></a>ubuntu安装teams：</h3><p>1、去官网下载二进制包teams.tar.gz。</p><p>2、将下载的二进制包解压至 /usr/local目录。</p><pre class="line-numbers language-none"><code class="language-none">tar -C /usr/local -xzf teams.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Ubuntu安装typora"><a href="#Ubuntu安装typora" class="headerlink" title="Ubuntu安装typora:"></a>Ubuntu安装typora:</h3><p>在终端中输入以下命令：</p><pre class="line-numbers language-none"><code class="language-none"># sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAEwget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -# add Typora's repositorysudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get update# install typorasudo apt-get install typora<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ubuntu安装cloudmusic："><a href="#ubuntu安装cloudmusic：" class="headerlink" title="ubuntu安装cloudmusic："></a>ubuntu安装cloudmusic：</h3><p>先到网站下载安装包，网址：<a href="https://music.163.com/#/download">https://music.163.com/#/download</a> , 然后下载客户端，点击下载全部客户端，选择Linux版，选择Ubuntu18.04，其实我的20.04 版的没找到，不过这个用起来还不错。至于是32还是64，自己看吧。<br>然后将安装包下载到：~/下载 目录下，然后在这个目录下面打开终端。<br>在终端里面输入：sudo dpkg -i netease-cloud-music_1.2.1_amd64_ubuntu_20190428.deb 就行了</p><h3 id="ubuntu安装vim："><a href="#ubuntu安装vim：" class="headerlink" title="ubuntu安装vim："></a>ubuntu安装vim：</h3><p>自带的vi不好用，所以自己重新下了一下</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install vim<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装完成后进入/etc/vim目录下配置文件，使用会舒服一点</p><pre class="line-numbers language-none"><code class="language-none">sudo vim vimrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在末尾添加代码</p><pre><code>set number   set history=1000   set autoindentset smartindent set tabstop=4 set shiftwidth=4 set showmatch</code></pre><h3 id="ubuntu-安装PostMan"><a href="#ubuntu-安装PostMan" class="headerlink" title="ubuntu 安装PostMan:"></a>ubuntu 安装PostMan:</h3><pre class="line-numbers language-test" data-language="test"><code class="language-test">sudo snap install postman<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="ubuntu-安装nodejs和npm"><a href="#ubuntu-安装nodejs和npm" class="headerlink" title="ubuntu 安装nodejs和npm:"></a>ubuntu 安装nodejs和npm:</h4><p>一.下载最新版本的nodejs包（最新版本的nodejs包里默认含有npm）<br>可以去nodejs官网去查看最新版本的nodejs<br>网址如下：<a href="https://nodejs.org/en/download/current/">https://nodejs.org/en/download/current/</a><br>目前最新版本为：v17.1.0</p><pre class="line-numbers language-none"><code class="language-none">wget https://nodejs.org/dist/v17.1.0/node-v17.1.0-linux-x64.tar.xz    tar xf  node-v17.1.0-linux-x64.tar.xz       // 解压cd node-v17.1.0-linux-x64/                  // 进入解压目录 ./bin/node -v                               // 执行node命令 查看版本// bin目录下有执行文件npm和node 做软链接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下载到你当前的目录,假如是：/home/root/</p><p>第二步 创建软连接 可以在任意路径下执行npm node<br>注意：在创建软连接的时候要写 绝对路径,软连接到/usr/local/bin/</p><pre class="line-numbers language-none"><code class="language-none">ln -s  /home/root/node-v17.1.0-linux-x64/bin/node  /usr/local/bin/ln -s /home/root/node-v17.1.0-linux-x64/bin/npm  /usr/local/bin/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>// 注意要写文件的绝对路径</p><p>如果你在创建软连的时候，出现npm已经存在,node 已经存在<br>解决方案：<br>删除 /usr/local/bin/目录下的node，npm</p><p>rt@ubuntu:<del>$ sudo rm -rf /usr/local/bin/node<br>rt@ubuntu:</del>$ sudo rm -rf /usr/local/bin/npm</p><p>之后再创建软连接，完成。</p><pre class="line-numbers language-none"><code class="language-none">rbt@ubuntu:~$ node -vv17.1.0rt@ubuntu:~$ npm -v8.4.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样node和npm就同时安装成功了！</p><h4 id="ubuntu安装python3："><a href="#ubuntu安装python3：" class="headerlink" title="ubuntu安装python3："></a>ubuntu安装python3：</h4><p>ubuntu本身是有Python2.7版本的，但是不同版本的ubuntu中的Python3的版本是不同的，我现在用的是14版本就是python3.4，我想把它升级为3.6版本。当然，如果需要，你可以改为任意版本。</p><ol><li>安装python3.6(非必需)<br>在终端中输入下面的命令（不要怀疑，每行都是一个命令）</li></ol><pre class="line-numbers language-none"><code class="language-none">wget http://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz  tar -xvzf Python-3.6.4.tgz  cd Python-3.6.4  ./configure --with-ssl  make  sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些命令会使你的ubuntu下载python3.6.4，并替换你现在的python3版本。</p><ol start="2"><li>安装python运行环境<br>输入sudo passwd 输入root相关密码，输入su，进入超级管理员（如果你没设置过，需要设置root用户密码），也许你在安装时还需要升级你的apt-get，命令行下输入apt-get update</li></ol><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install pythonsudo apt-get install python-dev(编译外部模块文件使用的)sudo apt-get install python-pipsudo apt-get install libxml*sudo apt-get install net-toolssudo apt-get install lsof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>python3的话安装pip，命令为sudo apt-get install python3-pip<br>执行之后，输入python3来确定你是否安装成功，如下图所示显示python3.6.4即安装成功：</p><p>3.更新pip版本</p><pre class="line-numbers language-none"><code class="language-none">sudo pip install --upgrade pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4.安装SSH</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install openssh-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.安装 Nginx</p><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>6.安装 uwsgi</p><pre class="line-numbers language-none"><code class="language-none">sudo pip install uwsgi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署django项目前输入以下命令开启8000端口</p><pre class="line-numbers language-none"><code class="language-none">uwsgi --http :8000  --chdir 项目路径 -w  项目名称.wsgi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解除端口被占用的命令：</p><pre class="line-numbers language-none"><code class="language-none">sudo fuser -k 8000/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！"><a href="#至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！" class="headerlink" title="至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！"></a>至此ubuntu的基本的软件开发环境基本搭建完成，本文只做快速搭建环境的流程，具体问题网上都有解决方案，还有就是为什么没有数据库的安装？废话，都有Docker了，谁还安装数据库呀！！！</h5>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旅行的意义</title>
      <link href="/zhb233go.github.io/2021/11/22/7-lu-xing-de-yi-yi/"/>
      <url>/zhb233go.github.io/2021/11/22/7-lu-xing-de-yi-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="旅行的意义"><a href="#旅行的意义" class="headerlink" title="旅行的意义"></a>旅行的意义</h1><ul><li>今天看到一句话:”年轻时,我认为旅行是人生重要的事情,但是</li></ul><p>现在,我意识到旅行不是如此。它没有那么让人兴奋,也算不上成就,</p><p>跟其它的消费行为没有太大区别。旅行中,我们真正感兴趣的东西都是</p><p>那些留在原地,努力建设的人们建造出来的。</p><p>现在想想去年我年的技术支持,也去过了许多的地方,对于我来说,第一份</p><p>工作它虽然谈不上好,但对于我自己的成长和视界上的提升是巨大的,从</p><p>小我就希望到外界的世界去看看.大山的孩子的心思总是单纯的一年的时间,</p><p>一边工作的同时也欣赏了各地的风景,但是我遗憾是给我去探寻留在原地</p><p>的人们建造出来的美景、美食和美丽的心灵的时间太短。每经过一个</p><p>地方都够而过,虽然时间短暂,但留在我心中的种子已经种子,我相信这颗种子不会死去,</p><p>随着时间的成熟和我个人的成长,一定会再次绽放那个短暂回忆美丽的</p><p>花朵,因为人是一直成长的,但是那么地方和那些人一定</p><p>会留住原地继续建造，等待每个匆匆过往的旅客。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最重要的事,就是做你认为正确的事</title>
      <link href="/zhb233go.github.io/2021/11/21/6-zui-chong-yao-de-shi-jiu-shi-zuo-ni-ren-wei-zheng-que-de-shi/"/>
      <url>/zhb233go.github.io/2021/11/21/6-zui-chong-yao-de-shi-jiu-shi-zuo-ni-ren-wei-zheng-que-de-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="最重要的事-就是做你认为正确的事"><a href="#最重要的事-就是做你认为正确的事" class="headerlink" title="最重要的事,就是做你认为正确的事"></a>最重要的事,就是做你认为正确的事</h1><ul><li>在小时候母亲都外出务工了,由爷爷奶奶扶养到初中,他们就<br>离世了,之后就是我和姐姐在家,我爸为了能照映到我们都在离<br>家较近的地方打工,妈妈常年在外务工,从小到大父母由于文化<br>程度都不高,在能给予我支持的就是尽力供我的教育,每次他们能与<br>我沟通的就是希望我好好读书,以后能找到一份好的工作,而现在,<br>大学读完了,也有了工作.我不知道是不是就达到了父母的期望。以前的<br>我很迷茫,也幸好我老家是个小地方,没有太多选择,在小学、初中、高中,<br>我尽我的可能都进了能尽量好的班级学习,不出意外的,我考上了大学,<br>而且是个一本,(我以为的)在选考业的时候,依旧迷茫,不知道选什么专业,<br>但是,不知道为什么,我的心中就认为以后的世界一定是互联网的世界,或许<br>是有预感,或许自己爱打游戏,对于我当时的天真和想法其实<br>到现在我也觉得是正确的,因为我想有学习软件开发或许我真的可以搞出个<br>名堂来。在当时,我在选学校时,我记得我的大学的第一志愿都选了”软件工程”,<br>之后是计算机”灬反正就是和软件相关的我都写上了,但是由<br>于贵州有贫困生补助,能写三个提前批的大学名额这个名额是那<br>外省大学为了一些特设学科而给出的名额。但是这些大学的学科都不是<br>我想去的,我就抱着不想去的心态,随便选了三个我自认为得不到的大学并<br>且我软件工程挨了一点边的《电子信息科学与技术》,而我也因为这个阴差<br>阳错的来到了我的母校”天津工业大学”,我很意外,也<br>有一点疑憾,没有能去我心心念念的大学学科。</li><li>读了九年的义务教育、从来没有人告诉我该做什么<br>父母告诉我好好读书,我就好好的考上了大学,<br>但是大学的学科并不是我想学习的学科、也没有人该告诉我应该做什么了,<br>又一次不出意外的,我迷茫了,在大学里充满了诱惑游戏、金钱、娱乐。<br>那时的我就像个孩子,脱离了父母的监管,在大学肆意的放纵。可以<br>想象之后的学习就像还狂奔的野马,踏进泥塘——一踏胡图,在大<br>三的学科有七科学科，我就挂了六科,谈了四年的女友也分了,当时的自己<br>就能用一个字形容:”颓废!加之我跟人借钱,欠了一屁股债。可以这么说:<br>这是我活到现在人生的最低谷。那个时候真的可以体验。 晚上在床上睡<br>不着见到第二天的太阳。经历那段时间,我也没有了其它的顾虑,将学科<br>补考,最后靠着几个难兄难弟的同学抗过了大学结束。而现在我回到了我当时<br>想报考的学科。在互联网做个软件开发,我很开心,因为我在做着我喜欢的<br>事情而我现在的工作都靠我自己学习而得到的,现在,我能理解什么是正确的事情。</li><li>罗翔老师在档节目里曾说:”你最重要是做你觉得正确的事情,<br>最重要的是你听不到内心的抱怨,最重要的是多年以后的你能够看得<br>起现在的你,过好每一天,演好当下的剧本,朝着心中的那个标杆去前进,<br>人要做到!不清高,不娇情,不抱怨,就是在黑夜中看到了微光,<br>你就朝着微光的方向走过去,虽然有的时候你去怀疑你会觉得<br>是不是走错了,但是所有的怀疑都为了确信:那就是如何过看起来好的一生<br>,那你就要去定义了,什么叫做好,这个世界有太多关于好的标准了。<br>good（好）,如果加个s,就变成了 goods (商品),所以一切事情<br>最重要的就是赚钱吗!难道能赚钱的职业就是好职业吗?那这样做<br>一切职业分工就没有意义了。你要去寻找什么叫good,然后你才能去过 good<br>的一生,你才可以避免去随波逐流,你才内心会有一种笃定,你才会拒绝跟别人<br>去攀比,也拒绝被别人攀比。对于不可控的事情,我们保持<br>乐观,对于可控的事情,我们保持谨慎。于是你就仔细去回想,你这一生<br>中所遇到的很多经历,很多重要的时刻,你才恍然大悟,原来你就是个很<br>渺小的人”。</li><li>虽然现在我的人生才走了四分之一的阶段,但是我还要面对我人生的以后的<br>各个重大时刻。所以,我希望以后的我能够坦然的面对,也希望以后的<br>自己,能够看得起现在的自己</li></ul><p>——致自己<br>2021.11.20</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以后的世界将是游戏的世界</title>
      <link href="/zhb233go.github.io/2021/11/20/5-yi-hou-de-shi-jie-jiang-shi-you-xi-de-shi-jie/"/>
      <url>/zhb233go.github.io/2021/11/20/5-yi-hou-de-shi-jie-jiang-shi-you-xi-de-shi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="以后的世界将是游戏的世界"><a href="#以后的世界将是游戏的世界" class="headerlink" title="以后的世界将是游戏的世界"></a>以后的世界将是游戏的世界</h1><p>上周同时观看了两部电影,分别是《头号流家》与《失控玩家》两部</p><p>电影都是讲述近未来的游戏世界,《头号玩家》以玩家视角为切入点,</p><p>讲述玩家以VR眼镜和体感服装为媒介,进入一个虚拟世界与众多玩家</p><p>一起游玩,这个世界与现实世界就如同一个平行</p><p>宇宙,玩家可以在这个宇宙里面做任何它想做的事情。而</p><p>《失控玩家》则以游戏NPC为视角,向观众介绍了人工智能与</p><p>游戏世界不同的可能性。又时逢前段时间,元宇宙的概率</p><p>大火,就向人们抛出了可在人工智能,大数据,去服务逐渐</p><p>盛行的时代,在不久的未来,就会出现这种产品。但是,一方面</p><p>上层的服务需要有底层硬件的支持。就现阶段而言,VR眼镜</p><p>与体感套件都很初级,服务器也难以支持这种大型的游戏服务。所以在我看来我对</p><p>以后的游戏市场保持乐观心态,可能在未来5年的时间,我们将看到游戏</p><p>市场的澎渤发展。我会不断观察和验证我的观点。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对新人的一些建议</title>
      <link href="/zhb233go.github.io/2021/11/19/4-dui-xin-ren-de-yi-xie-jian-yi/"/>
      <url>/zhb233go.github.io/2021/11/19/4-dui-xin-ren-de-yi-xie-jian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="软件开发人员促销：获得更高水平的建议"><a href="#软件开发人员促销：获得更高水平的建议" class="headerlink" title="软件开发人员促销：获得更高水平的建议"></a>软件开发人员促销：获得更高水平的建议</h1><p>我最近的促销活动进展顺利。当<a href="https://blog.pragmaticengineer.com/things-ive-learned-transitioning-from-engineer-to-engineering-manager/">我从工程师过渡到管理人员时</a>，我有八个人向我报告。两年后，他们都被提升到了一个新的水平，还有一些其他的开发人员，他们后来加入了我的团队。从那以后，我帮助团队以外的人整理了成功的晋升案例，并成为了几个工程师晋升委员会的成员。最近，我也被提升到了更高一级的工程管理。</p><p>升职迟早会成为工程师的敏感话题。加入一家公司时，很少有开发人员会考虑到这一点——这是理所当然的，因为人们都专注于跟上进度。但随着时间的推移，随着越来越多的人在他们身边得到晋升，晋升成为许多人的首要考虑。作为经理，这自然成为我经常思考的话题。</p><p><strong>本文收集了我向团队中的工程师提供的晋升建议</strong>- 其中许多人后来被提升到更高级别。</p><ul><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#do-your-preparation">做好准备</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#set-your-sight-on-the-promotion">将目光投向促销</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#get-help-frequent-feedback">获得帮助和频繁的反馈</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#put-in-the-work">投入工作</a></li><li><a href="https://blog.pragmaticengineer.com/software-engineering-promotions/#stay-grounded">脚踏实地</a></li><li>帮助别人</li></ul><h2 id="做好准备"><a href="#做好准备" class="headerlink" title="做好准备"></a>做好准备</h2><p>一旦你决定你对升职有兴趣，就从收集基本信息开始，并评估升职对你的现实程度。</p><h4 id="了解贵公司的晋升流程。"><a href="#了解贵公司的晋升流程。" class="headerlink" title="了解贵公司的晋升流程。"></a>了解贵公司的晋升流程。</h4><p>每家公司都有不同的晋升流程。虽然类似的公司可能有类似的流程，但不要想当然。如果有关于该过程的信息，那就是一个很好的开始。最好的起点是询问您的经理。随着公司的成长和成熟，促销流程发生了变化。我观察到的最常见的促销过程类型是以下三种：</p><ul><li><strong>非正式升职：经理决定谁升职</strong>。几位经理进入一个房间，然后拿出一份晋升人员名单，这是小型初创公司和公司的典型流程。在会议上，管理人员介绍他们团队中的人员，然后由团队决定他们是否准备好晋升。</li><li><strong>半正式的晋升过程，有一个以经理为主的晋升委员会</strong>。随着公司的发展，将所有经理聚集在一起变得困难且耗时。此外，先前过程的偏见开始变得更加明显。领导层将致力于制定一个更具可扩展性和更公平的流程。这通常从写下每个工程级别的基本期望开始，并要求经理提交简短的文档，说明他们团队中的工程师为什么准备晋升。</li><li><strong>正式的晋升流程：晋升套餐和委员会</strong>。谷歌、优步和几家大型科技公司都在效仿这种流程。它需要有明确和广泛定义的工作阶梯，在每个级别都有明确的期望。我们的想法是使促销活动尽可能公正。作为更公平和透明的过程的回报，产生了更多的文件。广泛的自我审查、同行审查和经理审查被写入。由高级工程师和管理人员组成的晋升委员会决定晋升是否通过。</li></ul><p>所有方法都有其优点和缺点。了解您的组织正在关注什么，以便您更好地了解您和您的经理必须如何准备。</p><h4 id="评估自己"><a href="#评估自己" class="headerlink" title="评估自己"></a>评估自己</h4><p>大多数科技公司都采用一种方法，将已经在那里工作的人提升到更高的水平。晋升通常是对您的影响力和技能始终超出对您的期望的认可，并且符合下一个级别的规范。</p><p>那么，与下一个级别相比，您的表现如何？当您在一家公司工作时，回答这个问题要容易得多，在文档中明确定义了能力和级别，您可以参考。定义明确的能力的一些很好的例子包括<a href="https://progression.monzo.com/">Monzo</a>、<a href="https://docs.google.com/spreadsheets/d/12h50IYqd7fsO7tJ0l1OuHYbz5vN2d24a8EIDFhu2AZQ/edit#gid=2035430096">Square</a>或<a href="https://dresscode.renttherunway.com/blog/ladder">Rent The Runway 等</a>。如果您的公司拥有明确定义的能力，请通读您所在级别和下一级别的期望。列出您所展示的技能、您所产生的影响以及它如何与这些期望相匹配。</p><p>如果您的公司没有明确的能力和期望，您仍然需要弄清楚您在当前的期望中表现如何。您还想知道达到下一个级别的预期目标。<strong>根据经验，要考虑晋升，您应该在目前的水平上做得很好。</strong>因此，您可以从获取有关您当前表现的反馈开始，与最适合向您提供反馈的人交谈：您的经理。</p><h4 id="让你的经理站在你这边"><a href="#让你的经理站在你这边" class="headerlink" title="让你的经理站在你这边"></a>让你的经理站在你这边</h4><p>无论您的公司遵循什么流程，如果您的经理不支持升职，那么您获得晋升的机会非常渺茫。所以一定要让你的经理站在你这边。你怎么做到这一点？询问他们促销是如何运作的，他们的促销理念是什么。与当前和下一级别相比，询问他们如何评价您当前的表现。根据您的经理的不同，您可能会决定逐步提出这个问题，但您迟早需要就此进行坦诚的对话。</p><p>这种谈话对我来说总是很尴尬，作为一名工程师，我在职业生涯中很长一段时间都避免这种谈话。回想起来，我希望我没有。原因很简单。</p><p>*<strong>当*您准备好*时，*晋升符合您经理的最佳利益。</strong>管理者的评判标准是他们是否有能力让他们的团队提供更好的产出。他们通过让他们的工程师作为一个团队更有效率来做到这一点。为了让团队更有效率，团队中的工程师需要成长为更高效、更可靠和更资深。外部可见的增长指标之一是促销活动。晋升意味着经理帮助这个人成长——要么通过指导、指导，要么只是让他们摆脱困境。一个团队越来越高级的经理表明他们在培养人才方面做得很好。</p><p>所以我们知道晋升会让经理看起来很好。尽管如此，仍有很多开发人员认为<em>“我的经理永远不会提拔我”。</em>问问自己：这是为什么？一位领导停滞不前的经理开始引起来自上级和团队的不必要的关注。如果人们不断收到平均或差劲的绩效评估，而从不准备升职，那对经理来说也不好看。所以在你问过自己为什么你的经理似乎不想提拔你之后，也问问你的经理。告诉您您可以和应该发展哪些领域符合他们的最大利益。</p><h4 id="在高级酒吧以上的促销活动中要切合实际"><a href="#在高级酒吧以上的促销活动中要切合实际" class="headerlink" title="在高级酒吧以上的促销活动中要切合实际"></a>在高级酒吧以上的促销活动中要切合实际</h4><p>通常，晋升到高级职位主要是基于获得技能、展示这些技能并产生影响。但是，在高级工程师级别之上，还有其他因素在起作用。</p><p>首先，可能有多少人可以晋升到更高级别的预算限制。有些地方需要一个商业案例，说明为什么给定的团队或区域需要领导、员工或首席工程师。如果没有商业案例，您可能无法获得晋升。即使您可能有公平的晋升机会，也是如此。</p><p>其次，在高级工程师级别以上，您可能会发现很难找到足够大且影响力足以保证晋升的项目。例如，您的团队可能正忙于交付小的、增量的功能，这些功能没有什么复杂性，但具有可观的商业价值。几乎可以肯定，仅仅在这里工作出色，您不会被提升到高级级别。在这种情况下，您需要掌控自己的职业并决定如何前进。你是否在等待新的机会到来？您是否调动团队来领导复杂而有影响力的绿地项目的工作？您是否提出了一项具有巨大业务影响的新计划，说服利益相关者启动并最终领导它？没有简单的答案：你必须采取主动，争取支持，</p><p><img src="https://blog.pragmaticengineer.com/content/images/2019/10/levels-1.png" alt="img"></p><p><strong>随着您的职业阶梯上升，进入下一个级别变得越来越难。</strong>这是开发人员阶梯上的类似挑战，就像管理一样。从经理到总监通常同样困难，就像从高级工程师到员工或原则一样。</p><h2 id="将目光投向促销"><a href="#将目光投向促销" class="headerlink" title="将目光投向促销"></a>将目光投向促销</h2><p>一旦您了解晋升流程的运作方式、评估自己并让您的经理站在您这边，就该集中注意力了。</p><h4 id="设定目标以缩小您在下一级别缺乏的领域的差距"><a href="#设定目标以缩小您在下一级别缺乏的领域的差距" class="headerlink" title="设定目标以缩小您在下一级别缺乏的领域的差距"></a>设定目标以缩小您在下一级别缺乏的领域的差距</h4><p>毫无疑问，您需要在多个领域变得更好或展示影响力。这可能涉及软件工程、有影响力的执行、设计复杂问题的解决方案、与他人更好地协作等领域。</p><p>设定可帮助您实现目标的 SMART 目标 - 具体、可衡量、可实现、现实、及时。设定只取决于你自己的目标，而不取决于外部因素，比如被给予机会。例如，如果您确定要改进的领域是在架构上变得更好，那么不要设定构建复杂项目的通用目标。但是您可以设定一个目标，每月至少彻底审查一份提案，在该领域指导至少一名初级工程师 3 个月，或阅读相关书籍并在接下来的 2 个月内向您的团队和组织展示学习成果。如果你被确认领导一个项目，你可以设定一个目标，让两个比你高的人审查你的提案，他们在你的团队之外。</p><h4 id="采取行动并承担责任，就像您已经处于下一个级别一样"><a href="#采取行动并承担责任，就像您已经处于下一个级别一样" class="headerlink" title="采取行动并承担责任，就像您已经处于下一个级别一样"></a>采取行动并承担责任，就像您已经处于下一个级别一样</h4><p>有两种促销情况。一个是非常简单的：毫无疑问，工程师已经在下一个级别执行了很长时间。另一个更具挑战性：这个人表现出很多希望，但有一些地方他们没有达到下一个层次。第二种促销案例是抛硬币类型，结果可能以任何一种方式进行。</p><p>当您为升职而努力时，目标是在下一个级别上始终如一地表现：不要仅将其限制在您的重点领域。如果您的目标是高层，而您团队的项目面临风险，请建立并帮助整个项目取得成功。如果你的经理要求志愿者做一件无聊但重要的家务活，而且没有人加紧努力，请考虑举手。在粉碎这项工作的基础上，自动化它的一部分，让团队中的下一个人更容易完成它。</p><h4 id="记录您的成就和影响"><a href="#记录您的成就和影响" class="headerlink" title="记录您的成就和影响"></a>记录您的成就和影响</h4><p>当您的经理或您整理升职案例的时候到了，第一个问题将是关于您取得的成就，这保证了这次升职。到那个时候，你会忘记你所做的很多伟大的工作。因此，提前开始并开始写下您正在完成的所有工作。</p><p>开始一个<a href="https://blog.pragmaticengineer.com/work-log-template-for-software-engineers/">工作日志文件</a>或类似的东西，你会不断更新。<a href="https://blog.pragmaticengineer.com/work-log-template-for-software-engineers/">这是我创建的 Google Doc 模板</a>。与您的经理分享此信息，以便他们也了解您所做的所有工作。没有人比你更了解你所做的工作。你可能会因为你完成了多少额外的事情而让你的经理大吃一惊。当你得到晋升时，你会让你们的生活更轻松。</p><p>考虑针对下一个职业阶梯级别<a href="https://blog.pragmaticengineer.com/performance-review-template-and-example-for-software-engineers/">进行自我评估</a>，列出您认为证明您已经证明在下一个级别工作的例子。向您的经理寻求反馈，并使用此审查来确定您可以努力缩小的下一个级别的差距。</p><h2 id="获得帮助和频繁的反馈"><a href="#获得帮助和频繁的反馈" class="headerlink" title="获得帮助和频繁的反馈"></a>获得帮助和频繁的反馈</h2><p>争取晋升的过程并不短：可能需要几个月的时间。很容易忘记自己的表现，以及您是否仍然在证明自己处于下一个级别的目标上。</p><h4 id="在公司找个导师，帮你"><a href="#在公司找个导师，帮你" class="headerlink" title="在公司找个导师，帮你"></a>在公司找个导师，帮你</h4><p>虽然您的经理可能会在您的升职工作中站在您这边，但他们能给您的反馈也有限。您可以<a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/">通过获得一位导师（另一位工程师）</a>来加速您的职业发展。</p><p>尝试找到已经处于下一个级别的开发人员。更好的是，如果他们在公司内得到提拔。向他们寻求指导，特别是在成长到一个新的水平上。与他们分享您的评估和目标，并寻求反馈和帮助以帮助您成长到更高的水平。</p><p>在我的公司内，我注意到主动建立此类指导的开发人员看到了多种好处。一方面，他们根据导师的反馈对自己的成长方式变得更具战略性。这些导师通常在公司工作的时间更长，并帮助工程师了解促销活动中一些不太清楚的部分。其次，即使他们没有得到提升，有导师的开发人员也更容易反弹。他们有自己的导师，他们投资于让他们更上一层楼。这使这些开发人员更容易团结一致，继续在他们的游戏中保持出色，并在下一个周期进行推广。</p><h4 id="要求定期、明确的反馈"><a href="#要求定期、明确的反馈" class="headerlink" title="要求定期、明确的反馈"></a>要求定期、明确的反馈</h4><p>设定目标并为之努力是一回事。但是，尤其是当您正在努力实现升职等重要里程碑时，定期获得有关您的工作方式的反馈同样重要。</p><p>注意定期向经理展示您认为自己取得的进展。向他们询问有关您在下一级别的进展情况的反馈。尽早进行对话，了解他们是否支持您在下一个周期获得晋升。即使答案是“还没有”，让他们帮助定义可操作的事情，如果你完成了，你将为下一个级别做好准备。</p><h4 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h4><p><a href="https://newsletter.pragmaticengineer.com/">订阅我的每周通讯</a>，为工程经理和高级工程师提供建议、观察和灵感。</p><h2 id="投入工作"><a href="#投入工作" class="headerlink" title="投入工作"></a>投入工作</h2><p>如果您已向您的经理和导师明确表示您正在为晋升而努力，请投入工作。在提名前的几个月里，加倍努力在更高的水平上表现，完成工作并帮助他人。</p><h4 id="不要疏远你的同龄人"><a href="#不要疏远你的同龄人" class="headerlink" title="不要疏远你的同龄人"></a>不要疏远你的同龄人</h4><p>我有时会看到工程师犯的一个错误是过于专注于<em>他们的</em>晋升，以至于最终损害了团队。到了升职时间，他们往往最终没有升职，因为很明显，他们与优秀的团队合作者背道而驰。越来越多的公司小心翼翼——理所当然！- 不提拔拉低团队的人。</p><p>为了实现您为晋升而设定的目标，让人们避开是一个糟糕的策略。首先，这是非常短期的思考。在晋升时可能会要求您可能走过的同龄人提供反馈。但即使他们不是，这也是不成熟的标志。您获得的资历越高，就越期望您成为一名出色的团队合作者，<em>同时取得</em>可靠的成绩。要达到平衡并不总是那么容易。但是，如果您发现自己以一种让团队中的人感到不安的方式推进自己的目标，请考虑改变您的方法以提高协作性。</p><h4 id="即使你觉得口袋里有东西，也不要退缩"><a href="#即使你觉得口袋里有东西，也不要退缩" class="headerlink" title="即使你觉得口袋里有东西，也不要退缩"></a>即使你觉得口袋里有东西，也不要退缩</h4><p>有一次，开发人员与他们的经理设定了目标，如果他们成功领导并交付 ComplexProjectX，他们将获得晋升。项目进展顺利，人就升职了。此人一听这好消息，一脚踹开，放下了这个项目，没有委托给其他人。随着项目的推出，越来越多的问题浮出水面，没有人采取行动。最终，不得不恢复推出。</p><p>这发生在晋升委员会讨论这位工程师的案子之前。在讨论中，他们一致认为，虽然这个人在很多方面都表现出很高的技能，但他们通过从方向盘上消失的第11个小时来表现出不成熟。没有沟通，也没有很好的解释为什么会发生这种情况。该人在那个周期没有得到提升。</p><h2 id="脚踏实地"><a href="#脚踏实地" class="headerlink" title="脚踏实地"></a>脚踏实地</h2><h4 id="不要相信任何向您承诺“肯定会升职”的人。"><a href="#不要相信任何向您承诺“肯定会升职”的人。" class="headerlink" title="不要相信任何向您承诺“肯定会升职”的人。"></a>不要相信任何向您承诺“肯定会升职”的人。</h4><p>我告诉我团队中的所有工程师的第一件事是，我和任何经理都不能保证“肯定会升职”。如果有人告诉他们这些，请不要相信。我见过太多的开发人员被这样的承诺烧毁。即使有最好的经理，也有很多原因导致“确定”的晋升不会实现。</p><p>首先，任何经理都可能会意外离开。最常见的苦涩故事是这样的：<em>“X 经理答应我会升职，因为我做得很好。然后他们离开了。我的新经理没有兑现这个承诺，决定不提拔我”。</em>第二个原因是，任何经理都可能误判他们的直属部门的表现或公司晋升的政治局势。相信关于“已经在口袋里”类型的声明的好消息很诱人：不要。如果你以表面价值接受这样的承诺，无论它们可能是多么真诚，你都会让自己失望。</p><h4 id="不要让晋升成为你唯一的目标"><a href="#不要让晋升成为你唯一的目标" class="headerlink" title="不要让晋升成为你唯一的目标"></a>不要让晋升成为你唯一的目标</h4><p>无论您在下一级别的表现如何，无论您的经理多么支持您，您都可能不会得到提升。如果你的唯一目标是升职本身，你会士气低落，可能会考虑辞职并寻找新工作，仅仅因为结果本身。</p><p>我曾经有一位我强烈支持的工程师，我 100% 相信他们会得到晋升。尽管我为这个人而战，但他们仍然没有走上连锁店为他们辩护。此后，我更加致力于帮助这位工程师在下一个周期中获得认可。幸运的是，这位开发人员不仅关注结果，而且同样关心其他领域的发展。下一次，他们粉碎了晋升过程，继续保持高增长轨迹。</p><p><strong>如果你的主要目标是职业发展，即使你没有得到提升，你也会获得宝贵的技能。</strong>这些技能可能是传达工程最佳实践、指导他人、领导项目、分享知识等。专注于这些技能，而不是仅仅提升。根据贵公司遵循的流程，促销会成功还是失败。但没有人能夺走你的成长。</p><h4 id="促销不是获得正面反馈的唯一途径"><a href="#促销不是获得正面反馈的唯一途径" class="headerlink" title="促销不是获得正面反馈的唯一途径"></a>促销不是获得正面反馈的唯一途径</h4><p>许多人将晋升视为对工作出色的证明。然而，虽然成功的促销确实意味着出色的反馈，但您获得的大部分正面认可不会通过促销获得。</p><p>你每天都会从和你一起工作的人那里得到反馈，他们会说“<em>谢谢</em>”、“<em>你真的帮了我</em>”或“<em>没有你我会被困更长时间</em>”。你会从你的经理和导师那里得到反馈。而且，当然，还有正式的绩效评估，您的经理还将在其中总结您所做的出色工作 - 以及需要改进的领域。获得奖金或加薪也是所有积极的反馈——所有这些都将比晋升更频繁。</p><h4 id="保持耐心并保持积极态度。这是一场漫长的比赛。"><a href="#保持耐心并保持积极态度。这是一场漫长的比赛。" class="headerlink" title="保持耐心并保持积极态度。这是一场漫长的比赛。"></a>保持耐心并保持积极态度。这是一场漫长的比赛。</h4><p>我有一位有几年经验的才华横溢的开发人员加入了我的团队，他渴望达到高级水平。他们有一个朋友最近晋升到了这个级别，他们觉得这个朋友在他们之前。这个人很沮丧，在经过他们的自我评估后，我告诉他们，与下一个级别相比，他们有太多的差距，无法在本周期晋升。我说，即使他们投入工作，我也看不到他们在下一个周期之前升职，也就是 9 个月之后。我建议我们制定一个计划来实现这一目标。</p><p>首先，这个人很不高兴，认为我已经为他们准备好了。慢慢地，冷静下来之后，我们制定了一个计划。一步一步地，我们取得了进展，他们开始意识到他们需要做多少工作。最终，9个月后，他们升职了。他们还不到5年的经验，已经是高级水平了。作为参考，我花了更长的时间才能达到相同的水平。尽管如此，与他们不同的是，我从未感到落后。</p><p>额外的 6 个月或 12 个月会对您的职业生涯产生影响吗？你越早接触它，你就越认为它会起作用。然而，一段时间后，您可能会意识到这不是短跑，而是马拉松。<strong>虽然您可能会在第一份工作几年后获得晋升，但随着时间的推移，晋升会放缓：获得晋升将更具挑战性。</strong></p><p>玩长时间的游戏。保持积极的态度并专注于您持续的专业成长。将您的成长视为一次旅程，而不是促销的竞争。这样做你会更加平衡。</p><h2 id="帮助别人"><a href="#帮助别人" class="headerlink" title="帮助别人"></a>帮助别人</h2><p>在公司内晋升从来都不是一件容易的事。当您在这方面取得成功时，请考虑回馈并收留某人，帮助他们成长。让其他人知道您愿意指导他人。如果您在团队中看到某人具有良好的成长潜力并且您觉得可以提供帮助，请主动提出指导他们。</p><p>即使你还没有得到提升，也要帮助他人成长并因他们的成长而获得认可。如果你所在的公司有更重量级的晋升流程，有同行评审，你可能会被其他人要求对他们的晋升进行同行评审。如果您在更高级别加入，其他工程师可能会向您寻求有关发展的建议。</p><p><strong>不要忘记，升职是对你成长的认可。最好的成长方式之一就是</strong><a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/"><strong>通过指导</strong></a><strong>来</strong><a href="https://blog.pragmaticengineer.com/developers-mentoring-other-developers/"><strong>教导他人</strong></a><strong>。</strong>保持平易近人和乐于助人的态度，并为此付出代价。你会学到更多，结交许多盟友，这样你的职业生涯将变得更加愉快。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>幸存者偏差</title>
      <link href="/zhb233go.github.io/2021/11/18/3-xing-cun-zhe-pian-chai/"/>
      <url>/zhb233go.github.io/2021/11/18/3-xing-cun-zhe-pian-chai/</url>
      
        <content type="html"><![CDATA[<h1 id="幸存者偏差"><a href="#幸存者偏差" class="headerlink" title="幸存者偏差"></a>幸存者偏差</h1><ul><li><p>二战时,美国邀请沃德教授利用统计学知识加强飞机。机翼是最容易击中的<br>位置机尾则是最少被击中的位置，沃德教授的结论：”是应该加强机尾的保护”,<br>而军方指挥官认为:”应该加强机翼的保护,因为这是最容易被击<br>中的地方”。</p></li><li><p>我们太容易在编造历史理论时忘记已经死去的人,但这个问题不仅存在于<br>历史中,还存在于我们在所有领域打造样本并搜集证据的方式中。我们<br>把这种扭曲称为偏差,也就是你所看到的事物与真正存在的庸物之间的差异。<br>我们的认知系统对于不出现在我们眼前或不引起我们感情注意<br>的事物可能没有反应。</p></li><li><p>我们天生肤浅,只注意我们看到的东西,不注意没给<br>我们留下生动印象的东西。我们向沉默的证据发动了双重战争。潜意识<br>的推理机制(的确存在这样的机制)忽视沉默的证据,即使我们知道需要考虑它。<br>不进入视线则不进入大脑我们对抽象的东西怀有天性上的甚至行动上的蔑视。</p></li></ul><p>—–节选自《黑天鹅》</p><p>作者:纳西姆·尼古拉斯·塔勒布</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超前消费的利与弊?</title>
      <link href="/zhb233go.github.io/2021/11/17/2-chao-qian-xiao-fei-de-li-yu-bi/"/>
      <url>/zhb233go.github.io/2021/11/17/2-chao-qian-xiao-fei-de-li-yu-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="超前消费的利与弊"><a href="#超前消费的利与弊" class="headerlink" title="超前消费的利与弊?"></a>超前消费的利与弊?</h1><p>就在昨天,我接到一个电话,说是想邀请我去招商银行办一张信用卡,</p><p>我当时没有答应他说是考虑一下，之后我就想这种形式的消费对我来说的利弊如何？</p><p>在我看来,就像花呗、信用卡之类形式的消费方式就与</p><p>货款无异,都是透支你的个人信用、在你没有这个经济实力的</p><p>情况下,银行给你提供这种方式让你消费,而你恰好踏入这个陷井,因</p><p>为银行给你支出的钱就是从其它人流入的钱流转,银行通过流转收取利息。</p><ul><li>超前消费的利:老话说的好!早卖早享受,晚买享折扣!但是对于你想要购</li></ul><p>买的物品没有足够的资金银行就跟你提供这种方式,抵押你的信用、</p><p>促使你去消费这样就使你能够在每月付出较少代价情况,购买你想要的物品,</p><ul><li>超前消费的弊:虽然你能够提前享受购买物品的快感,去透支你的信用、</li></ul><p>但是它是限制的,并且关键在于你有能力还上你的信用,在你资金链</p><p>充足情况下,信用能帮你周转，但你不能靠此无为乐,</p><p>透支信用的后果就是对自身信用的破坏这种消费形式属于风险</p><p>不大,但后果严重,就如同在悬崖攀爬过程中风险不大。因为你在</p><p>保险绳,就相当于你的资金链,一但你的保险绳断开、跌下谷底便是粉身碎骨。</p><ul><li>总结:对于我来说、自身在可支配资金情况下尽减少或者不用</li></ul><p>这种消费,因为只要你习惯这种形式的消费,你就没有了对他的畏惧感。</p><p>俗话说:淹死的都是会水的。小心驶得万年船。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你眼中的世界</title>
      <link href="/zhb233go.github.io/2021/11/16/1-ni-yan-zhong-de-shi-jie/"/>
      <url>/zhb233go.github.io/2021/11/16/1-ni-yan-zhong-de-shi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="你的眼里是什么样的世界就是什么样的"><a href="#你的眼里是什么样的世界就是什么样的" class="headerlink" title="你的眼里是什么样的世界就是什么样的,"></a>你的眼里是什么样的世界就是什么样的,</h1><ul><li>这个世界很大,而人却很渺小人就如同足球场上的沙粒微不足道,</li></ul><p>每个人都有不同的生活环境,从小到大，你眼中的世界是什么样的呢?</p><p>我认为世界是一直在变化的,而人也是一样在成长的，人眼中的世界是很局限的，</p><p>人的一生所经历的事物也是有限的,你能经历的就</p><p>只是你身边所能接触到的事与物,在一方面来说,这个世界是有一套它自身</p><p>运转的规则,你只能只身于世界的一个小环境中用你的眼睛去观察</p><p>成的一小部分,所以这个你所认识的世界仅仅是你看到的一小部分、而</p><p>你就认为这就是世界的全部,心中就难免与他所看的世界产生差距。</p><p>另一方面、世界是不断变化的,你所观察到的东西也是不断的变化,</p><p>而且人的心智上的成长也会影响你观察这个世界而得出不同的结</p><p>论。所以说,虽然这个世界有这么多我们看不清的事物和道理，</p><p>但只要我们一直保持独立的思考，并且能拥有一套我们去解释这个世界</p><p>的方法，我们就可以过好大部分的人生了!</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
