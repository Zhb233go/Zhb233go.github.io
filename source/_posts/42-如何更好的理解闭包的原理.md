---
title: 如何更好的理解闭包的原理
author: hypo
img: medias/featureimages/75.png
top: false
cover: false
toc: true
mathjax: false
date: 2023-10-23 16:00:11
coverImg:
password:
summary: 在Go语言中，闭包（closures）是指一个函数值（function value）捕获了其所在作用域外部变量的引用。
categories: 笔记
tags:
- Golang
- 闭包
---
# 如何更好的理解闭包的原理



> 在Go语言中，闭包（closures）是指一个函数值（function value）捕获了其所在作用域外部变量的引用。换句话说，闭包允许函数访问并操作其声明时不在同一作用域内的变量。这种行为在并发编程和函数式编程中非常有用。



## 简单理解

让我们通过一个例子来更好地理解Go闭包的原理：

```go
package main

import "fmt"

func main() {
	// 定义一个外部变量
	outerVar := 10

	// 创建一个闭包函数
	closureFunc := func() {
		// 在闭包函数中访问外部变量
		fmt.Println("Outer variable inside closure:", outerVar)
	}

	// 调用闭包函数
	closureFunc()

	// 修改外部变量的值
	outerVar = 20

	// 再次调用闭包函数
	closureFunc()
}
```

在这个例子中，`closureFunc` 是一个闭包函数。它访问了声明在其外部作用域的 `outerVar` 变量。当我们调用 `closureFunc()` 时，它会打印出 `outerVar` 的当前值。即使在闭包函数被创建后，`outerVar` 的值发生了改变，闭包函数仍然能够访问并打印出最新的值。

这种能力是通过Go语言的编译器和运行时环境实现的。当你创建一个闭包时，它会持有对其外部变量的引用，使得在闭包函数内部可以访问这些变量。这就是Go闭包的基本原理。

闭包在Go中常常用于实现函数式编程的概念，比如在函数中返回另一个函数，或者在并发编程中确保数据安全性。通过使用闭包，你可以方便地将函数和数据结构打包在一起，形成一个更加灵活和强大的抽象。



## 更多例子：

当使用闭包时，函数可以访问其外部作用域中的变量。这种特性使得闭包在很多情况下非常有用，比如延迟执行（deferred execution）、函数工厂（function factory）、事件处理等。以下是一些更多的闭包示例：

### 1. 延迟执行（Deferred Execution）

```go
package main

import "fmt"

func main() {
	for i := 1; i <= 3; i++ {
		defer func() {
			fmt.Println(i)
		}()
	}
}
```

输出：

```sh
4
4
4
```

在上述例子中，使用闭包延迟执行了一个匿名函数，但是这个闭包捕获的是变量 `i` 的引用。由于 `defer` 语句中的函数会在包含它的函数返回之后执行，所以闭包最终输出的是 `i` 的最终值，即 4。

### 2. 函数工厂（Function Factory）

```go
package main

import "fmt"

func makeMultiplier(factor int) func(int) int {
	return func(x int) int {
		return x * factor
	}
}

func main() {
	double := makeMultiplier(2)
	triple := makeMultiplier(3)

	fmt.Println(double(5)) // 输出 10
	fmt.Println(triple(5)) // 输出 15
}
```

在这个例子中，`makeMultiplier` 是一个函数工厂，它接受一个整数参数 `factor`，并返回一个新的函数，这个函数将传入的参数与 `factor` 相乘。通过不同的参数调用 `makeMultiplier`，我们创建了两个新的函数 `double` 和 `triple`。

### 3. 闭包作为参数传递

```go
package main

import "fmt"

func applyOperation(x int, operation func(int) int) int {
	return operation(x)
}

func main() {
	square := func(x int) int {
		return x * x
	}

	result := applyOperation(5, square)
	fmt.Println(result) // 输出 25
}
```

在这个例子中，`applyOperation` 函数接受一个整数 `x` 和一个操作函数 `operation` 作为参数，并将 `x` 传递给 `operation` 函数进行处理。在 `main` 函数中，我们定义了一个闭包 `square`，它计算输入的平方，并将它作为参数传递给 `applyOperation` 函数。

这些例子展示了闭包在不同场景下的应用。闭包允许函数保持对其外部作用域的引用，使得函数变得更加灵活和通用。



## 容易遇见的坑

闭包在Go中是一个非常强大的概念，但是也可能导致一些陷阱。以下是一些使用闭包时容易遇到的问题和注意事项：

### 1. 循环变量陷阱

```go
package main

import "fmt"

func main() {
	var funcs []func()

	for i := 0; i < 3; i++ {
		funcs = append(funcs, func() {
			fmt.Println(i)
		})
	}

	for _, f := range funcs {
		f() // 输出 3 3 3，而不是 0 1 2
	}
}
```

在这个例子中，闭包捕获的是循环变量 `i` 的引用。当`funcs` 切片中的闭包最终执行时，它们都会输出 `3`，而不是期望的循环变量的值 `0`、`1`、`2`。这是因为所有的闭包共享同一个 `i` 变量，而不是每个闭包都有自己的 `i` 值。

解决方法是在循环内部创建一个局部变量，将循环变量的值复制给这个局部变量，然后在闭包中使用局部变量。

```go
for i := 0; i < 3; i++ {
    localI := i
    funcs = append(funcs, func() {
        fmt.Println(localI)
    })
}
```

### 2. 闭包捕获的是变量引用

闭包捕获的是外部变量的引用，而不是它的值。如果在闭包中修改了这个变量的值，那么这个变量的改变会在闭包外部可见。例如：

```go
package main

import "fmt"

func main() {
	x := 10
	func() {
		x++
	}()
	fmt.Println(x) // 输出 11
}
```

在这个例子中，闭包中的 `x++` 修改了外部变量 `x` 的值。这种情况可能导致意料之外的结果，因此需要小心处理。

### 3. 闭包的执行顺序

闭包中的变量捕获是在闭包函数被调用时发生的，而不是在闭包创建时。这可能会导致一些意想不到的结果，特别是在涉及到循环的情况下。

以上都是使用闭包容易遇到的一些陷阱。了解这些问题，开发者可以更加谨慎地使用闭包，避免不必要的错误。