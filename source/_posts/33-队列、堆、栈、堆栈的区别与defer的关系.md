---
title: 队列、堆、栈、堆栈的区别与defer的关系
author: hypo
top: false
cover: false
toc: true
mathjax: false
date: 2022-02-12 13:47:03
img: medias/featureimages/43.jpg
coverImg:
password:
summary: **栈**(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性
categories: 笔记
tags:
- 笔记
- Golang
- 基础
---
# 队列、堆、栈、堆栈的区别  
### 堆栈：先进后出（就像放在箱子的衣服，先放进去的后拿出来）

### 队列：先进先出（就像一条路，有一个入口和一个出口，先进去的就可以先出去）

进程中每个线程都有自己的**堆栈**，这是一段线程创建时保留下的地址区域。我们的“**栈内存**”即在此。
至于“**堆**”内存，我个人认为在未用new定义时，**堆**应该就是未“保留”未“提交”的自由空间，new的功能是在这些自由空间中保留（并提交）出一个地址范围。

**栈**(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。在编程中，例如C/C++中，所有的局部变量都是从**栈**中分配内存空间，实际上也不是什么分配，只是从**栈顶**向上用就行，在退出函数的时候，只是修改**栈指针**就可以把**栈**中的内容销毁，所以速度最快。

**堆**（Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程，C/C++分别用malloc/New请求分配Heap，用free/delete销毁内存。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用**堆**的效率低的多！但是**堆**的好处是可以做的很大，C/C++对分配的Heap是不初始化的。

在Java中除了简单类型（int,char等）都是在**堆**中分配内存，这也是程序慢的一个主要原因。但是跟C/C++不同，Java中分配Heap内存是自动初始化的。在Java中所有的对象（包括int的wrapper  Integer）都是在**堆**中分配的，但是这个对象的引用却是在Stack中分配。也就是说在建立一个对象时从两个地方都分配内存，在Heap中分配的内存实际建立这个对象，而在Stack中分配的内存只是一个指向这个**堆**对象的指针（引用）而已。

**堆**是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{**堆**是指程序运行是申请的动态内存，而栈只是指一种使用**堆**的**方法**(即**先进后出**)。}

**栈**是先进后出的，但是于**堆**而言却没有这个特性，两者都是存放临时数据的地方。 对于**堆**，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。

###在同一个goroutine中：多个defer的调用栈原理是什么？

defer函数是如何调用的?

为了探究其中的奥秘我准备了如下代码：
````
package main
import "fmt"

func main() {
xx()
}
func xx() {
defer aaa(100, "hello aaa")
defer bbb("hello bbb")
return
}

func aaa(x int, arg string) {
fmt.Println(x, arg)
}

func bbb(arg string) {
fmt.Println(arg)
}
````
输出：

bbb

100 hello aaa

从输出结果看很像栈的数据结构特性：后进先出(LIFO).

对于如下所示的 defer 语句
````
func x() {
.......
defer y(......)
.......
}
````
首先，编译器会把 defer 语句翻译成对 deferproc 函数的调用，deferproc 负责构造一个用来保存 y 函数的地址以及 y 函数需要用到的参数的 _defer 结构体对象，并把该对象加入当前 goroutine 对应的 g 结构体对象的 _defer 链表表头；

然后，编译器会在 x 函数的结尾处插入对 deferreturn 的调用，deferreturn 负责递归的调用 x 函数通过 defer 语句注册的函数。

总体说来，在不考虑 panic/recover 的情况下，go语言对 defer 的实现机制还是比较简单，但其具体实现细节还是有很多地方值得我们仔细思考和学习的。

最后，defer函数虽然方便，但是需要有额外的运行开销，在使用时需要进行取舍，尤其是具有多个参数的时候，会发生多次内存拷贝：

runtime.deferproc执行之前：移动到栈中
runtime.deferproc执行过程中，拷贝_defer之后
runtime.deferreturn执行时，移动到栈中

update：go1.13对defer进行了优化，如果_defer没有发生逃逸，则将其分配在栈上，可以提高30%的性能。